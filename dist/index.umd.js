
  /**
   * Generated on: 1615366415968 
   *      Package: @innovaccer/design-system
   *      Version: v1.7.1-0
   *      License: MIT
   *         Docs: https://innovaccer.github.io/design-system
   */

    
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.InnovaccerDesignSystem = {}, global.React, global.ReactDOM));
}(this, (function (exports, React, ReactDOM) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  var colorToHex = function colorToHex(color) {
    return getComputedStyle(document.documentElement).getPropertyValue("--".concat(color));
  };

  var css = /*#__PURE__*/Object.freeze({
    __proto__: null,
    colorToHex: colorToHex
  });

  function _typeof$p(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$p = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof$p = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$p(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck$p(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$p(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$p(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$p(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$p(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$w(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends$p() {
    _extends$p = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$p.apply(this, arguments);
  }

  function ownKeys$p(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$p(Object(source), true).forEach(function (key) {
          _defineProperty$w(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$p(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits$o(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$o(subClass, superClass);
  }

  function _getPrototypeOf$o(o) {
    _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$o(o);
  }

  function _setPrototypeOf$o(o, p) {
    _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$o(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _objectWithoutPropertiesLoose$b(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties$a(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$b(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized$p(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$o(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$p(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf$o(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$o(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn$o(this, result);
    };
  }

  function _slicedToArray$6(arr, i) {
    return _arrayWithHoles$7(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest$7();
  }

  function _toConsumableArray$9(arr) {
    return _arrayWithoutHoles$9(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread$9();
  }

  function _arrayWithoutHoles$9(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles$7(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray$a(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit$6(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread$9() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest$7() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var _placeholders;

  var placeholders = (_placeholders = {}, _defineProperty$w(_placeholders, 'hh:mm', '--:--'), _defineProperty$w(_placeholders, 'hh:mm AM', '--:-- AM'), _placeholders);
  var isPlaceholderPresent = function isPlaceholderPresent(placeholderChar, time) {
    return time && time.includes(placeholderChar);
  };
  var isFormat12hour = function isFormat12hour(format) {
    return format === 'hh:mm AM';
  };

  var get12hourFormat = function get12hourFormat(hours) {
    var AMPM = hours < 12 ? 'AM' : 'PM';
    var hrs = hours % 12 || 12;
    return {
      hrs: hrs,
      AMPM: AMPM
    };
  };

  var get24hourFormat = function get24hourFormat(hours, am_pm) {
    var convertedHours = hours;

    if (am_pm) {
      if (am_pm === 'PM' && hours < 12) {
        convertedHours = hours + 12;
      } else if (am_pm === 'AM' && hours === 12) {
        convertedHours = hours - 12;
      }

      return convertedHours;
    }

    return hours;
  };

  var translateToTime = function translateToTime(format, time) {
    if (!time) return '';

    if (typeof time === 'number') {
      var timeObj = getTimeObjectFromNumber(format, time);
      return translateToString$1(format, timeObj);
    }

    return time;
  };

  var getTimeObjectFromNumber = function getTimeObjectFromNumber(format, time) {
    var d = new Date(time);
    var hrs = d.getHours();
    var hours = isFormat12hour(format) ? get12hourFormat(hrs).hrs : hrs;
    var am_pm = isFormat12hour(format) ? get12hourFormat(hrs).AMPM : '';
    var minutes = d.getMinutes();
    var seconds = d.getSeconds();
    return {
      hours: hours,
      minutes: minutes,
      seconds: seconds,
      am_pm: am_pm
    };
  };

  var getTimeObjFromStr = function getTimeObjFromStr(format, time) {
    var separator = ':';
    var hours = 0;
    var minutes = 0;
    var len = format.length;
    var timeLength = time.length;
    var lastChars = format.substring(len - 2, len);
    var is12hrFormat = lastChars === 'AM' || lastChars === 'PM';
    var am_pm = is12hrFormat ? time.substring(timeLength - 2, timeLength) : '';
    var timeFormat = is12hrFormat ? time.substring(0, timeLength - 3) : time;
    var inputFormat = is12hrFormat ? format.substring(0, len - 3) : format;
    var v = timeFormat.split(separator);
    inputFormat.split(separator).forEach(function (f, i) {
      switch (f) {
        case 'hh':
          hours = +v[i] || 0;
          break;

        case 'mm':
          minutes = +v[i] || 0;
          break;
      }
    });
    return {
      hours: hours,
      minutes: minutes,
      am_pm: am_pm
    };
  };
  var getOutputTimeString = function getOutputTimeString(inputFormat, outputFormat, time) {
    if (inputFormat === outputFormat) return time;

    var _getTimeObjFromStr = getTimeObjFromStr(inputFormat, time),
        hours = _getTimeObjFromStr.hours,
        minutes = _getTimeObjFromStr.minutes,
        am_pm = _getTimeObjFromStr.am_pm;

    var AMPM = isFormat12hour(outputFormat) ? get12hourFormat(hours).AMPM : '';
    var hrs = isFormat12hour(outputFormat) ? get12hourFormat(hours).hrs : get24hourFormat(hours, am_pm);
    var timeStr = translateToString$1(outputFormat, {
      minutes: minutes,
      hours: hrs,
      am_pm: AMPM
    });
    return timeStr;
  };

  var translateToString$1 = function translateToString(format, time) {
    var hours = time.hours,
        minutes = time.minutes,
        am_pm = time.am_pm;
    var separator = ':';
    var timeFormat = format.split(' ');
    var v = timeFormat[0].split(separator);
    var val = '';
    v.forEach(function (f, i) {
      switch (f) {
        case 'hh':
          val += hours < 10 ? "0".concat(hours) : hours;
          break;

        case 'mm':
          val += minutes < 10 ? "0".concat(minutes) : minutes;
          break;
      }

      if (i !== f.length - 1) val += separator;
    });
    val += isFormat12hour(format) && am_pm ? " ".concat(am_pm) : '';
    return val;
  };

  var isValid = function isValid(validators) {
    for (var _len = arguments.length, value = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      value[_key - 1] = arguments[_key];
    }

    var iterator = Array.isArray(validators) ? validators : [validators];
    return iterator.every(function (validator) {
      return validator.apply(void 0, value);
    });
  };
  var date$3 = function date(val, format) {
    var validate = function validate(date, month, year) {
      var monthLength = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Adjust for leap years

      if (year % 400 == 0 || year % 100 != 0 && year % 4 == 0) monthLength[1] = 29; // Check the range of the day

      return month <= 12 && date <= monthLength[month - 1];
    };

    switch (format) {
      case 'dd/mm/yyyy':
        var p = val.split('/');
        var date = +p[0] || 1;
        var month = +p[1] || 1;
        var year = +p[2] || 1900;
        return validate(date, month, year);

      case 'mm/dd/yyyy':
        var p = val.split('/');
        var date = +p[1] || 1;
        var month = +p[0] || 1;
        var year = +p[2] || 1900;
        return validate(date, month, year);

      case 'yyyy/mm/dd':
        var p = val.split('/');
        var date = +p[2] || 1;
        var month = +p[1] || 1;
        var year = +p[0] || 1900;
        return validate(date, month, year);

      case 'dd-mm-yyyy':
        var p = val.split('-');
        var date = +p[0] || 1;
        var month = +p[1] || 1;
        var year = +p[2] || 1900;
        return validate(date, month, year);

      case 'mm-dd-yyyy':
        var p = val.split('-');
        var date = +p[1] || 1;
        var month = +p[0] || 1;
        var year = +p[2] || 1900;
        return validate(date, month, year);

      case 'yyyy-mm-dd':
        var p = val.split('-');
        var date = +p[2] || 1;
        var month = +p[1] || 1;
        var year = +p[0] || 1900;
        return validate(date, month, year);

      default:
        return false;
    }
  };
  var time$2 = function time(val, format) {
    var _getTimeObjFromStr = getTimeObjFromStr(format, val),
        hours = _getTimeObjFromStr.hours,
        minutes = _getTimeObjFromStr.minutes;

    var hoursCond = isFormat12hour(format) ? hours <= 12 : hours < 24;
    return hoursCond && minutes <= 60;
  };

  var validators = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isValid: isValid,
    date: date$3,
    time: time$2
  });

  var _time;

  var date$2 = {
    'dd/mm/yyyy': [/[0123]/, /\d/, '/', /\[01]/, /\d/, '/', /\d/, /\d/, /\d/, /\d/],
    'mm/dd/yyyy': [/[01]/, /\d/, '/', /[0123]/, /\d/, '/', /\d/, /\d/, /\d/, /\d/],
    'yyyy/mm/dd': [/\d/, /\d/, /\d/, /\d/, '/', /[01]/, /\d/, '/', /[0123]/, /\d/],
    'dd-mm-yyyy': [/[0123]/, /\d/, '-', /[01]/, /\d/, '-', /\d/, /\d/, /\d/, /\d/],
    'mm-dd-yyyy': [/[01]/, /\d/, '-', /[0123]/, /\d/, '-', /\d/, /\d/, /\d/, /\d/],
    'yyyy-mm-dd': [/\d/, /\d/, /\d/, /\d/, '-', /[01]/, /\d/, '-', /[0123]/, /\d/]
  };
  var rangeDate = {
    'dd/mm/yyyy': [/[0123]/, /\d/, '/', /\[01]/, /\d/, '/', /\d/, /\d/, /\d/, /\d/, ' ', '-', ' ', /[0123]/, /\d/, '/', /\[01]/, /\d/, '/', /\d/, /\d/, /\d/, /\d/],
    'mm/dd/yyyy': [/[01]/, /\d/, '/', /[0123]/, /\d/, '/', /\d/, /\d/, /\d/, /\d/, ' ', '-', ' ', /[01]/, /\d/, '/', /[0123]/, /\d/, '/', /\d/, /\d/, /\d/, /\d/],
    'yyyy/mm/dd': [/\d/, /\d/, /\d/, /\d/, '/', /[01]/, /\d/, '/', /[0123]/, /\d/, ' ', '-', ' ', /\d/, /\d/, /\d/, /\d/, '/', /[01]/, /\d/, '/', /[0123]/, /\d/],
    'dd-mm-yyyy': [/[0123]/, /\d/, '-', /[01]/, /\d/, '-', /\d/, /\d/, /\d/, /\d/, ' ', '-', ' ', /[0123]/, /\d/, '-', /[01]/, /\d/, '-', /\d/, /\d/, /\d/, /\d/],
    'mm-dd-yyyy': [/[01]/, /\d/, '-', /[0123]/, /\d/, '-', /\d/, /\d/, /\d/, /\d/, ' ', '-', ' ', /[01]/, /\d/, '-', /[0123]/, /\d/, '-', /\d/, /\d/, /\d/, /\d/],
    'yyyy-mm-dd': [/\d/, /\d/, /\d/, /\d/, '-', /[01]/, /\d/, '-', /[0123]/, /\d/, ' ', '-', ' ', /\d/, /\d/, /\d/, /\d/, '-', /[01]/, /\d/, '-', /[0123]/, /\d/]
  };
  var time$1 = (_time = {}, _defineProperty$w(_time, 'hh:mm', [/[0-1-2]/, /\d/, ':', /[0-5]/, /\d/]), _defineProperty$w(_time, 'hh:mm AM', [/[0-1]/, /\d/, ':', /[0-5]/, /\d/, ' ', /[APap]/, 'M']), _time);

  var masks = /*#__PURE__*/Object.freeze({
    __proto__: null,
    date: date$2,
    rangeDate: rangeDate,
    time: time$1
  });

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    css: css,
    validators: validators,
    masks: masks
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var classnames = createCommonjsModule(function (module) {
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  /* global define */

  (function () {

  	var hasOwn = {}.hasOwnProperty;

  	function classNames () {
  		var classes = [];

  		for (var i = 0; i < arguments.length; i++) {
  			var arg = arguments[i];
  			if (!arg) continue;

  			var argType = typeof arg;

  			if (argType === 'string' || argType === 'number') {
  				classes.push(arg);
  			} else if (Array.isArray(arg) && arg.length) {
  				var inner = classNames.apply(null, arg);
  				if (inner) {
  					classes.push(inner);
  				}
  			} else if (argType === 'object') {
  				for (var key in arg) {
  					if (hasOwn.call(arg, key) && arg[key]) {
  						classes.push(key);
  					}
  				}
  			}
  		}

  		return classes.join(' ');
  	}

  	if (module.exports) {
  		classNames.default = classNames;
  		module.exports = classNames;
  	} else {
  		window.classNames = classNames;
  	}
  }());
  });

  // export type DefaultProps<T> = T extends { defaultProps: any }
  //   ? T['defaultProps']
  //   : {};
  // export type Props<T, U> = Omit<T, keyof U> & {
  //   [P in keyof T & keyof U]?: T[P];
  // };
  var extractBaseProps = function extractBaseProps(props) {
    var baseProps = ['className', 'data-test'];
    var basePropsObj = baseProps.reduce(function (acc, curr) {
      return props[curr] ? _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty$w({}, curr, props[curr])) : _objectSpread2({}, acc);
    }, {});
    return basePropsObj;
  };
  var filterProps = function filterProps(props, propsList, include) {
    return Object.entries(props).filter(function (obj) {
      return include ? propsList.includes(obj[0]) : !propsList.includes(obj[0]);
    }).reduce(function (acc, curr) {
      acc[curr[0]] = curr[1];
      return acc;
    }, {});
  };

  var initialsLength = 2;
  var Avatar = function Avatar(props) {
    var _classNames, _classNames2;

    var withTooltip = props.withTooltip,
        tooltipPosition = props.tooltipPosition,
        size = props.size,
        children = props.children,
        firstName = props.firstName,
        lastName = props.lastName,
        className = props.className,
        appearance = props.appearance;
    var baseProps = extractBaseProps(props);
    var initials = children ? children.trim().slice(0, initialsLength) : "".concat(firstName ? firstName.trim()[0] : '').concat(lastName ? lastName.trim()[0] : '');
    var tooltip = children || "".concat(firstName || '', " ").concat(lastName || '') || '';
    var DefaultAppearance = 'secondary';
    var colors = ['accent4', 'primary', 'accent3', 'alert', 'accent2', 'warning', 'accent1', 'success'];
    var AvatarAppearance = appearance || colors[(initials.charCodeAt(0) + (initials.charCodeAt(1) || 0)) % 8] || DefaultAppearance;
    var classes = classnames((_classNames = {
      Avatar: true
    }, _defineProperty$w(_classNames, "Avatar--".concat(size), size), _defineProperty$w(_classNames, "Avatar--".concat(AvatarAppearance), AvatarAppearance), _defineProperty$w(_classNames, 'Avatar--disabled', !initials || !withTooltip), _classNames), className);
    var ContentClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, "Avatar-content--".concat(size), size), _defineProperty$w(_classNames2, "Avatar-content--".concat(AvatarAppearance), AvatarAppearance), _classNames2));
    var IconClass = classnames(_defineProperty$w({}, "Avatar-content--".concat(AvatarAppearance), AvatarAppearance));

    var renderAvatar = function renderAvatar() {
      return /*#__PURE__*/React.createElement("span", _extends$p({
        "data-test": "DesignSystem-Avatar"
      }, baseProps, {
        className: classes
      }), initials && /*#__PURE__*/React.createElement(Text$1, {
        weight: "medium",
        appearance: 'white',
        className: ContentClass
      }, initials), !initials && /*#__PURE__*/React.createElement(Icon, {
        "data-test": "DesignSystem-AvatarIcon",
        name: "person",
        size: size === 'regular' ? 16 : 12,
        appearance: 'white',
        className: IconClass
      }));
    };

    var renderTooltip = function renderTooltip() {
      if (withTooltip && initials) {
        return /*#__PURE__*/React.createElement(Tooltip, {
          tooltip: tooltip,
          position: tooltipPosition,
          triggerClass: 'flex-grow-0'
        }, renderAvatar());
      }

      return renderAvatar();
    };

    return renderTooltip();
  };
  Avatar.displayName = 'Avatar';
  Avatar.defaultProps = {
    tooltipPosition: 'bottom',
    withTooltip: true,
    size: 'regular'
  };

  var AvatarGroup = function AvatarGroup(props) {
    var max = props.max,
        borderColor = props.borderColor,
        popoverOptions = props.popoverOptions,
        tooltipPosition = props.tooltipPosition,
        list = props.list,
        className = props.className;
    var popperRenderer = popoverOptions.popperRenderer,
        _popoverOptions$maxHe = popoverOptions.maxHeight,
        maxHeight = _popoverOptions$maxHe === void 0 ? 150 : _popoverOptions$maxHe,
        _popoverOptions$posit = popoverOptions.position,
        position = _popoverOptions$posit === void 0 ? 'bottom' : _popoverOptions$posit,
        _popoverOptions$on = popoverOptions.on,
        on = _popoverOptions$on === void 0 ? 'hover' : _popoverOptions$on,
        _popoverOptions$dark = popoverOptions.dark,
        dark = _popoverOptions$dark === void 0 ? true : _popoverOptions$dark,
        _popoverOptions$appen = popoverOptions.appendToBody,
        appendToBody = _popoverOptions$appen === void 0 ? true : _popoverOptions$appen,
        _popoverOptions$poppe = popoverOptions.popperClassName,
        popperClassName = _popoverOptions$poppe === void 0 ? '' : _popoverOptions$poppe;
    var baseProps = extractBaseProps(props);
    var extraAvatars = list.length > max ? list.length - max > 9 ? 9 : list.length - max : 0;
    var style = {
      borderRadius: '50%',
      backgroundColor: "".concat(borderColor),
      border: "var(--spacing-xs) solid ".concat(borderColor),
      boxShadow: "0 0 0 var(--spacing-xs) ".concat(borderColor)
    };
    var AvatarGroupClass = classnames(_defineProperty$w({}, 'AvatarGroup', true), className);
    var popperClass = classnames(_defineProperty$w({}, 'AvatarGroup-Popper', true), popperClassName);
    var trigger = /*#__PURE__*/React.createElement("div", {
      "data-test": "DesignSystem-AvatarGroup--TriggerAvatar",
      style: style
    }, /*#__PURE__*/React.createElement(Avatar, {
      appearance: "secondary",
      firstName: "+",
      lastName: "".concat(extraAvatars),
      withTooltip: false
    }));

    var renderPopper = function renderPopper() {
      var extraAvatarsList = list.slice(max, list.length);

      if (popperRenderer && typeof renderPopper === 'function') {
        return popperRenderer(extraAvatarsList);
      }

      return /*#__PURE__*/React.createElement("div", {
        className: "py-6 pr-4 pl-6"
      }, /*#__PURE__*/React.createElement("div", {
        className: "AvatarGroup-TextWrapper",
        style: {
          maxHeight: maxHeight
        }
      }, extraAvatarsList.map(function (item, ind) {
        var _item$firstName = item.firstName,
            firstName = _item$firstName === void 0 ? '' : _item$firstName,
            _item$lastName = item.lastName,
            lastName = _item$lastName === void 0 ? '' : _item$lastName;
        var name = "".concat(firstName, " ").concat(lastName);
        return /*#__PURE__*/React.createElement(Text$1, {
          key: ind,
          appearance: dark ? 'white' : 'default',
          className: ind < extraAvatars - 1 ? 'mb-5' : '',
          "data-test": "DesignSystem-AvatarGroup--Text"
        }, name);
      })));
    };

    var renderAvatars = function renderAvatars() {
      var avatars = list.slice(0, max).map(function (item, index) {
        var appearance = item.appearance,
            firstName = item.firstName,
            lastName = item.lastName;
        return /*#__PURE__*/React.createElement("div", {
          "data-test": "DesignSystem-AvatarGroup--Avatar",
          className: "AvatarGroup-item",
          style: style,
          key: index
        }, /*#__PURE__*/React.createElement(Avatar, {
          appearance: appearance,
          firstName: firstName,
          lastName: lastName,
          withTooltip: true,
          tooltipPosition: tooltipPosition
        }));
      });
      return avatars;
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-AvatarGroup"
    }, baseProps, {
      className: "".concat(AvatarGroupClass, " d-inline-flex")
    }), renderAvatars(), list.length - max > 0 && /*#__PURE__*/React.createElement(Popover, {
      on: on,
      dark: dark,
      trigger: trigger,
      position: position,
      appendToBody: appendToBody,
      className: popperClass
    }, renderPopper()));
  };
  AvatarGroup.displayName = 'AvatarGroup';
  AvatarGroup.defaultProps = {
    max: 2,
    borderColor: 'var(--white)',
    tooltipPosition: 'bottom',
    popoverOptions: {}
  };

  var useEffect$1 = React.useEffect,
      useState$2 = React.useState;
  var Backdrop = function Backdrop(props) {
    var className = props.className;
    var baseProps = extractBaseProps(props);

    var _useState = useState$2(null),
        _useState2 = _slicedToArray$6(_useState, 2),
        savedBodyOverflow = _useState2[0],
        setBodyOverflow = _useState2[1];

    var _React$useState = React.useState(props.open),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        open = _React$useState2[0],
        setOpen = _React$useState2[1];

    var _React$useState3 = React.useState(props.open),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        animate = _React$useState4[0],
        setAnimate = _React$useState4[1];

    var classes = classnames({
      Backdrop: true,
      'Backdrop--open': open,
      'Backdrop-animation--open': animate,
      'Backdrop-animation--close': !animate
    }, className);

    var disableBodyScroll = function disableBodyScroll() {
      document.body.style.setProperty('overflow', 'hidden', 'important');
    };

    var enableBodyScroll = function enableBodyScroll() {
      document.body.style.overflow = savedBodyOverflow || '';
      setBodyOverflow(null);
    };

    useEffect$1(function () {
      if (props.open) {
        setBodyOverflow(document.body.style.overflow);
        disableBodyScroll();
        setOpen(true);
        setAnimate(true);
      }

      if (!props.open) {
        window.setTimeout(function () {
          setOpen(false);
        }, 120);
        setAnimate(false);
        enableBodyScroll();
      }
    }, [props.open]);
    var BackdropElement = /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-Backdrop",
      "data-layer": true
    }, baseProps, {
      className: classes
    })), document.body);
    return BackdropElement;
  };
  Backdrop.displayName = 'Backdrop';

  var Badge = function Badge(props) {
    var _classNames;

    var appearance = props.appearance,
        children = props.children,
        subtle = props.subtle,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {
      Badge: true
    }, _defineProperty$w(_classNames, "Badge--".concat(appearance), appearance && !subtle), _defineProperty$w(_classNames, "Badge--subtle-".concat(appearance), subtle), _classNames), className);
    return /*#__PURE__*/React.createElement("span", _extends$p({
      "data-test": "DesignSystem-Badge"
    }, baseProps, {
      className: classes
    }), children);
  };
  Badge.displayName = 'Badge';
  Badge.defaultProps = {
    appearance: 'secondary'
  };

  /* eslint-disable no-undefined,no-param-reassign,no-shadow */

  /**
   * Throttle execution of a function. Especially useful for rate limiting
   * execution of handlers on events like resize and scroll.
   *
   * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
   * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
   *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
   *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
   *                                    the internal counter is reset).
   * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
   *                                    to `callback` when the throttled-function is executed.
   * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
   *                                    schedule `callback` to execute after `delay` ms.
   *
   * @returns {Function}  A new, throttled, function.
   */
  function throttle$3 (delay, noTrailing, callback, debounceMode) {
    /*
     * After wrapper has stopped being called, this timeout ensures that
     * `callback` is executed at the proper times in `throttle` and `end`
     * debounce modes.
     */
    var timeoutID;
    var cancelled = false; // Keep track of the last time `callback` was executed.

    var lastExec = 0; // Function to clear existing timeout

    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    } // Function to cancel next exec


    function cancel() {
      clearExistingTimeout();
      cancelled = true;
    } // `noTrailing` defaults to falsy.


    if (typeof noTrailing !== 'boolean') {
      debounceMode = callback;
      callback = noTrailing;
      noTrailing = undefined;
    }
    /*
     * The `wrapper` function encapsulates all of the throttling / debouncing
     * functionality and when executed will limit the rate at which `callback`
     * is executed.
     */


    function wrapper() {
      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
        arguments_[_key] = arguments[_key];
      }

      var self = this;
      var elapsed = Date.now() - lastExec;

      if (cancelled) {
        return;
      } // Execute `callback` and update the `lastExec` timestamp.


      function exec() {
        lastExec = Date.now();
        callback.apply(self, arguments_);
      }
      /*
       * If `debounceMode` is true (at begin) this is used to clear the flag
       * to allow future `callback` executions.
       */


      function clear() {
        timeoutID = undefined;
      }

      if (debounceMode && !timeoutID) {
        /*
         * Since `wrapper` is being called for the first time and
         * `debounceMode` is true (at begin), execute `callback`.
         */
        exec();
      }

      clearExistingTimeout();

      if (debounceMode === undefined && elapsed > delay) {
        /*
         * In throttle mode, if `delay` time has been exceeded, execute
         * `callback`.
         */
        exec();
      } else if (noTrailing !== true) {
        /*
         * In trailing throttle mode, since `delay` time has not been
         * exceeded, schedule `callback` to execute `delay` ms after most
         * recent execution.
         *
         * If `debounceMode` is true (at begin), schedule `clear` to execute
         * after `delay` ms.
         *
         * If `debounceMode` is false (at end), schedule `callback` to
         * execute after `delay` ms.
         */
        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
      }
    }

    wrapper.cancel = cancel; // Return the wrapper function.

    return wrapper;
  }

  /* eslint-disable no-undefined */
  /**
   * Debounce execution of a function. Debouncing, unlike throttling,
   * guarantees that a function is only executed a single time, either at the
   * very beginning of a series of calls, or at the very end.
   *
   * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
   * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
   *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
   *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
   * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
   *                                  to `callback` when the debounced-function is executed.
   *
   * @returns {Function} A new, debounced function.
   */

  function debounce$4 (delay, atBegin, callback) {
    return callback === undefined ? throttle$3(delay, atBegin, false) : throttle$3(delay, callback, atBegin !== false);
  }

  var getSearchedOptions = function getSearchedOptions(options, searchTerm) {
    var result = options.filter(function (option) {
      return option.label.toLowerCase().includes(searchTerm.toLowerCase());
    });
    return result;
  };
  var _isEqual = function _isEqual(arr1, arr2) {
    return arr1.length === arr2.length && arr1.every(function (option, index) {
      return option.value === arr2[index].value || option.label === arr2[index].label;
    });
  };
  var _isControlled = function _isControlled(selected) {
    return selected !== undefined;
  };
  var _isOpenControlled = function _isOpenControlled(open) {
    return open !== undefined;
  };
  var _showSelectedItems = function _showSelectedItems(bulk, searchTerm, withCheckbox) {
    return bulk && withCheckbox && searchTerm === '';
  };
  var _isSelectAllPresent = function _isSelectAllPresent(searchTerm, bulkOptions, withSelectAll, withCheckbox) {
    return withCheckbox && withSelectAll && bulkOptions === 0 && searchTerm === '';
  };
  var scrollTo = function scrollTo(element, top) {
    element.scrollTo(0, top);
  };
  var scrollIntoView = function scrollIntoView(menuElement, focusedElement) {
    var menuRect = menuElement === null || menuElement === void 0 ? void 0 : menuElement.getBoundingClientRect();
    var focusedRect = focusedElement.getBoundingClientRect();
    var overscroll = focusedElement.offsetHeight;

    if (focusedRect.bottom > menuRect.bottom && menuElement) {
      scrollTo(menuElement, focusedElement.offsetTop - menuRect.height + overscroll);
    } else if (focusedRect.top < menuRect.top && menuElement) {
      scrollTo(menuElement, focusedElement.offsetTop - overscroll);
    }
  };
  var getSelectAll$1 = function getSelectAll(selected, optionsLength, disabledOptionsLength) {
    if (selected.length) {
      if (selected.length > 0 && disabledOptionsLength > 0 && selected.length === optionsLength - disabledOptionsLength) {
        return {
          indeterminate: true,
          checked: true
        }; //
      }

      var indeterminate = selected.length > 0 && selected.length !== optionsLength;
      var checked = selected.length > 0 && selected.length === optionsLength;
      var obj = {
        checked: checked,
        indeterminate: indeterminate
      };
      return obj;
    }

    return {
      indeterminate: false,
      checked: false
    };
  };

  var DropdownButton = /*#__PURE__*/React.forwardRef(function (props, ref) {
    var _classNames, _classNames2;

    var _props$triggerSize = props.triggerSize,
        triggerSize = _props$triggerSize === void 0 ? 'regular' : _props$triggerSize,
        _props$placeholder = props.placeholder,
        placeholder = _props$placeholder === void 0 ? 'Select' : _props$placeholder,
        _props$menu = props.menu,
        menu = _props$menu === void 0 ? false : _props$menu,
        children = props.children,
        icon = props.icon,
        disabled = props.disabled,
        open = props.open,
        inlineLabel = props.inlineLabel,
        error = props.error,
        rest = _objectWithoutProperties$a(props, ["triggerSize", "placeholder", "menu", "children", "icon", "disabled", "open", "inlineLabel", "error"]);

    var buttonDisabled = disabled ? 'disabled' : 'default';
    var trimmedPlaceholder = placeholder.trim();
    var value = children ? children : trimmedPlaceholder;
    var iconName = !menu ? 'keyboard_arrow_down' : icon ? icon : 'more_horiz';
    var buttonClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Button', true), _defineProperty$w(_classNames, 'DropdownButton', true), _defineProperty$w(_classNames, "DropdownButton--".concat(triggerSize), triggerSize), _defineProperty$w(_classNames, "DropdownButton--".concat(triggerSize, "Square"), menu), _defineProperty$w(_classNames, 'DropdownButton--placeholder', !children && !menu), _defineProperty$w(_classNames, 'DropdownButton--icon', icon), _defineProperty$w(_classNames, 'DropdownButton--open', open), _defineProperty$w(_classNames, 'DropdownButton--error', error), _classNames));
    var textClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Text', true), _defineProperty$w(_classNames2, 'Text--regular', true), _defineProperty$w(_classNames2, 'DropdownButton-text', true), _classNames2));
    return /*#__PURE__*/React.createElement("button", _extends$p({
      ref: ref,
      type: "button",
      value: children,
      className: buttonClass,
      disabled: disabled,
      tabIndex: 0,
      "data-test": "DesignSystem-DropdownTrigger"
    }, rest), !menu && /*#__PURE__*/React.createElement("div", {
      className: "DropdownButton-wrapper"
    }, inlineLabel && /*#__PURE__*/React.createElement(Text$1, {
      appearance: "subtle",
      className: "mr-4"
    }, "".concat(inlineLabel.trim().charAt(0).toUpperCase()).concat(inlineLabel.trim().slice(1))), icon && !inlineLabel && /*#__PURE__*/React.createElement(Icon, {
      appearance: buttonDisabled,
      className: "d-flex align-items-center mr-4",
      name: icon
    }), value && /*#__PURE__*/React.createElement("span", {
      className: textClass
    }, value)), /*#__PURE__*/React.createElement(Icon, {
      appearance: buttonDisabled,
      name: iconName
    }));
  });
  DropdownButton.displayName = 'DropdownButton';

  var GenericText = function GenericText(_ref) {
    var children = _ref.children,
        _ref$componentType = _ref.componentType,
        componentType = _ref$componentType === void 0 ? 'span' : _ref$componentType,
        className = _ref.className,
        props = _objectWithoutProperties$a(_ref, ["children", "componentType", "className"]);

    return /*#__PURE__*/React.createElement(componentType, _objectSpread2(_objectSpread2({}, props), {}, {
      className: className
    }), children);
  };

  var Text$1 = function Text(props) {
    var _classNames;

    var appearance = props.appearance,
        size = props.size,
        children = props.children,
        weight = props.weight,
        small = props.small,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {
      Text: true
    }, _defineProperty$w(_classNames, "Text--".concat(appearance), appearance), _defineProperty$w(_classNames, "Text--".concat(weight), weight), _defineProperty$w(_classNames, "Text--".concat(size), size), _defineProperty$w(_classNames, 'Text--small', size === 'small' || small), _classNames), className);
    return /*#__PURE__*/React.createElement(GenericText, _extends$p({
      "data-test": "DesignSystem-Text"
    }, baseProps, {
      className: classes,
      componentType: "span"
    }), children);
  };
  Text$1.displayName = 'Text';
  Text$1.defaultProps = {
    appearance: 'default',
    size: 'regular'
  };

  var Icon = function Icon(props) {
    var _classNames;

    var appearance = props.appearance,
        className = props.className,
        name = props.name,
        size = props.size,
        onClick = props.onClick,
        children = props.children;
    var baseProps = extractBaseProps(props);

    var mapper = function mapper(val) {
      if (val === 'outline') return 'outlined';
      if (val === 'rounded') return 'round';
      return val;
    };

    var type = mapper(props.type);
    var iconClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'material-icons', true), _defineProperty$w(_classNames, "material-icons-".concat(mapper(type)), type && type !== 'filled'), _defineProperty$w(_classNames, 'Icon', true), _defineProperty$w(_classNames, "Icon--".concat(appearance), appearance), _defineProperty$w(_classNames, "".concat(className), className), _classNames));
    var styles = {
      fontSize: "".concat(size, "px"),
      width: "".concat(size, "px")
    }; // change `children` to {name} after migration

    if (children && /*#__PURE__*/React.isValidElement(children)) {
      return /*#__PURE__*/React.createElement("span", _extends$p({}, baseProps, {
        className: className
      }), children);
    }

    return /*#__PURE__*/React.createElement("i", _extends$p({}, baseProps, {
      className: iconClass,
      style: styles,
      onClick: onClick
    }), type ? "".concat(name, "_").concat(type) : name);
  };
  Icon.displayName = 'Icon';
  Icon.defaultProps = {
    size: 16
  };

  var uidGenerator = function uidGenerator() {
    var dt = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = (dt + Math.random() * 16) % 16 | 0;
      dt = Math.floor(dt / 16);
      var s = (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
      return s;
    });
    return uuid;
  };

  /**
   * ######Checkbox has two types:
   *  - [Controlled Checkbox](https://reactjs.org/docs/forms.html#controlled-components)
   *  - [Uncontrolled Checkbox](https://reactjs.org/docs/uncontrolled-components.html)
   */
  var Checkbox = /*#__PURE__*/React.forwardRef(function (props, forwardedRef) {
    var _classNames, _classNames3, _classNames4, _classNames5;

    var _props$size = props.size,
        size = _props$size === void 0 ? 'regular' : _props$size,
        _props$tabIndex = props.tabIndex,
        tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,
        defaultChecked = props.defaultChecked,
        indeterminate = props.indeterminate,
        label = props.label,
        disabled = props.disabled,
        onChange = props.onChange,
        name = props.name,
        value = props.value,
        className = props.className;
    var ref = React.useRef(null);
    var baseProps = extractBaseProps(props);
    React.useImperativeHandle(forwardedRef, function () {
      return ref.current;
    });

    var _React$useState = React.useState(props.checked === undefined ? defaultChecked : props.checked),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        checked = _React$useState2[0],
        setChecked = _React$useState2[1];

    React.useEffect(function () {
      setIndeterminate(indeterminate);
    }, [indeterminate]);
    React.useEffect(function () {
      if (props.checked !== undefined) {
        setChecked(props.checked);
      }
    }, [props.checked]);
    var CheckboxClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Checkbox', true), _defineProperty$w(_classNames, 'Checkbox--disabled', disabled), _defineProperty$w(_classNames, "Checkbox--".concat(size), size), _classNames), className);
    var CheckboxOuterWrapper = classnames(_defineProperty$w({}, 'Checkbox-outerWrapper', true));
    var CheckboxTextClass = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'Checkbox-label', true), _defineProperty$w(_classNames3, "Checkbox-label--".concat(size), size), _classNames3));
    var CheckboxInputWrapper = classnames((_classNames4 = {}, _defineProperty$w(_classNames4, 'Checkbox-input', true), _defineProperty$w(_classNames4, 'Checkbox-input--checked', checked), _defineProperty$w(_classNames4, 'Checkbox-input--indeterminate', props.indeterminate), _classNames4));
    var CheckboxWrapper = classnames((_classNames5 = {}, _defineProperty$w(_classNames5, 'Checkbox-wrapper', true), _defineProperty$w(_classNames5, "Checkbox-wrapper--".concat(size), size), _classNames5));

    var setIndeterminate = function setIndeterminate(indeterminateValue) {
      ref.current.indeterminate = indeterminateValue;
    };

    var onChangeHandler = function onChangeHandler(e) {
      if (props.checked === undefined) {
        setChecked(e.target.checked);
        setIndeterminate(e.target.indeterminate);
      }

      if (onChange) onChange(e);
    };

    var id = "".concat(name, "-").concat(label, "-").concat(uidGenerator());
    var IconName = indeterminate ? 'remove' : checked ? 'check' : '';
    var IconSize = size === 'tiny' ? 8 : 16;
    return /*#__PURE__*/React.createElement("div", {
      className: CheckboxClass
    }, /*#__PURE__*/React.createElement("div", {
      className: CheckboxOuterWrapper
    }, /*#__PURE__*/React.createElement("input", _extends$p({}, baseProps, {
      type: "checkbox",
      defaultChecked: defaultChecked,
      onChange: onChangeHandler,
      checked: checked,
      disabled: disabled,
      ref: ref,
      name: name,
      value: value,
      className: CheckboxInputWrapper,
      tabIndex: tabIndex,
      id: id
    })), /*#__PURE__*/React.createElement("span", {
      className: CheckboxWrapper
    }, IconName && /*#__PURE__*/React.createElement(Icon, {
      name: IconName,
      size: IconSize,
      appearance: 'white'
    }))), label && label.trim() && /*#__PURE__*/React.createElement("label", {
      htmlFor: id,
      className: CheckboxTextClass
    }, /*#__PURE__*/React.createElement(Text$1, {
      size: size === 'tiny' ? 'small' : 'regular',
      appearance: disabled ? 'disabled' : 'default'
    }, label.trim())));
  });
  Checkbox.displayName = 'Checkbox';

  var CheckboxOption = function CheckboxOption(props) {
    var className = props.className,
        selected = props.selected,
        optionData = props.optionData,
        onChangeHandler = props.onChangeHandler,
        onUpdateActiveOption = props.onUpdateActiveOption,
        dataTest = props.dataTest;
    var label = optionData.label,
        disabled = optionData.disabled;
    return /*#__PURE__*/React.createElement("div", {
      className: className,
      onMouseEnter: onUpdateActiveOption,
      "data-test": dataTest,
      "data-disabled": disabled
    }, /*#__PURE__*/React.createElement(Checkbox, {
      label: label,
      disabled: disabled,
      checked: selected,
      onChange: onChangeHandler,
      tabIndex: -1,
      className: "OptionCheckbox"
    }));
  };

  var DefaultOption = function DefaultOption(props) {
    var className = props.className,
        textClassName = props.textClassName,
        onClickHandler = props.onClickHandler,
        optionData = props.optionData,
        appearance = props.appearance,
        onUpdateActiveOption = props.onUpdateActiveOption,
        dataTest = props.dataTest;
    var label = optionData.label,
        disabled = optionData.disabled;
    return /*#__PURE__*/React.createElement("div", {
      className: className,
      onClick: onClickHandler,
      onMouseEnter: onUpdateActiveOption,
      "data-test": dataTest,
      "data-disabled": disabled
    }, /*#__PURE__*/React.createElement("div", {
      className: 'Option-label'
    }, /*#__PURE__*/React.createElement(Text$1, {
      className: textClassName,
      appearance: appearance
    }, label)));
  };

  var MetaOption = function MetaOption(props) {
    var className = props.className,
        textClassName = props.textClassName,
        onClickHandler = props.onClickHandler,
        optionData = props.optionData,
        onUpdateActiveOption = props.onUpdateActiveOption,
        renderSubInfo = props.renderSubInfo,
        appearance = props.appearance,
        dataTest = props.dataTest;
    var subInfo = optionData.subInfo,
        label = optionData.label,
        disabled = optionData.disabled;
    return /*#__PURE__*/React.createElement("div", {
      className: className,
      onClick: onClickHandler,
      onMouseEnter: onUpdateActiveOption,
      "data-test": dataTest,
      "data-disabled": disabled
    }, /*#__PURE__*/React.createElement("div", {
      className: 'Option-label'
    }, /*#__PURE__*/React.createElement(Text$1, {
      className: textClassName,
      appearance: appearance
    }, label), subInfo && renderSubInfo(subInfo)));
  };

  var IconOption = function IconOption(props) {
    var _classNames;

    var className = props.className,
        textClassName = props.textClassName,
        onClickHandler = props.onClickHandler,
        optionData = props.optionData,
        onUpdateActiveOption = props.onUpdateActiveOption,
        appearance = props.appearance,
        dataTest = props.dataTest;
    var label = optionData.label,
        icon = optionData.icon,
        disabled = optionData.disabled;
    var OptionClass = classnames((_classNames = {}, _defineProperty$w(_classNames, "".concat(className), true), _defineProperty$w(_classNames, 'Option--icon', icon), _classNames));
    return /*#__PURE__*/React.createElement("div", {
      className: OptionClass,
      onClick: onClickHandler,
      onMouseEnter: onUpdateActiveOption,
      "data-test": dataTest,
      "data-disabled": disabled
    }, icon && /*#__PURE__*/React.createElement(Icon, {
      className: "Option-icon mr-4",
      name: icon,
      appearance: appearance
    }), /*#__PURE__*/React.createElement("div", {
      className: 'Option-label'
    }, /*#__PURE__*/React.createElement(Text$1, {
      className: textClassName,
      appearance: appearance
    }, label)));
  };

  var IconWithMetaOption = function IconWithMetaOption(props) {
    var _classNames;

    var className = props.className,
        textClassName = props.textClassName,
        renderSubInfo = props.renderSubInfo,
        onClickHandler = props.onClickHandler,
        optionData = props.optionData,
        onUpdateActiveOption = props.onUpdateActiveOption,
        appearance = props.appearance,
        dataTest = props.dataTest;
    var subInfo = optionData.subInfo,
        label = optionData.label,
        icon = optionData.icon,
        disabled = optionData.disabled;
    var OptionClass = classnames((_classNames = {}, _defineProperty$w(_classNames, "".concat(className), true), _defineProperty$w(_classNames, 'Option--icon', icon), _classNames));
    return /*#__PURE__*/React.createElement("div", {
      className: OptionClass,
      onClick: onClickHandler,
      onMouseEnter: onUpdateActiveOption,
      "data-test": dataTest,
      "data-disabled": disabled
    }, icon && /*#__PURE__*/React.createElement(Icon, {
      className: "Option-icon mr-4",
      name: icon,
      appearance: appearance
    }), /*#__PURE__*/React.createElement("div", {
      className: 'Option-label'
    }, /*#__PURE__*/React.createElement(Text$1, {
      className: textClassName,
      appearance: appearance
    }, label), subInfo && renderSubInfo(subInfo)));
  };

  var _OptionTypeMapping;
  var OptionTypeMapping = (_OptionTypeMapping = {}, _defineProperty$w(_OptionTypeMapping, 'DEFAULT', DefaultOption), _defineProperty$w(_OptionTypeMapping, 'WITH_ICON', IconOption), _defineProperty$w(_OptionTypeMapping, 'WITH_META', MetaOption), _defineProperty$w(_OptionTypeMapping, 'WITH_CHECKBOX', CheckboxOption), _defineProperty$w(_OptionTypeMapping, 'ICON_WITH_META', IconWithMetaOption), _OptionTypeMapping);

  var Option = function Option(props) {
    var _classNames, _classNames2, _classNames3, _classNames4;

    var optionData = props.optionData,
        selected = props.selected,
        onClick = props.onClick,
        updateActiveOption = props.updateActiveOption,
        onChange = props.onChange,
        active = props.active,
        index = props.index,
        checkboxes = props.checkboxes,
        menu = props.menu;

    var _ref = optionData.optionType ? optionData : props,
        _ref$optionType = _ref.optionType,
        optionType = _ref$optionType === void 0 ? 'DEFAULT' : _ref$optionType;

    var disabled = optionData.disabled;
    var OptionClassName = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Option', true), _defineProperty$w(_classNames, 'Option--active', active), _defineProperty$w(_classNames, 'Option--selected', selected && !menu), _defineProperty$w(_classNames, 'Option--disabled', disabled), _defineProperty$w(_classNames, 'OptionWrapper', true), _classNames));
    var CheckboxClassName = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Option-checkbox', true), _defineProperty$w(_classNames2, 'Option-checkbox--active', active), _defineProperty$w(_classNames2, 'OptionWrapper', true), _classNames2));
    var textClassName = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'Option-text', true), _defineProperty$w(_classNames3, 'Option-text--wrap', !props.truncateOption), _classNames3));
    var customOptionClass = classnames((_classNames4 = {}, _defineProperty$w(_classNames4, 'OptionWrapper', true), _defineProperty$w(_classNames4, 'OptionWrapper--disabled', disabled), _classNames4));

    var onUpdateActiveOption = function onUpdateActiveOption() {
      if (disabled) return;
      if (updateActiveOption) updateActiveOption(index);
    };

    var onClickHandler = function onClickHandler(e) {
      if (disabled) return;
      e.stopPropagation();
      if (onClick) onClick();
    };

    var onChangeHandler = function onChangeHandler(e) {
      if (disabled) return;
      e.stopPropagation();
      if (onChange) onChange(e);
    };

    if (props.optionRenderer) {
      return /*#__PURE__*/React.createElement("div", _extends$p({
        className: customOptionClass,
        "data-disabled": disabled,
        onMouseEnter: onUpdateActiveOption
      }, !checkboxes && {
        onClick: onClick
      }), props.optionRenderer({
        optionData: optionData,
        selected: selected,
        onChange: onChange,
        active: active,
        index: index
      }));
    }

    var renderSubInfo = function renderSubInfo(subInfo) {
      var labelAppearance = disabled ? 'disabled' : selected ? 'white' : 'subtle';
      var iconAppearance = selected ? 'white' : 'disabled';

      if (typeof subInfo === 'string') {
        return /*#__PURE__*/React.createElement(Text$1, {
          appearance: labelAppearance
        }, subInfo);
      }

      var _subInfo$list = subInfo.list,
          list = _subInfo$list === void 0 ? [] : _subInfo$list,
          seperator = subInfo.seperator;
      return /*#__PURE__*/React.createElement(MetaList, {
        list: list,
        seperator: seperator,
        iconAppearance: iconAppearance,
        labelAppearance: labelAppearance,
        seperatorAppearance: iconAppearance
      });
    };

    var appearance = disabled ? 'disabled' : selected && !menu ? 'white' : 'default';
    var type = checkboxes ? 'WITH_CHECKBOX' : optionType;
    var component = OptionTypeMapping[type];
    return component({
      selected: selected,
      index: index,
      renderSubInfo: renderSubInfo,
      optionData: optionData,
      textClassName: textClassName,
      appearance: appearance,
      onClickHandler: onClickHandler,
      onChangeHandler: onChangeHandler,
      onUpdateActiveOption: onUpdateActiveOption,
      dataTest: "DesignSystem-DropdownOption--".concat(type),
      className: checkboxes ? CheckboxClassName : OptionClassName
    });
  };

  var PlaceholderParagraph = function PlaceholderParagraph(props) {
    var _classNames2;

    var length = props.length,
        size = props.size,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames(_defineProperty$w({
      'Placeholder--animation': true,
      PlaceholderParagraph: true
    }, "PlaceholderParagraph--".concat(size), size));
    var wrapperClass = classnames((_classNames2 = {
      'PlaceholderParagraph-wrapper': true
    }, _defineProperty$w(_classNames2, "PlaceholderParagraph-wrapper--length-".concat(length), length), _defineProperty$w(_classNames2, "PlaceholderParagraph-wrapper--size-".concat(size), size), _classNames2), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: wrapperClass
    }), /*#__PURE__*/React.createElement("span", {
      className: classes
    }));
  };
  PlaceholderParagraph.displayName = 'PlaceholderParagraph';
  PlaceholderParagraph.defaultProps = {
    length: 'medium'
  };

  var PlaceholderImage = function PlaceholderImage(props) {
    var _classNames;

    var _props$size = props.size,
        size = _props$size === void 0 ? 'small' : _props$size,
        round = props.round,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {
      PlaceholderImage: true,
      'Placeholder--animation': true
    }, _defineProperty$w(_classNames, 'PlaceholderImage--round', round), _defineProperty$w(_classNames, "PlaceholderImage--".concat(size), size), _classNames), className);
    return /*#__PURE__*/React.createElement("span", _extends$p({}, baseProps, {
      className: classes
    }));
  };
  PlaceholderImage.displayName = 'PlaceholderImage';
  PlaceholderImage.defaultProps = {
    size: 'small'
  };

  var Placeholder = function Placeholder(props) {
    var imageSize = props.imageSize,
        withImage = props.withImage,
        round = props.round,
        children = props.children,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var paragraphClasses = classnames(_defineProperty$w({
      'Placeholder-paragraph': true
    }, 'Placeholder-paragraph--withImage', withImage));
    var classes = classnames(_defineProperty$w({}, 'Placeholder', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-Placeholder"
    }, baseProps, {
      className: classes
    }), withImage && /*#__PURE__*/React.createElement(PlaceholderImage, {
      round: round,
      size: imageSize,
      "data-test": "DesignSystem-Placeholder--Image"
    }), children && /*#__PURE__*/React.createElement("div", {
      className: paragraphClasses,
      "data-test": "DesignSystem-Placeholder--Paragraph"
    }, children));
  };
  Placeholder.displayName = 'Placeholder';
  Placeholder.defaultProps = {
    withImage: true,
    imageSize: 'small'
  };

  var Loading = function Loading(props) {
    var loadingType = props.loadingType;

    switch (loadingType) {
      case 'DEFAULT':
        return /*#__PURE__*/React__default['default'].createElement(PlaceholderParagraph, {
          length: 'large'
        });

      case 'WITH_ICON':
        return /*#__PURE__*/React__default['default'].createElement(Placeholder, {
          withImage: true,
          round: true
        }, /*#__PURE__*/React__default['default'].createElement(PlaceholderParagraph, {
          length: "large"
        }));

      case 'WITH_META':
        return /*#__PURE__*/React__default['default'].createElement(Placeholder, {
          withImage: false
        }, /*#__PURE__*/React__default['default'].createElement(PlaceholderParagraph, {
          length: "large"
        }), /*#__PURE__*/React__default['default'].createElement(PlaceholderParagraph, {
          length: "medium",
          size: "xxs"
        }));

      case 'WITH_CHECKBOX':
        return /*#__PURE__*/React__default['default'].createElement(Placeholder, {
          withImage: true
        }, /*#__PURE__*/React__default['default'].createElement(PlaceholderParagraph, {
          length: "large"
        }));

      case 'ICON_WITH_META':
        return /*#__PURE__*/React__default['default'].createElement(Placeholder, {
          withImage: true,
          round: true,
          imageSize: 'medium'
        }, /*#__PURE__*/React__default['default'].createElement(PlaceholderParagraph, {
          length: "large"
        }), /*#__PURE__*/React__default['default'].createElement(PlaceholderParagraph, {
          length: "medium",
          size: "xxs"
        }));
    }

    return null;
  };

  var alignmentMapping = {
    right: 'bottom-start',
    left: 'bottom-end'
  };

  var DropdownList = function DropdownList(props) {
    var _classNames4, _classNames5;

    var _props$listOptions = props.listOptions,
        listOptions = _props$listOptions === void 0 ? [] : _props$listOptions,
        inputRef = props.inputRef,
        _props$align = props.align,
        align = _props$align === void 0 ? 'right' : _props$align,
        _props$optionType = props.optionType,
        optionType = _props$optionType === void 0 ? 'DEFAULT' : _props$optionType,
        _props$applyButtonLab = props.applyButtonLabel,
        applyButtonLabel = _props$applyButtonLab === void 0 ? 'Apply' : _props$applyButtonLab,
        _props$cancelButtonLa = props.cancelButtonLabel,
        cancelButtonLabel = _props$cancelButtonLa === void 0 ? 'Cancel' : _props$cancelButtonLa,
        _props$truncateOption = props.truncateOption,
        truncateOption = _props$truncateOption === void 0 ? true : _props$truncateOption,
        _props$withSelectAll = props.withSelectAll,
        withSelectAll = _props$withSelectAll === void 0 ? true : _props$withSelectAll,
        _props$maxHeight = props.maxHeight,
        maxHeight = _props$maxHeight === void 0 ? 200 : _props$maxHeight,
        customTrigger = props.customTrigger,
        selected = props.selected,
        tempSelected = props.tempSelected,
        previousSelected = props.previousSelected,
        remainingOptions = props.remainingOptions,
        firstEnabledOption = props.firstEnabledOption,
        dropdownOpen = props.dropdownOpen,
        menu = props.menu,
        searchTerm = props.searchTerm,
        showApplyButton = props.showApplyButton,
        withCheckbox = props.withCheckbox,
        withSearch = props.withSearch,
        popoverOptions = props.popoverOptions,
        onSearchChange = props.onSearchChange,
        optionRenderer = props.optionRenderer,
        applyOptions = props.applyOptions,
        cancelOptions = props.cancelOptions,
        toggleDropdown = props.toggleDropdown,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var dropdownRef = /*#__PURE__*/React.createRef();
    var triggerRef = /*#__PURE__*/React.createRef();
    var dropdownTriggerRef = /*#__PURE__*/React.createRef();
    var dropdownCancelButtonRef = /*#__PURE__*/React.createRef();
    var dropdownApplyButtonRef = /*#__PURE__*/React.createRef();

    var _React$useState = React.useState(),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        popoverStyle = _React$useState2[0],
        setPopoverStyle = _React$useState2[1];

    var _React$useState3 = React.useState(firstEnabledOption),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        cursor = _React$useState4[0],
        setCursor = _React$useState4[1];

    React.useEffect(function () {
      if (dropdownOpen) {
        var _triggerRef$current;

        var width = props.width,
            minWidth = props.minWidth,
            maxWidth = props.maxWidth;
        var popperWidth = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.clientWidth;
        var popperMinWidth = showApplyButton ? 176 : menu ? 128 : popperWidth;
        var popperWrapperStyle = {
          width: width ? width : popperWidth,
          minWidth: minWidth ? minWidth : popperMinWidth,
          maxWidth: maxWidth ? maxWidth : '100%'
        };
        setPopoverStyle(popperWrapperStyle);
      }
    }, [dropdownOpen]);
    React.useEffect(function () {
      if (firstEnabledOption !== cursor) setCursor(firstEnabledOption);
    }, [firstEnabledOption]);
    var _props$triggerSize = props.triggerSize,
        triggerSize = _props$triggerSize === void 0 ? 'regular' : _props$triggerSize,
        _props$placeholder = props.placeholder,
        placeholder = _props$placeholder === void 0 ? 'Select' : _props$placeholder,
        icon = props.icon,
        error = props.error,
        disabled = props.disabled,
        inlineLabel = props.inlineLabel,
        triggerLabel = props.triggerLabel;
    var CustomTrigger = customTrigger ? customTrigger(triggerLabel ? triggerLabel : placeholder) : /*#__PURE__*/React.createElement(React.Fragment, null);
    var NewCustomTrigger = /*#__PURE__*/React.cloneElement(CustomTrigger, {
      tabindex: 0,
      ref: dropdownTriggerRef
    });
    var trigger = customTrigger ? NewCustomTrigger : /*#__PURE__*/React.createElement(DropdownButton, {
      placeholder: placeholder,
      triggerSize: triggerSize,
      open: dropdownOpen,
      icon: icon,
      disabled: disabled,
      inlineLabel: inlineLabel,
      menu: menu,
      error: error,
      ref: dropdownTriggerRef
    }, triggerLabel);
    var dropdownStyle = {
      maxHeight: maxHeight,
      overflowY: 'auto',
      overflowX: 'hidden'
    };

    var getDropdownClass = function getDropdownClass(index, isGroup) {
      var Dropdown = classnames(_defineProperty$w({}, 'Dropdown--border', isGroup && index !== 0));
      return Dropdown;
    };

    var getDropdownSectionClass = function getDropdownSectionClass(showClearButton) {
      var _classNames2;

      return classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Dropdown-section', true), _defineProperty$w(_classNames2, 'Dropdown-section--withClear', showClearButton), _classNames2));
    };

    var dropdownClass = classnames(_defineProperty$w({}, 'Dropdown', true), className);
    var dropdownWrapperClass = classnames((_classNames4 = {}, _defineProperty$w(_classNames4, 'Dropdown-wrapper', true), _defineProperty$w(_classNames4, 'Dropdown-wrapper--wrap', !truncateOption), _classNames4));
    var SelectAllClass = classnames((_classNames5 = {}, _defineProperty$w(_classNames5, 'Option-checkbox', true), _defineProperty$w(_classNames5, 'Option-checkbox--active', cursor === 0), _defineProperty$w(_classNames5, 'OptionWrapper', true), _classNames5));

    var onToggleDropdown = function onToggleDropdown(open, type) {
      var _dropdownTriggerRef$c;

      toggleDropdown(open, type);
      if (!disabled) (_dropdownTriggerRef$c = dropdownTriggerRef.current) === null || _dropdownTriggerRef$c === void 0 ? void 0 : _dropdownTriggerRef$c.focus();
      setCursor(firstEnabledOption);
    };

    var onCancelOptions = function onCancelOptions() {
      var _dropdownTriggerRef$c2;

      cancelOptions();
      (_dropdownTriggerRef$c2 = dropdownTriggerRef.current) === null || _dropdownTriggerRef$c2 === void 0 ? void 0 : _dropdownTriggerRef$c2.focus();
    };

    var onApplyOptions = function onApplyOptions() {
      var _dropdownTriggerRef$c3;

      applyOptions();
      (_dropdownTriggerRef$c3 = dropdownTriggerRef.current) === null || _dropdownTriggerRef$c3 === void 0 ? void 0 : _dropdownTriggerRef$c3.focus();
    };

    var optionClickHandler = function optionClickHandler(item) {
      var _dropdownTriggerRef$c4;

      props.onOptionSelect(item);
      (_dropdownTriggerRef$c4 = dropdownTriggerRef.current) === null || _dropdownTriggerRef$c4 === void 0 ? void 0 : _dropdownTriggerRef$c4.focus();
    };

    var searchClearHandler = function searchClearHandler() {
      setCursor(firstEnabledOption);
      if (onSearchChange && searchTerm) onSearchChange('');
    };

    var searchHandler = function searchHandler(event) {
      setCursor(firstEnabledOption);
      if (onSearchChange) onSearchChange(event.target.value);
    };

    var updateActiveOption = function updateActiveOption(index, parentCheckbox) {
      var updatedIndex = withCheckbox && withSelectAll && !props.async && !parentCheckbox ? index + 1 : index;
      setCursor(updatedIndex);
    };

    var renderFooter = function renderFooter() {
      var _props$footerLabel = props.footerLabel,
          footerLabel = _props$footerLabel === void 0 ? 'Search for more options' : _props$footerLabel;
      return /*#__PURE__*/React.createElement("div", {
        className: 'Dropdown-footer'
      }, /*#__PURE__*/React.createElement(Text$1, {
        size: "small",
        appearance: 'subtle'
      }, footerLabel));
    };

    var renderGroups = function renderGroups(group, selectedGroup) {
      var onClearOptions = props.onClearOptions;
      var isClearDisabled = selected.every(function (option) {
        return option.disabled;
      });
      return /*#__PURE__*/React.createElement("div", {
        className: getDropdownSectionClass(selectedGroup)
      }, /*#__PURE__*/React.createElement(Text$1, {
        size: "small",
        appearance: 'subtle'
      }, group), selectedGroup && /*#__PURE__*/React.createElement(Button, {
        onClick: onClearOptions,
        disabled: isClearDisabled,
        appearance: "transparent",
        size: "tiny"
      }, "Clear"));
    };

    var renderApplyButton = function renderApplyButton() {
      var disable = _isEqual(previousSelected, tempSelected);

      return /*#__PURE__*/React.createElement("div", {
        className: 'Dropdown-buttonWrapper'
      }, /*#__PURE__*/React.createElement(Button, {
        ref: dropdownCancelButtonRef,
        className: "mr-4",
        appearance: 'basic',
        onClick: onCancelOptions,
        size: 'tiny',
        tabIndex: -1
      }, cancelButtonLabel), /*#__PURE__*/React.createElement(Button, {
        ref: dropdownApplyButtonRef,
        appearance: 'primary',
        disabled: disable,
        size: 'tiny',
        onClick: onApplyOptions
      }, applyButtonLabel));
    };

    var renderSearch = function renderSearch() {
      var loadingOptions = props.loadingOptions,
          searchInit = props.searchInit;
      var disable = loadingOptions && !searchInit;
      return /*#__PURE__*/React.createElement("div", {
        className: 'Dropdown-inputWrapper'
      }, /*#__PURE__*/React.createElement(Input, {
        name: "Dropdown-search",
        icon: 'search',
        value: searchTerm,
        placeholder: 'Search..',
        disabled: disable,
        autoFocus: true,
        onChange: searchHandler,
        onClear: searchClearHandler,
        ref: inputRef,
        autoComplete: 'off',
        className: "Dropdown-input"
      }));
    };

    var renderLoading = function renderLoading(loadersLength) {
      var arr = Array(loadersLength).fill('Loading');
      var type = withCheckbox ? 'WITH_CHECKBOX' : optionType;
      return arr.map(function (option, ind) {
        return /*#__PURE__*/React.createElement("div", {
          className: "Option-loading",
          key: "".concat(option, "-").concat(ind)
        }, /*#__PURE__*/React.createElement(Loading, {
          loadingType: type
        }));
      });
    };

    var renderSelectAll = function renderSelectAll() {
      var _props$selectAllLabel = props.selectAllLabel,
          selectAllLabel = _props$selectAllLabel === void 0 ? 'Select All' : _props$selectAllLabel,
          selectAll = props.selectAll,
          onSelectAll = props.onSelectAll;
      var label = selectAllLabel.trim() ? selectAllLabel.trim() : 'Select All';
      return /*#__PURE__*/React.createElement("div", {
        className: SelectAllClass,
        onMouseEnter: function onMouseEnter(_e) {
          return updateActiveOption(0, true);
        }
      }, /*#__PURE__*/React.createElement(Checkbox, {
        label: label,
        onChange: onSelectAll,
        checked: selectAll.checked,
        indeterminate: selectAll.indeterminate,
        tabIndex: -1,
        className: "OptionCheckbox"
      }));
    };

    var renderOptions = function renderOptions(item, index) {
      // const selectAllPresent = withCheckbox
      //   && remainingOptions === 0
      //   && searchTerm === ''
      //   && withSelectAll;
      var selectAllPresent = _isSelectAllPresent(searchTerm, remainingOptions, withSelectAll, withCheckbox);

      var active = selectAllPresent ? index + 1 === cursor : index === cursor;
      var optionIsSelected = tempSelected.findIndex(function (option) {
        return option.value === item.value;
      }) !== -1;
      return /*#__PURE__*/React.createElement(Option, {
        optionData: item,
        truncateOption: truncateOption,
        selected: optionIsSelected,
        index: index,
        updateActiveOption: updateActiveOption,
        optionRenderer: optionRenderer,
        active: active,
        checkboxes: withCheckbox,
        menu: menu,
        onClick: function onClick() {
          return optionClickHandler(item);
        },
        onChange: function onChange(e) {
          return props.onSelect(item, e.target.checked);
        },
        optionType: props.optionType
      });
    };

    var renderDropdownSection = function renderDropdownSection() {
      var _props$selectedSectio = props.selectedSectionLabel,
          selectedSectionLabel = _props$selectedSectio === void 0 ? 'Selected Items' : _props$selectedSectio,
          _props$loadersCount = props.loadersCount,
          loadersCount = _props$loadersCount === void 0 ? 10 : _props$loadersCount,
          loadingOptions = props.loadingOptions;

      var selectAllPresent = _isSelectAllPresent(searchTerm, remainingOptions, withSelectAll, withCheckbox);

      if (loadersCount && loadingOptions) {
        return /*#__PURE__*/React.createElement("div", {
          className: 'Dropdown-loading'
        }, /*#__PURE__*/React.createElement("div", {
          className: "Dropdown-wrapper",
          style: dropdownStyle
        }, renderLoading(loadersCount)));
      }

      if (listOptions.length === 0 && !loadingOptions) {
        var _props$noResultMessag = props.noResultMessage,
            noResultMessage = _props$noResultMessag === void 0 ? 'No result found' : _props$noResultMessag;
        return /*#__PURE__*/React.createElement("div", {
          className: 'Dropdown-errorWrapper'
        }, /*#__PURE__*/React.createElement("div", {
          className: 'Option'
        }, /*#__PURE__*/React.createElement("div", {
          className: 'Option-subinfo'
        }, noResultMessage)));
      }

      return /*#__PURE__*/React.createElement("div", {
        className: dropdownWrapperClass,
        style: dropdownStyle,
        ref: dropdownRef
      }, selectAllPresent && renderSelectAll(), selected.length > 0 && renderGroups(selectedSectionLabel, true), selected.map(function (option, index) {
        return renderOptions(option, index);
      }), listOptions.map(function (option, index) {
        var prevGroup = index > 0 ? listOptions[index - 1].group : selected.length ? selectedSectionLabel : undefined;
        var currentGroup = option.group;
        var isGroup = prevGroup !== currentGroup;
        var updatedIndex = index + selected.length;
        return /*#__PURE__*/React.createElement("div", {
          className: getDropdownClass(updatedIndex, isGroup),
          key: index
        }, isGroup && currentGroup && renderGroups(currentGroup), renderOptions(option, updatedIndex));
      }), props.async && remainingOptions > 0 && renderFooter());
    };

    var focusOption = function focusOption(direction, classes) {
      var elements = document.querySelectorAll(classes);
      var updatedCursor = direction === 'down' ? cursor + 1 : cursor - 1;
      var startIndex = updatedCursor;
      var endIndex = direction === 'down' ? elements.length : -1;

      while (startIndex !== endIndex) {
        var node = elements[startIndex];

        if (node.getAttribute('data-disabled') !== 'true') {
          var element = elements[startIndex];
          if (element) scrollIntoView(dropdownRef.current, element);
          if (element !== undefined) setCursor(startIndex);
          break;
        }

        if (direction === 'down') {
          startIndex++;
        } else {
          startIndex--;
        }
      }
    };

    var onkeydown = function onkeydown(event) {
      var _dropdownApplyButtonR;

      var optionClass = '.OptionWrapper';

      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          dropdownOpen ? focusOption('down', optionClass) : onToggleDropdown(!dropdownOpen);
          break;

        case 'ArrowUp':
          event.preventDefault();
          dropdownOpen ? focusOption('up', optionClass) : onToggleDropdown(!dropdownOpen);
          break;

        case 'Enter':
          var activeElement = document.activeElement;

          if (dropdownOpen && (inputRef.current === activeElement || dropdownTriggerRef.current === activeElement)) {
            event.preventDefault();
            var classes = withCheckbox ? "".concat(optionClass, " .Checkbox-input") : optionClass;
            var elements = document.querySelectorAll(classes);
            var element = elements[cursor];
            if (element) element.click();
          }

          if (!dropdownOpen) onToggleDropdown(!dropdownOpen);
          break;

        case 'Tab':
          if (!showApplyButton && dropdownOpen) {
            event.preventDefault();
            onToggleDropdown(false, 'onClick');
            return;
          }

          var currentElement = document.activeElement;
          var disabledApplyButton = (_dropdownApplyButtonR = dropdownApplyButtonRef.current) === null || _dropdownApplyButtonR === void 0 ? void 0 : _dropdownApplyButtonR.disabled;

          if ((currentElement === dropdownCancelButtonRef.current && disabledApplyButton || currentElement === dropdownApplyButtonRef.current) && dropdownOpen) {
            event.preventDefault();
            onToggleDropdown(false, 'onClick');
            return;
          }

          if (showApplyButton && dropdownOpen) {
            event.preventDefault();

            if (currentElement === dropdownCancelButtonRef.current) {
              var _dropdownApplyButtonR2;

              (_dropdownApplyButtonR2 = dropdownApplyButtonRef.current) === null || _dropdownApplyButtonR2 === void 0 ? void 0 : _dropdownApplyButtonR2.focus();
            } else {
              var _dropdownCancelButton;

              (_dropdownCancelButton = dropdownCancelButtonRef.current) === null || _dropdownCancelButton === void 0 ? void 0 : _dropdownCancelButton.focus();
            }
          }

          break;
      }
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: dropdownClass,
      ref: triggerRef,
      onKeyDown: onkeydown
    }), /*#__PURE__*/React.createElement(Popover, _extends$p({
      onToggle: onToggleDropdown,
      trigger: trigger,
      triggerClass: !menu ? 'w-100' : '',
      open: dropdownOpen,
      customStyle: popoverStyle,
      position: alignmentMapping[align]
    }, popoverOptions), (withSearch || props.async) && renderSearch(), renderDropdownSection(), showApplyButton && withCheckbox && renderApplyButton()));
  };

  DropdownList.displayName = 'DropdownList';

  var inputRef = /*#__PURE__*/React.createRef();

  /**
   * ###Note:
   * 1. Dropdown props types:
   *  - async: fetchOptions
   *  - sync: options, loading
   * 2. Sync Dropdown:
   *  - Manually toggle loading state to update options (Options <= staticLimit).
   * 3. Callback Functions
   *  - Controlled Dropdown:
   *    * onUpdate: Called when user `clicks on option` / `clicks on Clear, Cancel or Apply button`.
   *    * onChange: Called when selected options are updated.
   *  - Uncontrolled Dropdown:
   *    * onChange: Called when user `clicks on option` / `clicks on Clear, or Apply button`.
   */
  var Dropdown = /*#__PURE__*/function (_React$Component) {
    _inherits$o(Dropdown, _React$Component);

    var _super = _createSuper(Dropdown);

    function Dropdown(props) {
      var _this;

      _classCallCheck$p(this, Dropdown);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "staticLimit", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "getDisabledOptions", function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return options.filter(function (option) {
          return option.disabled;
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "fetchOptionsFunction", function (searchTerm) {
        var options = _this.props.options;
        var filteredOptions = searchTerm ? getSearchedOptions(options, searchTerm) : options;
        return new Promise(function (resolve) {
          resolve({
            options: filteredOptions,
            count: filteredOptions.length
          });
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getUnSelectedOptions", function (options, init) {
        if (options.length) {
          if (!init) {
            return options.filter(function (option) {
              return _this.state.tempSelected.findIndex(function (item) {
                return item.value === option.value;
              }) === -1;
            });
          }

          var _this$props$selected = _this.props.selected,
              _selected2 = _this$props$selected === void 0 ? [] : _this$props$selected;

          var unSelectedGroup = options.filter(function (option) {
            return _isControlled(_this.props.selected) ? _selected2.findIndex(function (item) {
              return item.value === option.value;
            }) === -1 : !option.selected;
          });
          return unSelectedGroup;
        }

        return options;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getSelectedOptions", function (options, init) {
        var _this$props$selected2 = _this.props.selected,
            selected = _this$props$selected2 === void 0 ? [] : _this$props$selected2;

        if (options.length) {
          if (!init) return _this.state.tempSelected;
          var selectedGroup = _isControlled(_this.props.selected) ? selected : options.filter(function (option) {
            return option.selected;
          });
          return selectedGroup;
        }

        return [];
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateOptions", function (init, async) {
        var _this$state = _this.state,
            searchTerm = _this$state.searchTerm,
            selectAll = _this$state.selectAll,
            tempSelected = _this$state.tempSelected,
            previousSelected = _this$state.previousSelected;
        var updatedAsync = async === undefined ? _this.state.async : async;
        var _this$props = _this.props,
            fetchOptions = _this$props.fetchOptions,
            withCheckbox = _this$props.withCheckbox,
            withSearch = _this$props.withSearch;
        var fetchFunction = fetchOptions ? fetchOptions : _this.fetchOptionsFunction;
        fetchFunction(searchTerm).then(function (res) {
          var _inputRef$current;

          var options = res.options,
              count = res.count;
          updatedAsync = searchTerm === '' ? count > _this.staticLimit : updatedAsync;
          var unSelectedGroup = _showSelectedItems(updatedAsync, searchTerm, withCheckbox) ? _this.getUnSelectedOptions(options, init) : options;
          var selectedGroup = searchTerm === '' ? _this.getSelectedOptions(options, init) : [];
          var optionsLength = searchTerm === '' ? count : _this.state.optionsLength;

          var disabledOptions = _this.getDisabledOptions(unSelectedGroup.slice(0, _this.staticLimit));

          _this.setState(_objectSpread2(_objectSpread2({}, _this.state), {}, {
            optionsLength: optionsLength,
            loading: false,
            async: updatedAsync,
            searchedOptionsLength: count,
            options: unSelectedGroup.slice(0, _this.staticLimit),
            tempSelected: init ? selectedGroup : tempSelected,
            previousSelected: init ? selectedGroup : previousSelected,
            selected: _showSelectedItems(updatedAsync, searchTerm, withCheckbox) ? selectedGroup : [],
            triggerLabel: _this.updateTriggerLabel(init ? selectedGroup : tempSelected),
            selectAll: !updatedAsync && init ? getSelectAll$1(selectedGroup, optionsLength, disabledOptions.length) : selectAll
          }));

          if (updatedAsync || withSearch) (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateSearchTerm", function (search) {
        _this.setState(_objectSpread2(_objectSpread2({}, _this.state), {}, {
          loading: true,
          searchInit: true,
          searchTerm: search
        }));
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateOnPopperToggle", function () {
        var _this$props2 = _this.props,
            withCheckbox = _this$props2.withCheckbox,
            showApplyButton = _this$props2.showApplyButton,
            onClose = _this$props2.onClose,
            name = _this$props2.name,
            _this$props2$selected = _this$props2.selected,
            selected = _this$props2$selected === void 0 ? [] : _this$props2$selected;
        var _this$state2 = _this.state,
            previousSelected = _this$state2.previousSelected,
            tempSelected = _this$state2.tempSelected,
            optionsLength = _this$state2.optionsLength,
            async = _this$state2.async,
            loading = _this$state2.loading,
            searchTerm = _this$state2.searchTerm,
            options = _this$state2.options;
        var popperIsOpen = _isOpenControlled(_this.props.open) ? _this.props.open : _this.state.open;

        var disabledOptionsCount = _this.getDisabledOptions(options).length;

        if (withCheckbox && showApplyButton) {
          var temporarySelected = _isControlled(_this.props.selected) ? selected : previousSelected;

          _this.setState({
            tempSelected: temporarySelected,
            selectAll: getSelectAll$1(temporarySelected, optionsLength, disabledOptionsCount),
            triggerLabel: _this.updateTriggerLabel(temporarySelected)
          });
        }

        if (_isOpenControlled(_this.props.open)) {
          _this.setState({
            open: popperIsOpen
          });
        }

        if (popperIsOpen) {
          var moveSelectedGroup = _showSelectedItems(async, searchTerm, withCheckbox) && !_isEqual(_this.state.selected, tempSelected);

          _this.setState({
            loading: moveSelectedGroup || loading || searchTerm !== '',
            searchInit: searchTerm !== '',
            searchTerm: ''
          });

          if (moveSelectedGroup) _this.updateOptions(false);
        }

        if (onClose && !popperIsOpen) {
          var arr = withCheckbox && showApplyButton ? _isControlled(_this.props.selected) ? selected : previousSelected : _this.state.tempSelected;
          var values = arr.map(function (option) {
            return option.value;
          });
          onClose(values, name);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateTriggerLabel", function () {
        var selectedArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var totalOptions = arguments.length > 1 ? arguments[1] : undefined;
        var selectedLength = selectedArray.length;
        if (selectedLength === 0) return '';
        var _this$props3 = _this.props,
            _this$props3$triggerO = _this$props3.triggerOptions,
            triggerOptions = _this$props3$triggerO === void 0 ? {} : _this$props3$triggerO,
            getLabel = _this$props3.getLabel;
        var customLabel = triggerOptions.customLabel,
            _triggerOptions$label = triggerOptions.labelLimit,
            labelLimit = _triggerOptions$label === void 0 ? 2 : _triggerOptions$label;
        var optionsLength = _this.state ? _this.state.optionsLength : totalOptions;
        var label = '';

        if (selectedLength <= labelLimit) {
          label = selectedArray.map(function (option) {
            return option.label;
          }).join(', ');
        } else {
          label = customLabel ? customLabel(selectedLength, optionsLength, selectedArray) : "".concat(selectedLength, " selected");
        }

        if (getLabel) getLabel(label);
        return label;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateSelectedOptions", function (selectedArray, isSingleSelect, isControlled) {
        var _this$state3 = _this.state,
            optionsLength = _this$state3.optionsLength,
            previousSelected = _this$state3.previousSelected,
            selected = _this$state3.selected,
            loading = _this$state3.loading,
            open = _this$state3.open;
        var _this$props4 = _this.props,
            onChange = _this$props4.onChange,
            withCheckbox = _this$props4.withCheckbox,
            showApplyButton = _this$props4.showApplyButton,
            closeOnSelect = _this$props4.closeOnSelect,
            name = _this$props4.name,
            onPopperToggle = _this$props4.onPopperToggle;
        var updatePreviousSelected = withCheckbox && showApplyButton && isControlled;

        var disabledOptions = _this.getDisabledOptions(_this.state.options);

        var isClearClicked = selectedArray.length === 0 && selected.length > 0 || selectedArray.every(function (option) {
          return option.disabled;
        }) && !selected.every(function (option) {
          return option.disabled;
        });

        _this.setState(_objectSpread2(_objectSpread2({}, _this.state), {}, {
          tempSelected: selectedArray,
          triggerLabel: _this.updateTriggerLabel(selectedArray),
          selectAll: getSelectAll$1(selectedArray, optionsLength, disabledOptions.length),
          open: _isOpenControlled(_this.props.open) || withCheckbox ? open : !closeOnSelect,
          previousSelected: updatePreviousSelected ? selectedArray : previousSelected,
          selected: isClearClicked ? selectedArray : selected,
          loading: isClearClicked ? true : loading
        }));

        if (isClearClicked) _this.debounceClear();

        if (onChange && (!showApplyButton || isControlled)) {
          var values = selectedArray.map(function (item) {
            return item.value;
          });
          var selectedValues = isSingleSelect ? values[0] : values;
          onChange(selectedValues, name);
        }

        if (!withCheckbox && closeOnSelect && onPopperToggle && _isOpenControlled(_this.props.open)) {
          onPopperToggle(false, 'optionClick');
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onOptionSelect", function (option) {
        var _this$props5 = _this.props,
            onUpdate = _this$props5.onUpdate,
            selected = _this$props5.selected;

        if (_isControlled(selected)) {
          if (onUpdate) onUpdate('select-option', option);
          return;
        }

        _this.updateSelectedOptions([option], true);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onSelect", function (option, checked) {
        var _this$props6 = _this.props,
            onUpdate = _this$props6.onUpdate,
            selected = _this$props6.selected,
            showApplyButton = _this$props6.showApplyButton;

        if (_isControlled(selected) && !showApplyButton) {
          if (onUpdate) onUpdate(checked ? 'select-option' : 'deselect-option', option);
          return;
        }

        var tempSelected = _this.state.tempSelected;
        var selectedArray = tempSelected.slice();

        if (!checked) {
          var index = selectedArray.findIndex(function (item) {
            return item.value === option.value;
          });
          selectedArray.splice(index, 1);
        }

        selectedArray = checked ? selectedArray.concat(option) : selectedArray;

        _this.updateSelectedOptions(selectedArray, false);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onSelectAll", function (event) {
        var _this$props7 = _this.props,
            onUpdate = _this$props7.onUpdate,
            selected = _this$props7.selected,
            showApplyButton = _this$props7.showApplyButton;
        var _this$state4 = _this.state,
            tempSelected = _this$state4.tempSelected,
            options = _this$state4.options;

        if (_isControlled(selected) && !showApplyButton) {
          if (onUpdate) onUpdate(event.target.checked ? 'select-all' : 'deselect-all');
          return;
        }

        var selectedArr = tempSelected.slice();
        var selectedDisabledArray = selectedArr.filter(function (option) {
          return option.disabled;
        });
        var selectedArray = event.target.checked ? [].concat(_toConsumableArray$9(options.filter(function (option) {
          return !option.disabled;
        })), _toConsumableArray$9(selectedDisabledArray)) : selectedDisabledArray;

        _this.updateSelectedOptions(selectedArray, false);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "debounceSearch", debounce$4(_this.props.searchDebounceDuration, function () {
        _this.setState({
          searchInit: false
        }, function () {
          _this.updateOptions(false);
        });
      }));

      _defineProperty$w(_assertThisInitialized$p(_this), "debounceClear", debounce$4(250, function () {
        return _this.updateOptions(false);
      }));

      _defineProperty$w(_assertThisInitialized$p(_this), "onClearOptions", function () {
        var _this$props8 = _this.props,
            selected = _this$props8.selected,
            name = _this$props8.name,
            onUpdate = _this$props8.onUpdate,
            showApplyButton = _this$props8.showApplyButton,
            onChange = _this$props8.onChange;
        var tempSelected = _this.state.tempSelected;
        var selectedArray = tempSelected.filter(function (option) {
          return option.disabled;
        });

        if (_isControlled(selected) && !showApplyButton) {
          if (onUpdate) onUpdate('clear-all');
          return;
        }

        _this.setState({
          selected: selectedArray,
          tempSelected: selectedArray,
          triggerLabel: '',
          loading: true
        });

        _this.debounceClear();

        if (onChange && !showApplyButton) onChange(selectedArray, name);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onTogglePopper", function (type) {
        var onPopperToggle = _this.props.onPopperToggle;

        if (onPopperToggle && _isOpenControlled(_this.props.open)) {
          onPopperToggle(false, type);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onCancelOptions", function () {
        var _this$state5 = _this.state,
            previousSelected = _this$state5.previousSelected,
            tempSelected = _this$state5.tempSelected,
            optionsLength = _this$state5.optionsLength;
        var _this$props9 = _this.props,
            selected = _this$props9.selected,
            onUpdate = _this$props9.onUpdate,
            onClose = _this$props9.onClose,
            name = _this$props9.name;
        var popperIsOpen = _isOpenControlled(_this.props.open) ? _this.state.open : false;
        var values = previousSelected.map(function (option) {
          return option.value;
        });

        if (_isControlled(selected)) {
          if (onUpdate) onUpdate('cancel-selected', previousSelected, tempSelected);

          _this.onTogglePopper('cancelClick');

          return;
        }

        var label = _this.updateTriggerLabel(previousSelected);

        var disabledOptions = _this.getDisabledOptions(_this.state.options);

        _this.setState(_objectSpread2(_objectSpread2({}, _this.state), {}, {
          tempSelected: previousSelected,
          selectAll: getSelectAll$1(previousSelected, optionsLength, disabledOptions.length),
          triggerLabel: label,
          open: popperIsOpen
        }));

        if (onClose && !popperIsOpen) {
          onClose(values, name);
        }

        _this.onTogglePopper('cancelClick');
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onApplyOptions", function () {
        var _this$state6 = _this.state,
            tempSelected = _this$state6.tempSelected,
            previousSelected = _this$state6.previousSelected;
        var _this$props10 = _this.props,
            onChange = _this$props10.onChange,
            selected = _this$props10.selected,
            onUpdate = _this$props10.onUpdate,
            onClose = _this$props10.onClose,
            name = _this$props10.name;
        var popperIsOpen = _isOpenControlled(_this.props.open) ? _this.state.open : false;
        var values = tempSelected.map(function (option) {
          return option.value;
        });

        if (_isControlled(selected)) {
          if (onUpdate) onUpdate('apply-selected', previousSelected, tempSelected);

          _this.onTogglePopper('applyClick');

          return;
        }

        _this.setState(_objectSpread2(_objectSpread2({}, _this.state), {}, {
          previousSelected: tempSelected,
          optionsApplied: true,
          open: popperIsOpen
        }));

        if (onChange) {
          onChange(values, name);
        }

        if (onClose && !popperIsOpen) {
          onClose(values, name);
        }

        _this.onTogglePopper('applyClick');
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onToggleDropdown", function (updatedOpen, type) {
        if (_this.props.disabled) {
          return;
        }

        var onPopperToggle = _this.props.onPopperToggle;

        if (onPopperToggle && _isOpenControlled(_this.props.open)) {
          onPopperToggle(updatedOpen, type);
          return;
        }

        _this.setState({
          open: updatedOpen
        });
      });

      var _props$selected = props.selected,
          _selected = _props$selected === void 0 ? [] : _props$selected,
          _totalOptions = props.totalOptions,
          _withCheckbox = props.withCheckbox,
          _loading = props.loading,
          _open = props.open,
          _options = props.options;

      _this.staticLimit = Math.min(100, props.staticLimit);

      var _optionsLength = _totalOptions ? _totalOptions : _options.length;

      var _async = 'fetchOptions' in _this.props || _optionsLength > _this.staticLimit;

      var _selectedGroup = !_async ? _this.getSelectedOptions(_options, true) : [];

      var _disabledOptions = _this.getDisabledOptions(_options);

      _this.state = {
        async: _async,
        optionsLength: _optionsLength,
        open: _open,
        searchInit: false,
        searchedOptionsLength: _optionsLength,
        optionsApplied: false,
        options: _options || [],
        loading: _async ? true : _loading,
        searchTerm: '',
        tempSelected: _selectedGroup,
        previousSelected: _selectedGroup,
        selected: _showSelectedItems(_async, '', _withCheckbox) ? _selected : [],
        triggerLabel: _this.updateTriggerLabel(_selectedGroup, _optionsLength),
        selectAll: getSelectAll$1(_selectedGroup, _optionsLength, _disabledOptions.length)
      };
      return _this;
    }

    _createClass$p(Dropdown, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var async = this.state.async;
        if (async) this.updateOptions(true);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (!this.state.async) {
          var _this$props11 = this.props,
              loading = _this$props11.loading,
              fetchOptions = _this$props11.fetchOptions,
              _this$props11$options = _this$props11.options,
              _options2 = _this$props11$options === void 0 ? [] : _this$props11$options,
              withSearch = _this$props11.withSearch;

          var disabledOptionsCount = this.getDisabledOptions(_options2).length;

          if (prevProps.loading !== loading && !fetchOptions) {
            if (_options2.length > this.staticLimit) {
              this.updateOptions(true, true);
            } else {
              var _inputRef$current2;

              var selectedGroup = this.getSelectedOptions(_options2, true);
              this.setState(_objectSpread2(_objectSpread2({}, this.state), {}, {
                options: _options2,
                loading: loading,
                tempSelected: selectedGroup,
                previousSelected: selectedGroup,
                optionsLength: _options2.length,
                searchedOptionsLength: _options2.length,
                triggerLabel: this.updateTriggerLabel(selectedGroup),
                selectAll: getSelectAll$1(selectedGroup, this.state.optionsLength, disabledOptionsCount)
              }));
              if (withSearch) (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.focus();
            }
          }
        }

        if (this.props.selected !== undefined && prevProps.selected !== this.props.selected && prevProps.loading === this.props.loading) {
          var isSingleSelect = !this.props.withCheckbox;
          this.updateSelectedOptions(this.props.selected, isSingleSelect, true);
        }

        if (prevProps.open !== this.props.open || prevState.open !== this.state.open) {
          if (_isOpenControlled(this.props.open) && this.props.open === this.state.open) return;
          this.updateOnPopperToggle();
        }

        if (prevState.searchTerm !== this.state.searchTerm) {
          this.debounceSearch();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state7 = this.state,
            options = _this$state7.options,
            async = _this$state7.async,
            open = _this$state7.open,
            searchTerm = _this$state7.searchTerm,
            searchInit = _this$state7.searchInit,
            loading = _this$state7.loading,
            searchedOptionsLength = _this$state7.searchedOptionsLength,
            tempSelected = _this$state7.tempSelected,
            selectAll = _this$state7.selectAll,
            triggerLabel = _this$state7.triggerLabel,
            previousSelected = _this$state7.previousSelected;
        var _this$props12 = this.props,
            _this$props12$withSel = _this$props12.withSelectAll,
            withSelectAll = _this$props12$withSel === void 0 ? true : _this$props12$withSel,
            withCheckbox = _this$props12.withCheckbox;

        var _this$props13 = this.props,
            _this$props13$trigger = _this$props13.triggerOptions,
            triggerOptions = _this$props13$trigger === void 0 ? {} : _this$props13$trigger;
            _this$props13.selected;
            var rest = _objectWithoutProperties$a(_this$props13, ["triggerOptions", "selected"]);

        var remainingOptionsLen = searchedOptionsLength - options.length;
        var firstEnabledOption = _isSelectAllPresent(searchTerm, remainingOptionsLen, withSelectAll, withCheckbox) ? 0 : options.findIndex(function (option) {
          return !option.disabled;
        });
        return /*#__PURE__*/React.createElement(DropdownList, _extends$p({
          listOptions: options,
          inputRef: inputRef,
          remainingOptions: remainingOptionsLen,
          firstEnabledOption: firstEnabledOption,
          loadingOptions: loading,
          async: async,
          searchInit: searchInit,
          dropdownOpen: open,
          searchTerm: searchTerm,
          triggerLabel: triggerLabel,
          tempSelected: tempSelected,
          previousSelected: previousSelected,
          selected: this.state.selected,
          applyOptions: this.onApplyOptions,
          cancelOptions: this.onCancelOptions,
          toggleDropdown: this.onToggleDropdown,
          onClearOptions: this.onClearOptions,
          onSelect: this.onSelect,
          selectAll: selectAll,
          onSearchChange: this.updateSearchTerm,
          onOptionSelect: this.onOptionSelect,
          onSelectAll: this.onSelectAll,
          customTrigger: triggerOptions.customTrigger
        }, rest));
      }
    }]);

    return Dropdown;
  }(React.Component);

  _defineProperty$w(Dropdown, "defaultProps", {
    triggerOptions: {},
    options: [],
    closeOnSelect: true,
    staticLimit: 50,
    searchDebounceDuration: 300
  });

  var SubtleLink = function SubtleLink(props) {
    var onClick = props.onClick,
        children = props.children,
        href = props.href;

    var onClickHandler = function onClickHandler(e) {
      e.preventDefault();
      onClick();
    };

    return /*#__PURE__*/React.createElement("a", {
      className: "SubtleLink",
      href: href,
      onClick: onClickHandler
    }, children);
  };

  var renderLink = function renderLink(item, _onClick) {
    return /*#__PURE__*/React.createElement(SubtleLink, {
      href: item.link,
      onClick: function onClick() {
        return _onClick(item.link);
      }
    }, item.label);
  };

  var renderDropdown = function renderDropdown(list, onClick) {
    var options = list.map(function (item) {
      return {
        label: item.label,
        value: item.link
      };
    });

    var customTrigger = function customTrigger() {
      return /*#__PURE__*/React.createElement(Button, {
        size: "tiny",
        appearance: "transparent",
        icon: "more_horiz_filled"
      });
    };

    return /*#__PURE__*/React.createElement(Dropdown, {
      triggerSize: 'tiny',
      triggerOptions: {
        customTrigger: customTrigger
      },
      options: options,
      menu: true,
      onChange: function onChange(selected) {
        onClick(selected);
      }
    });
  };

  var Breadcrumbs = function Breadcrumbs(props) {
    var list = props.list,
        onClick = props.onClick,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var BreadcrumbClass = classnames(_defineProperty$w({}, 'Breadcrumbs', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: BreadcrumbClass
    }), list.length <= 4 ? list.map(function (item, index) {
      return /*#__PURE__*/React.createElement("div", {
        key: index,
        className: "Breadcrumbs-item"
      }, /*#__PURE__*/React.createElement("span", {
        className: "Breadcrumbs-link"
      }, renderLink(item, onClick)), /*#__PURE__*/React.createElement("span", {
        className: "Breadcrumbs-itemSeparator"
      }, "/"));
    }) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: "Breadcrumbs-item"
    }, /*#__PURE__*/React.createElement("span", {
      className: "Breadcrumbs-link"
    }, renderLink(list[0], onClick)), /*#__PURE__*/React.createElement("span", {
      className: "Breadcrumbs-itemSeparator"
    }, "/")), /*#__PURE__*/React.createElement("div", {
      className: "Breadcrumbs-dropdown"
    }, renderDropdown(list.slice(1, list.length - 1), onClick), /*#__PURE__*/React.createElement("span", {
      className: "Breadcrumbs-itemSeparator"
    }, "/")), /*#__PURE__*/React.createElement("div", {
      className: "Breadcrumbs-item"
    }, /*#__PURE__*/React.createElement("span", {
      className: "Breadcrumbs-link"
    }, renderLink(list[list.length - 1], onClick)), /*#__PURE__*/React.createElement("span", {
      className: "Breadcrumbs-itemSeparator"
    }, "/"))));
  };

  var Spinner = function Spinner(props) {
    var appearance = props.appearance,
        size = props.size,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var wrapperClasses = classnames(_defineProperty$w({
      Spinner: true
    }, "Spinner--".concat(size), size), className);
    var circleClasses = classnames(_defineProperty$w({
      Circle: true
    }, "Circle--".concat(appearance), appearance));
    var svgProps = {
      viewBox: '0 0 50 50'
    };
    var circleProps = {
      cx: 25,
      cy: 25,
      r: 20,
      fill: 'none',
      strokeMiterlimit: '10',
      strokeWidth: '4'
    };
    return /*#__PURE__*/React.createElement("svg", _extends$p({}, baseProps, {
      className: wrapperClasses
    }, svgProps), /*#__PURE__*/React.createElement("circle", _extends$p({
      className: circleClasses
    }, circleProps)));
  };
  Spinner.displayName = 'Spinner';
  Spinner.defaultProps = {
    appearance: 'primary',
    size: 'medium'
  };

  var sizeMapping$1 = {
    tiny: 12,
    regular: 16,
    large: 20
  };
  var Button = /*#__PURE__*/React.forwardRef(function (props, ref) {
    var _classNames, _classNames2, _classNames3;

    var _props$size = props.size,
        size = _props$size === void 0 ? 'regular' : _props$size,
        _props$appearance = props.appearance,
        appearance = _props$appearance === void 0 ? 'basic' : _props$appearance,
        _props$iconAlign = props.iconAlign,
        iconAlign = _props$iconAlign === void 0 ? 'left' : _props$iconAlign,
        _props$tabIndex = props.tabIndex,
        tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,
        type = props.type,
        children = props.children,
        icon = props.icon,
        expanded = props.expanded,
        selected = props.selected,
        loading = props.loading,
        disabled = props.disabled,
        className = props.className,
        rest = _objectWithoutProperties$a(props, ["size", "appearance", "iconAlign", "tabIndex", "type", "children", "icon", "expanded", "selected", "loading", "disabled", "className"]);

    var buttonClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Button', true), _defineProperty$w(_classNames, 'Button--expanded', expanded), _defineProperty$w(_classNames, "Button--".concat(size), size), _defineProperty$w(_classNames, "Button--".concat(size, "Square"), !children), _defineProperty$w(_classNames, "Button--".concat(appearance), appearance), _defineProperty$w(_classNames, 'Button--selected', selected && (appearance === 'basic' || appearance === 'transparent')), _defineProperty$w(_classNames, "Button--iconAlign-".concat(iconAlign), children && iconAlign), _defineProperty$w(_classNames, "".concat(className), className), _classNames));
    var iconClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Button-icon', true), _defineProperty$w(_classNames2, "Button-icon--".concat(iconAlign), children && iconAlign), _classNames2));
    var spinnerClass = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'Button-spinner', true), _defineProperty$w(_classNames3, "Button-spinner--".concat(iconAlign), children && iconAlign), _classNames3));
    return /*#__PURE__*/React.createElement("button", _extends$p({
      ref: ref,
      type: type,
      className: buttonClass,
      disabled: disabled || loading,
      tabIndex: tabIndex
    }, rest), loading && /*#__PURE__*/React.createElement("span", {
      className: spinnerClass
    }, /*#__PURE__*/React.createElement(Spinner, {
      size: "small",
      appearance: appearance === 'basic' || appearance === 'transparent' ? 'secondary' : 'white'
    })), icon && !loading && /*#__PURE__*/React.createElement("div", {
      className: iconClass
    }, /*#__PURE__*/React.createElement(Icon, {
      name: icon,
      appearance: disabled ? 'disabled' : appearance === 'basic' || appearance === 'transparent' ? selected ? 'info' : 'default' : 'white',
      size: sizeMapping$1[size]
    })), children);
  });
  Button.displayName = 'Button';

  var Card = /*#__PURE__*/React.forwardRef(function (props, ref) {
    var _classNames;

    var _props$shadow = props.shadow,
        shadow = _props$shadow === void 0 ? 'medium' : _props$shadow,
        children = props.children,
        className = props.className,
        rest = _objectWithoutProperties$a(props, ["shadow", "children", "className"]);

    var classes = classnames((_classNames = {
      Card: true
    }, _defineProperty$w(_classNames, "Card--shadow-".concat(shadow), shadow), _defineProperty$w(_classNames, "".concat(className), className), _classNames));
    return /*#__PURE__*/React.createElement("div", _extends$p({
      ref: ref
    }, rest, {
      className: classes
    }), children);
  });
  Card.displayName = 'Card';

  var GenericChip = function GenericChip(props) {
    var label = props.label,
        icon = props.icon,
        clearButton = props.clearButton,
        disabled = props.disabled,
        className = props.className,
        selected = props.selected,
        onClose = props.onClose,
        onClick = props.onClick;
    var baseProps = extractBaseProps(props);

    var iconClass = function iconClass(align) {
      var _classNames;

      return classnames((_classNames = {}, _defineProperty$w(_classNames, 'Chip-icon', true), _defineProperty$w(_classNames, "Chip-icon--".concat(align), align), _defineProperty$w(_classNames, 'cursor-pointer', align === 'right' && !disabled), _classNames));
    };

    var onCloseHandler = function onCloseHandler(e) {
      e.stopPropagation();
      if (onClose) onClose();
    };

    var onClickHandler = function onClickHandler() {
      if (onClick) onClick();
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: "Chip-wrapper ".concat(className),
      onClick: onClickHandler
    }), icon && /*#__PURE__*/React.createElement(Icon, {
      name: icon,
      appearance: disabled ? 'disabled' : selected ? 'info' : 'default',
      className: iconClass('left')
    }), /*#__PURE__*/React.createElement(Text$1, {
      appearance: disabled ? 'disabled' : 'default'
    }, label), clearButton && /*#__PURE__*/React.createElement(Icon, {
      name: "clear",
      appearance: disabled ? 'disabled' : selected ? 'info' : 'subtle',
      className: iconClass('right'),
      onClick: onCloseHandler
    }));
  };
  GenericChip.displayName = 'GenericChip';

  var Chip = function Chip(props) {
    var _classNames;

    var label = props.label,
        icon = props.icon,
        clearButton = props.clearButton,
        type = props.type,
        disabled = props.disabled,
        selected = props.selected,
        onClose = props.onClose,
        onClick = props.onClick,
        name = props.name,
        className = props.className;
    var baseProps = extractBaseProps(props);

    var onCloseHandler = function onCloseHandler() {
      if (!disabled && onClose) onClose(name);
    };

    var onClickHandler = function onClickHandler() {
      if (!disabled && onClick) onClick(name);
    };

    var chipClass = classnames((_classNames = {
      Chip: true
    }, _defineProperty$w(_classNames, "Chip-".concat(type, "--disabled"), disabled), _defineProperty$w(_classNames, "Chip--".concat(type), type && !disabled), _defineProperty$w(_classNames, "Chip-".concat(type, "--selected"), selected && !disabled), _classNames), className);
    var clearbutton = type === 'action' ? false : clearButton;
    var select = type === 'selection' && selected ? true : false;
    return /*#__PURE__*/React.createElement(GenericChip, _extends$p({}, baseProps, {
      label: label,
      selected: select,
      icon: icon,
      clearButton: clearbutton,
      disabled: disabled,
      className: chipClass,
      onClose: onCloseHandler,
      onClick: onClickHandler,
      name: name
    }));
  };
  Chip.displayName = 'Chip';
  Chip.defaultProps = {
    type: 'input'
  };

  var ChipGroup = function ChipGroup(props) {
    var list = props.list,
        onClick = props.onClick,
        onClose = props.onClose,
        className = props.className;
    var baseProps = extractBaseProps(props);

    var onClickHandler = function onClickHandler(item) {
      if (onClick) onClick(item);
    };

    var onCloseHandler = function onCloseHandler(item) {
      if (onClose) onClose(item);
    };

    var ChipGroupClass = classnames(_defineProperty$w({}, 'ChipGroup', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: ChipGroupClass
    }), list.map(function (item, ind) {
      var _item$label = item.label,
          label = _item$label === void 0 ? '' : _item$label,
          icon = item.icon,
          type = item.type,
          disabled = item.disabled,
          selected = item.selected,
          clearButton = item.clearButton,
          name = item.name;
      return /*#__PURE__*/React.createElement("span", {
        key: ind,
        className: "ChipGroup-item"
      }, /*#__PURE__*/React.createElement(Chip, {
        name: name,
        label: label,
        selected: selected,
        icon: icon,
        disabled: disabled,
        clearButton: clearButton,
        type: type,
        onClick: function onClick() {
          return onClickHandler(item);
        },
        onClose: function onClose() {
          return onCloseHandler(item);
        }
      }));
    }));
  };
  ChipGroup.displayName = 'ChipGroup';

  var Column = /*#__PURE__*/React.forwardRef(function (props, ref) {
    var _classNames;

    var size = props.size,
        sizeXS = props.sizeXS,
        sizeS = props.sizeS,
        sizeM = props.sizeM,
        sizeL = props.sizeL,
        sizeXL = props.sizeXL,
        className = props.className,
        children = props.children,
        rest = _objectWithoutProperties$a(props, ["size", "sizeXS", "sizeS", "sizeM", "sizeL", "sizeXL", "className", "children"]);

    var classes = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Col', true), _defineProperty$w(_classNames, "Col--".concat(size), size), _defineProperty$w(_classNames, "Col--xs-".concat(sizeXS), sizeXS), _defineProperty$w(_classNames, "Col--s-".concat(sizeS), sizeS), _defineProperty$w(_classNames, "Col--m-".concat(sizeM), sizeM), _defineProperty$w(_classNames, "Col--l-".concat(sizeL), sizeL), _defineProperty$w(_classNames, "Col--xl-".concat(sizeXL), sizeXL), _defineProperty$w(_classNames, "".concat(className), className), _classNames));
    return /*#__PURE__*/React.createElement("div", _extends$p({
      ref: ref
    }, rest, {
      className: classes
    }), children);
  });
  Column.displayName = 'Column';

  var sizeMap = {
    s: 'h5',
    m: 'h4',
    l: 'h3',
    xl: 'h2',
    xxl: 'h1'
  };
  var Heading = function Heading(props) {
    var _classNames;

    var appearance = props.appearance,
        size = props.size,
        children = props.children,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {
      Heading: true
    }, _defineProperty$w(_classNames, "Heading--".concat(size), size), _defineProperty$w(_classNames, "Heading--".concat(appearance), appearance), _classNames), className);
    return /*#__PURE__*/React.createElement(GenericText, _extends$p({
      "data-test": "DesignSystem-Heading"
    }, baseProps, {
      className: classes,
      componentType: sizeMap[size]
    }), children);
  };
  Heading.displayName = 'Heading';
  Heading.defaultProps = {
    appearance: 'default',
    size: 'm'
  };

  var Subheading = function Subheading(props) {
    var appearance = props.appearance,
        children = props.children,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames(_defineProperty$w({
      Subheading: true
    }, "Subheading--".concat(appearance), appearance), className);
    return /*#__PURE__*/React.createElement(GenericText, _extends$p({
      "data-test": "DesignSystem-Subheading"
    }, baseProps, {
      className: classes,
      componentType: 'h4'
    }), children);
  };
  Subheading.displayName = 'Subheading';
  Subheading.defaultProps = {
    appearance: 'default'
  };

  var config$1 = {
    yearBlockRange: 12,
    yearsInRow: 3,
    monthBlock: 12,
    monthsInRow: 3,
    daysInRow: 7,
    months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    days: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
  };

  var yearBlockRange = config$1.yearBlockRange;
  var getIndexOfDay = function getIndexOfDay(day) {
    return ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'].indexOf(day);
  };
  var getYearBlock = function getYearBlock(year) {
    return year - year % yearBlockRange;
  };
  var getDaysInMonth = function getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  };
  var getFirstDayOfMonth = function getFirstDayOfMonth(year, month) {
    return new Date(year, month).getDay();
  };
  var getDateInfo = function getDateInfo(d) {
    if (d) {
      var dateVal = convertToDate(d);

      if (dateVal) {
        var year = dateVal.getFullYear();
        var month = dateVal.getMonth();
        var day = dateVal.getDay();
        var date = dateVal.getDate();
        var decadeYear = getYearBlock(year);
        return {
          decadeYear: decadeYear,
          year: year,
          month: month,
          day: day,
          date: date
        };
      } else {
        return {};
      }
    }

    return {};
  };
  var convertToDate = function convertToDate(d, format, validators) {
    var dateVal;

    if (d) {
      if (typeof d === 'number') {
        dateVal = new Date(d);
      } else if (typeof d === 'string') {
        return format ? translateToDate(format, d, validators) : undefined;
      } else if (!(d instanceof Date)) {
        var _ref = d,
            year = _ref.year,
            month = _ref.month,
            date = _ref.date;
        dateVal = new Date(year, month, date, 0, 0, 0);
      } else {
        dateVal = d;
      }
    }

    return dateVal;
  };
  var compareDecade = function compareDecade(d, operator, currDecade) {
    if (d) {
      var _getDateInfo = getDateInfo(d),
          limitDecade = _getDateInfo.decadeYear;

      switch (operator) {
        case 'less':
          if (limitDecade < currDecade) return true;
          break;

        case 'more':
          if (limitDecade > currDecade) return true;
          break;

        case 'equal':
          if (limitDecade === currDecade) return true;
          break;
      }
    }

    return false;
  };
  var compareDate = function compareDate(d, operator, currYear, currMonth, currDate) {
    if (d) {
      var _getDateInfo2 = getDateInfo(d),
          limitYear = _getDateInfo2.year,
          limitMonth = _getDateInfo2.month,
          limitDate = _getDateInfo2.date;

      switch (operator) {
        case 'less':
          if (limitYear < currYear) return true;
          if (limitYear > currYear) return false;

          if (currMonth !== undefined) {
            if (limitMonth < currMonth) return true;
            if (limitMonth > currMonth) return false;
          }

          if (currDate !== undefined && limitDate < currDate) return true;
          break;

        case 'more':
          if (limitYear > currYear) return true;
          if (limitYear < currYear) return false;

          if (currMonth !== undefined) {
            if (limitMonth > currMonth) return true;
            if (limitMonth < currMonth) return false;
          }

          if (currDate !== undefined && limitDate > currDate) return true;
          break;

        case 'equal':
          if (currDate !== undefined) {
            if (limitYear === currYear && limitMonth === currMonth && limitDate === currDate) return true;
          } else if (currMonth !== undefined) {
            if (limitYear === currYear && limitMonth === currMonth) return true;
          } else if (limitYear === currYear) return true;

      }
    }

    return false;
  };
  var translateToString = function translateToString(format, d) {
    if (format && d) {
      var _getDateInfo3 = getDateInfo(d),
          year = _getDateInfo3.year,
          month = _getDateInfo3.month,
          date = _getDateInfo3.date;

      var separator = format.includes('/') ? '/' : '-';
      var f = format.split(separator);
      var val = f.reduce(function (out, curr, i) {
        switch (curr) {
          case 'mm':
            out += (month < 9 && '0') + (month + 1);
            break;

          case 'yyyy':
            out += year;
            break;

          case 'dd':
            out += (date < 10 && '0') + date;
            break;
        }

        if (i !== f.length - 1) out += separator;
        return out;
      }, '');
      return val;
    }

    return '';
  };
  var translateToDate = function translateToDate(format, val) {
    var validators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    if (isValid(validators, val, format)) {
      var separator = format.includes('/') ? '/' : '-';
      var year = -1,
          month = -1,
          date = -1;
      var v = val.split(separator);
      format.split(separator).forEach(function (f, i) {
        switch (f) {
          case 'mm':
            month = +v[i] - 1;
            break;

          case 'yyyy':
            year = +v[i];
            break;

          case 'dd':
            date = +v[i];
            break;
        }
      });
      var d = convertToDate({
        year: year,
        month: month,
        date: date
      });
      return d;
    } else {
      return undefined;
    }
  };

  var Calendar = /*#__PURE__*/function (_React$Component) {
    _inherits$o(Calendar, _React$Component);

    var _super = _createSuper(Calendar);

    function Calendar(props) {
      var _this;

      _classCallCheck$p(this, Calendar);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "updateState", function (year, month, date) {
        _this.setState({
          year: year,
          month: month,
          date: date
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getDateValue", function (year, month, date) {
        var _this$props = _this.props,
            disabledBefore = _this$props.disabledBefore,
            disabledAfter = _this$props.disabledAfter;
        var d = new Date(year, month, date);

        if (compareDate(disabledBefore, 'more', year, month, date) || compareDate(disabledAfter, 'less', year, month, date)) {
          return undefined;
        }

        return d;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getNavDateInfo", function (index) {
        var _this$state = _this.state,
            yearBlockNav = _this$state.yearBlockNav,
            yearNav = _this$state.yearNav,
            monthNav = _this$state.monthNav;
        var monthBlock = config$1.monthBlock;
        var yearBlock = yearBlockNav;
        var month = (monthNav + index) % monthBlock;
        var year = yearNav + (index !== 0 && month < monthNav ? 1 : 0);
        return {
          yearBlock: yearBlock,
          year: year,
          month: month
        };
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getInRangeError", function () {
        var _this$props2 = _this.props,
            rangePicker = _this$props2.rangePicker,
            rangeLimit = _this$props2.rangeLimit;
        var _this$state2 = _this.state,
            startDateState = _this$state2.startDate,
            endDateState = _this$state2.endDate,
            hoverDateState = _this$state2.hoverDate;

        if (rangePicker && rangeLimit) {
          var _getDateInfo = getDateInfo(startDateState),
              startYear = _getDateInfo.year,
              startMonth = _getDateInfo.month,
              _startDate2 = _getDateInfo.date;

          var _getDateInfo2 = getDateInfo(endDateState),
              endYear = _getDateInfo2.year,
              endMonth = _getDateInfo2.month,
              _endDate2 = _getDateInfo2.date;

          var _getDateInfo3 = getDateInfo(hoverDateState),
              hoverYear = _getDateInfo3.year,
              hoverMonth = _getDateInfo3.month,
              hoverDate = _getDateInfo3.date;

          var limitDate;

          if (startDateState) {
            limitDate = new Date(startDateState);
            limitDate.setDate(_startDate2 + rangeLimit);
            return compareDate(limitDate, 'less', hoverYear, hoverMonth, hoverDate + 1) || compareDate(limitDate, 'less', endYear, endMonth, _endDate2 + 1);
          }

          if (endDateState) {
            limitDate = new Date(endDateState);
            limitDate.setDate(_endDate2 - rangeLimit);
            return compareDate(limitDate, 'more', hoverYear, hoverMonth, hoverDate - 1) || compareDate(limitDate, 'more', startYear, startMonth, _startDate2 - 1);
          }
        }

        return false;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "selectYear", function (year) {
        _this.updateState(year);

        _this.setState({
          view: 'month'
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "selectMonth", function (month) {
        _this.updateState(_this.state.yearNav, month);

        _this.setState({
          view: 'date'
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "selectDate", function (index, date) {
        var _this$getNavDateInfo = _this.getNavDateInfo(index),
            year = _this$getNavDateInfo.year,
            month = _this$getNavDateInfo.month;

        _this.updateState(year, month, date);

        var d = _this.getDateValue(year, month, date);

        _this.setState({
          currDate: d
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "navClickHandler", function (type) {
        var _this$state3 = _this.state,
            view = _this$state3.view,
            yearBlockNav = _this$state3.yearBlockNav,
            yearNav = _this$state3.yearNav,
            monthNav = _this$state3.monthNav;
        var yearBlockRange = config$1.yearBlockRange,
            monthBlock = config$1.monthBlock;

        switch (view) {
          case 'year':
            if (type === 'prev') _this.setState({
              yearBlockNav: yearBlockNav - yearBlockRange
            });
            if (type === 'next') _this.setState({
              yearBlockNav: yearBlockNav + yearBlockRange
            });
            break;

          case 'month':
            if (type === 'prev') _this.setState({
              yearNav: yearNav - 1
            });
            if (type === 'next') _this.setState({
              yearNav: yearNav + 1
            });
            break;

          case 'date':
            if (type === 'prev') {
              if (monthNav === 0) _this.setState({
                yearNav: yearNav - 1
              });

              _this.setState({
                monthNav: (monthBlock + monthNav - 1) % monthBlock
              });
            }

            if (type === 'next') {
              if (monthNav === monthBlock - 1) _this.setState({
                yearNav: yearNav + 1
              });

              _this.setState({
                monthNav: (monthNav + 1) % monthBlock
              });
            }

            break;
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderJumpButton", function (type) {
        var _this$props3 = _this.props,
            disabledBefore = _this$props3.disabledBefore,
            disabledAfter = _this$props3.disabledAfter;
        var _this$state4 = _this.state,
            view = _this$state4.view,
            yearBlockNav = _this$state4.yearBlockNav,
            yearNav = _this$state4.yearNav,
            monthNav = _this$state4.monthNav;
        var disabled = false;

        switch (view) {
          case 'year':
            if (type === 'prev') {
              disabled = compareDecade(disabledBefore, 'more', yearBlockNav) || compareDecade(disabledBefore, 'equal', yearBlockNav);
            }

            if (type === 'next') {
              disabled = compareDecade(disabledAfter, 'less', yearBlockNav) || compareDecade(disabledAfter, 'equal', yearBlockNav);
            }

            break;

          case 'month':
            if (type === 'prev') {
              disabled = compareDate(disabledBefore, 'more', yearNav - 1);
            }

            if (type === 'next') {
              disabled = compareDate(disabledAfter, 'less', yearNav + 1);
            }

            break;

          case 'date':
            if (type === 'prev') {
              disabled = compareDate(disabledBefore, 'more', yearNav, monthNav - 1);
            }

            if (type === 'next') {
              disabled = compareDate(disabledAfter, 'less', yearNav, monthNav + 1);
            }

            break;
        }

        var headerIconClass = classnames({
          'Calendar-headerIcon': true,
          'Calendar-headerIcon--disabled': disabled
        });
        return /*#__PURE__*/React.createElement(Icon, {
          name: "arrow_".concat(type === 'next' ? 'forward' : 'back'),
          className: headerIconClass,
          onClick: function onClick() {
            return _this.navClickHandler(type);
          }
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderHeaderContent", function (index) {
        var monthsInView = _this.props.monthsInView;
        var _this$state5 = _this.state,
            view = _this$state5.view,
            yearBlockNav = _this$state5.yearBlockNav;
        var yearBlockRange = config$1.yearBlockRange,
            months = config$1.months;
        var _this$props$jumpView = _this.props.jumpView,
            jumpView = _this$props$jumpView === void 0 ? true : _this$props$jumpView;

        if (jumpView) {
          if (monthsInView > 1) jumpView = false;
        }

        var _this$getNavDateInfo2 = _this.getNavDateInfo(index),
            yearNavVal = _this$getNavDateInfo2.year,
            monthNavVal = _this$getNavDateInfo2.month;

        var headerContentClass = classnames({
          'Calendar-headerContent': true,
          'Calendar-headerContent--noIcon-left': index === monthsInView - 1,
          'Calendar-headerContent--noIcon-right': index === 0
        });
        var headerContent = '';

        var onClickHandler = function onClickHandler(currView) {
          if (jumpView) {
            if (currView === 'year') _this.setState({
              view: 'date'
            });
            if (currView === 'month') _this.setState({
              view: 'year'
            });
            if (currView === 'date') _this.setState({
              view: 'month'
            });
          }
        };

        if (view === 'year') headerContent = "".concat(yearBlockNav, " - ").concat(yearBlockNav + (yearBlockRange - 1));
        if (view === 'month') headerContent = "".concat(yearNavVal);
        return /*#__PURE__*/React.createElement("div", {
          className: headerContentClass
        }, view !== 'date' && /*#__PURE__*/React.createElement("span", {
          onClick: function onClick() {
            return onClickHandler(view);
          }
        }, /*#__PURE__*/React.createElement(Heading, {
          size: "s"
        }, headerContent)), view === 'date' && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
          onClick: function onClick() {
            return onClickHandler(view);
          }
        }, /*#__PURE__*/React.createElement(Heading, {
          size: "s"
        }, months[monthNavVal])), "\xA0", /*#__PURE__*/React.createElement("span", {
          onClick: function onClick() {
            return onClickHandler('month');
          }
        }, /*#__PURE__*/React.createElement(Heading, {
          size: "s"
        }, yearNavVal))));
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderBodyYear", function () {
        var yearBlockRange = config$1.yearBlockRange,
            yearsInRow = config$1.yearsInRow;
        var _this$props4 = _this.props,
            rangePicker = _this$props4.rangePicker,
            disabledBefore = _this$props4.disabledBefore,
            disabledAfter = _this$props4.disabledAfter;
        var _this$state6 = _this.state,
            yearBlockNav = _this$state6.yearBlockNav,
            yearNav = _this$state6.yearNav;
        var noOfRows = Math.ceil(yearBlockRange / yearsInRow);
        return Array.from({
          length: noOfRows
        }, function (_y, row) {
          return /*#__PURE__*/React.createElement("div", {
            key: row,
            className: "Calendar-valueRow"
          }, Array.from({
            length: yearsInRow
          }, function (_x, col) {
            var offset = yearsInRow * row + col;
            if (offset === yearBlockNav) return undefined;
            var year = yearBlockNav + offset;
            var disabled = compareDate(disabledBefore, 'more', year) || compareDate(disabledAfter, 'less', year);
            var active = !disabled && !rangePicker && yearNav === year && year === _this.state.year;
            var valueClass = classnames({
              'Calendar-value': true,
              'Calendar-value--active': active,
              'Calendar-value--disabled': disabled
            });
            return /*#__PURE__*/React.createElement("div", {
              key: "".concat(row, "-").concat(col),
              className: valueClass,
              onClick: function onClick() {
                return _this.selectYear(year);
              }
            }, /*#__PURE__*/React.createElement(Text$1, {
              appearance: active ? 'white' : disabled ? 'disabled' : 'default'
            }, "".concat(year)));
          }));
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderBodyMonth", function () {
        var monthBlock = config$1.monthBlock,
            monthsInRow = config$1.monthsInRow,
            months = config$1.months;
        var _this$props5 = _this.props,
            disabledBefore = _this$props5.disabledBefore,
            disabledAfter = _this$props5.disabledAfter;
        var _this$state7 = _this.state,
            yearNav = _this$state7.yearNav,
            monthNav = _this$state7.monthNav,
            year = _this$state7.year;
        var noOfRows = Math.ceil(monthBlock / monthsInRow);
        return Array.from({
          length: noOfRows
        }, function (_y, row) {
          return /*#__PURE__*/React.createElement("div", {
            key: row,
            className: "Calendar-valueRow"
          }, Array.from({
            length: monthsInRow
          }, function (_x, col) {
            var month = monthsInRow * row + col;
            var disabled = compareDate(disabledBefore, 'more', yearNav, month) || compareDate(disabledAfter, 'less', yearNav, month);
            var active = !disabled && year === yearNav && monthNav === month;
            var valueClass = classnames({
              'Calendar-value': true,
              'Calendar-value--active': active,
              'Calendar-value--dummy': disabled
            });
            return /*#__PURE__*/React.createElement("div", {
              key: "".concat(row, "-").concat(col),
              className: valueClass,
              onClick: function onClick() {
                return _this.selectMonth(month);
              }
            }, /*#__PURE__*/React.createElement(Text$1, {
              appearance: active ? 'white' : disabled ? 'disabled' : 'default'
            }, months[month]));
          }));
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderBodyDate", function (index) {
        var daysInRow = config$1.daysInRow,
            days = config$1.days;
        var _this$props6 = _this.props,
            rangePicker = _this$props6.rangePicker,
            firstDayOfWeek = _this$props6.firstDayOfWeek;

        var onMouseLeaveHandler = function onMouseLeaveHandler() {
          if (rangePicker) {
            _this.setState({
              hoverDate: undefined
            });
          }
        };

        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
          className: "Calendar-dayValues"
        }, Array.from({
          length: 7
        }, function (_x, day) {
          var valueClass = classnames({
            'Calendar-value': true,
            'Calendar-value--dummy': true
          });
          var dayValue = (day + daysInRow + getIndexOfDay(firstDayOfWeek)) % daysInRow;
          return /*#__PURE__*/React.createElement(Subheading, {
            key: day,
            className: valueClass,
            appearance: "disabled"
          }, days[dayValue]);
        })), /*#__PURE__*/React.createElement("div", {
          className: "Calendar-dateValues",
          onMouseLeave: onMouseLeaveHandler
        }, _this.renderDateValues(index)));
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderDateValues", function (index) {
        var daysInRow = config$1.daysInRow;
        var _this$props7 = _this.props,
            rangePicker = _this$props7.rangePicker,
            firstDayOfWeek = _this$props7.firstDayOfWeek,
            disabledBefore = _this$props7.disabledBefore,
            disabledAfter = _this$props7.disabledAfter;
        var _this$state8 = _this.state,
            startDate = _this$state8.startDate,
            endDate = _this$state8.endDate,
            hoverDate = _this$state8.hoverDate;
        var _this$state9 = _this.state,
            yearState = _this$state9.year,
            monthState = _this$state9.month,
            dateState = _this$state9.date;

        var _this$getNavDateInfo3 = _this.getNavDateInfo(index),
            yearNavVal = _this$getNavDateInfo3.year,
            monthNavVal = _this$getNavDateInfo3.month;

        var dayRange = getDaysInMonth(yearNavVal, monthNavVal);
        var dayDiff = getFirstDayOfMonth(yearNavVal, monthNavVal) - getIndexOfDay(firstDayOfWeek);
        var dummyDays = (dayDiff + daysInRow) % daysInRow;
        var noOfRows = Math.ceil((dayRange + dummyDays) / daysInRow);

        var inRangeError = _this.getInRangeError();

        var onClickHandler = function onClickHandler(date) {
          if (rangePicker) {
            if (startDate && endDate) {
              _this.selectDate(index, date);
            } else {
              if (!inRangeError) _this.selectDate(index, date);
            }
          } else {
            _this.selectDate(index, date);
          }
        };

        var onMouseOverHandler = function onMouseOverHandler(date) {
          if (rangePicker) {
            var d = _this.getDateValue(yearNavVal, monthNavVal, date);

            if (!(startDate && endDate)) {
              _this.setState({
                hoverDate: d
              });
            }
          }
        };

        return Array.from({
          length: noOfRows
        }, function (_y, row) {
          if (dummyDays < daysInRow) {
            return /*#__PURE__*/React.createElement("div", {
              key: row,
              className: "Calendar-valueRow"
            }, Array.from({
              length: daysInRow
            }, function (_x, col) {
              var date = daysInRow * row + col - dummyDays + 1;
              var dummy = date <= 0 || date > dayRange;
              var disabled = !dummy && (compareDate(disabledBefore, 'more', yearNavVal, monthNavVal, date) || compareDate(disabledAfter, 'less', yearNavVal, monthNavVal, date));
              var active = !disabled && yearState === yearNavVal && monthState === monthNavVal && dateState === date;
              var startActive = false;
              var endActive = false;
              var inRange = false;
              var inRangeLast = false;

              if (rangePicker) {
                startActive = compareDate(startDate, 'equal', yearNavVal, monthNavVal, date);
                endActive = compareDate(endDate, 'equal', yearNavVal, monthNavVal, date);
                inRangeLast = compareDate(hoverDate, 'equal', yearNavVal, monthNavVal, date);
                active = !disabled && (startActive || endActive);

                if (startDate && endDate) {
                  inRange = !disabled && (compareDate(startDate, 'less', yearNavVal, monthNavVal, date) || startActive) && (compareDate(endDate, 'more', yearNavVal, monthNavVal, date) || endActive);
                } else if (startDate) {
                  inRange = !disabled && (compareDate(hoverDate, 'more', yearNavVal, monthNavVal, date) || inRangeLast) && compareDate(startDate, 'less', yearNavVal, monthNavVal, date);
                } else if (endDate) {
                  inRange = !disabled && (compareDate(hoverDate, 'less', yearNavVal, monthNavVal, date) || inRangeLast) && compareDate(endDate, 'more', yearNavVal, monthNavVal, date);
                }
              }

              var wrapperClass = classnames({
                'Calendar-valueWrapper': true,
                'Calendar-valueWrapper--start': startActive || inRangeLast && endDate,
                'Calendar-valueWrapper--end': endActive || inRangeLast && startDate,
                'Calendar-valueWrapper--inRange': inRange || rangePicker && active,
                'Calendar-valueWrapper--inRange-error': inRange && inRangeError
              });
              var valueClass = classnames({
                'Calendar-value': true,
                'Calendar-value--active': active,
                'Calendar-value--dummy': dummy || disabled,
                'Calendar-value--disabled': disabled
              });
              return /*#__PURE__*/React.createElement("div", {
                key: "".concat(row, "-").concat(col),
                className: wrapperClass
              }, /*#__PURE__*/React.createElement("span", {
                className: valueClass,
                onClick: function onClick() {
                  return onClickHandler(date);
                },
                onMouseOver: function onMouseOver() {
                  return onMouseOverHandler(date);
                }
              }, !dummy && /*#__PURE__*/React.createElement(Text$1, {
                appearance: active ? 'white' : disabled ? 'disabled' : 'default'
              }, "".concat(date))));
            }));
          }

          return null;
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderCalendar", function (index) {
        var _classNames;

        var monthsInView = _this.props.monthsInView;
        var view = _this.state.view;
        var wrapperClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Calendar', true), _defineProperty$w(_classNames, "Calendar--".concat(view), view), _classNames));
        var headerClass = classnames({
          'Calendar-header': true
        });
        var bodyClass = classnames({
          'Calendar-body': true
        });
        return /*#__PURE__*/React.createElement("div", {
          key: index,
          className: wrapperClass
        }, /*#__PURE__*/React.createElement("div", {
          className: headerClass
        }, index === 0 && _this.renderJumpButton('prev'), _this.renderHeaderContent(index), index === monthsInView - 1 && _this.renderJumpButton('next')), /*#__PURE__*/React.createElement("div", {
          className: bodyClass
        }, view === 'year' && _this.renderBodyYear(), view === 'month' && _this.renderBodyMonth(), view === 'date' && _this.renderBodyDate(index)));
      });

      var _this$props8 = _this.props,
          _rangePicker = _this$props8.rangePicker,
          _startDate = _this$props8.startDate,
          _endDate = _this$props8.endDate,
          _monthsInView = _this$props8.monthsInView,
          _view = _this$props8.view;
      var currDate = _rangePicker ? _endDate || _startDate : props.date;

      var _yearNav = props.yearNav || getDateInfo(currDate || Date.now()).year;

      var _monthNav = props.monthNav || getDateInfo(currDate || Date.now()).month;

      var _getDateInfo4 = getDateInfo(currDate),
          _year = _getDateInfo4.year,
          _month = _getDateInfo4.month,
          _date = _getDateInfo4.date;

      _this.state = {
        currDate: currDate,
        startDate: _startDate,
        endDate: _endDate,
        yearNav: _yearNav,
        monthNav: _monthNav,
        year: _year,
        month: _month,
        date: _date,
        view: _monthsInView > 1 ? 'date' : _view,
        yearBlockNav: getYearBlock(_yearNav)
      };
      return _this;
    }

    _createClass$p(Calendar, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        var monthsInView = this.props.monthsInView;

        if (prevProps.date !== this.props.date) {
          var _getDateInfo5 = getDateInfo(this.props.date),
              year = _getDateInfo5.year,
              month = _getDateInfo5.month,
              _date2 = _getDateInfo5.date;

          this.updateState(year, month, _date2);
          var d = convertToDate(this.props.date);
          this.setState({
            currDate: d
          });
        }

        if (prevProps.startDate !== this.props.startDate) {
          var _d = convertToDate(this.props.startDate);

          this.setState({
            startDate: _d
          });
        }

        if (prevProps.endDate !== this.props.endDate) {
          var _d2 = convertToDate(this.props.endDate);

          this.setState({
            endDate: _d2
          });
        }

        if (prevProps.view !== this.props.view) {
          if (this.props.monthsInView === 1) {
            this.setState({
              view: this.props.view
            });
          }
        }

        if (prevProps.yearNav !== this.props.yearNav) {
          var yearNav = this.props.yearNav;

          if (yearNav) {
            this.setState({
              yearNav: yearNav,
              yearBlockNav: getYearBlock(yearNav)
            });
          }
        }

        if (prevProps.monthNav !== this.props.monthNav) {
          var monthNav = this.props.monthNav;

          if (monthNav) {
            this.setState({
              monthNav: monthNav
            });
          }
        }

        if (prevState.currDate !== this.state.currDate) {
          var _this$props9 = this.props,
              rangePicker = _this$props9.rangePicker,
              onDateChange = _this$props9.onDateChange;
          var _this$state10 = this.state,
              currDate = _this$state10.currDate,
              _startDate3 = _this$state10.startDate,
              _endDate3 = _this$state10.endDate;

          if (currDate) {
            if (onDateChange) onDateChange(currDate);

            if (rangePicker) {
              this.setState({
                hoverDate: undefined
              });

              if (_startDate3 && _endDate3) {
                this.setState({
                  startDate: currDate,
                  endDate: undefined
                });
              } else {
                var _getDateInfo6 = getDateInfo(currDate),
                    _year2 = _getDateInfo6.year,
                    _month2 = _getDateInfo6.month,
                    _date3 = _getDateInfo6.date;

                if (_startDate3) {
                  if (compareDate(_startDate3, 'more', _year2, _month2, _date3)) {
                    this.setState({
                      startDate: currDate
                    });
                  } else {
                    this.setState({
                      endDate: currDate
                    });
                  }
                } else if (_endDate3) {
                  if (compareDate(_endDate3, 'less', _year2, _month2, _date3)) {
                    this.setState({
                      endDate: currDate
                    });
                  } else {
                    this.setState({
                      startDate: currDate
                    });
                  }
                } else {
                  this.setState({
                    startDate: currDate
                  });
                }
              }
            } else {
              this.setState({
                startDate: currDate
              });
            }
          }
        }

        if (prevState.startDate !== this.state.startDate || prevState.endDate !== this.state.endDate) {
          var onRangeChange = this.props.onRangeChange;
          var _this$state11 = this.state,
              _startDate4 = _this$state11.startDate,
              _endDate4 = _this$state11.endDate;
          if (onRangeChange) onRangeChange(_startDate4, _endDate4);
        }

        if (prevState.year !== this.state.year) {
          var _year3 = this.state.year;

          if (_year3 !== undefined && monthsInView === 1) {
            this.setState({
              year: _year3,
              yearBlockNav: getYearBlock(_year3),
              yearNav: _year3
            });
          }
        }

        if (prevState.month !== this.state.month) {
          var _month3 = this.state.month;

          if (_month3 !== undefined && monthsInView === 1) {
            this.setState({
              monthNav: _month3
            });
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props10 = this.props,
            monthsInView = _this$props10.monthsInView,
            className = _this$props10.className;
        var baseProps = extractBaseProps(this.props);
        return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
          className: "Calendar-wrapper ".concat(className)
        }), Array.from({
          length: monthsInView
        }, function (_x, index) {
          return _this2.renderCalendar(index);
        }));
      }
    }]);

    return Calendar;
  }(React.Component);

  _defineProperty$w(Calendar, "defaultProps", {
    monthsInView: 1,
    view: 'date',
    firstDayOfWeek: 'sunday'
  });

  var Trigger$1 = function Trigger(props) {
    var inputFormat = props.inputFormat,
        inputOptions = props.inputOptions,
        validators = props.validators,
        state = props.state,
        setState = props.setState;
    var init = state.init,
        date = state.date,
        error = state.error;
    var _inputOptions$placeho = inputOptions.placeholderChar,
        placeholderChar = _inputOptions$placeho === void 0 ? '_' : _inputOptions$placeho;

    var onChangeHandler = function onChangeHandler(_e, val) {
      setState({
        open: true
      });

      if (val && !val.includes(placeholderChar)) {
        var d = translateToDate(inputFormat, val, validators);
        setState({
          date: d
        });
      }
    };

    var onBlurHandler = function onBlurHandler(_e, val) {
      setState({
        init: true
      });

      if (!val || val.includes(placeholderChar)) {
        setState({
          date: undefined
        });
      }
    };

    var onClearHandler = function onClearHandler() {
      setState({
        init: true,
        date: undefined
      });
    };

    var showError = inputOptions.error || inputOptions.required && error && init;
    var errorMessage = inputOptions.caption === undefined ? 'Invalid value' : inputOptions.caption;

    var inputValidator = function inputValidator(val) {
      return isValid(validators, val, inputFormat);
    };

    var mask = date$2[inputFormat];
    return /*#__PURE__*/React.createElement(InputMask, _extends$p({
      icon: "events",
      placeholder: inputFormat
    }, inputOptions, {
      error: showError,
      mask: mask,
      value: date ? translateToString(inputFormat, date) // @ts-ignore
      : init ? InputMask.utils.getDefaultValue(mask, placeholderChar) : '',
      onChange: onChangeHandler,
      onBlur: onBlurHandler,
      onClear: onClearHandler,
      caption: showError ? errorMessage : '',
      validators: [inputValidator],
      clearOnEmptyBlur: false
    }));
  };

  var DatePicker = /*#__PURE__*/function (_React$Component) {
    _inherits$o(DatePicker, _React$Component);

    var _super = _createSuper(DatePicker);

    function DatePicker(props) {
      var _this;

      _classCallCheck$p(this, DatePicker);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "getError", function (date) {
        var _this$props = _this.props,
            disabledBefore = _this$props.disabledBefore,
            disabledAfter = _this$props.disabledAfter;

        var _getDateInfo = getDateInfo(disabledBefore),
            dbYear = _getDateInfo.year,
            dbMonth = _getDateInfo.month,
            dbDate = _getDateInfo.date;

        var _getDateInfo2 = getDateInfo(disabledAfter),
            daYear = _getDateInfo2.year,
            daMonth = _getDateInfo2.month,
            daDate = _getDateInfo2.date;

        return !date ? true : compareDate(date, 'less', dbYear, dbMonth, dbDate) || compareDate(date, 'more', daYear, daMonth, daDate);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onDateChangeHandler", function (d) {
        _this.setState({
          init: true,
          date: d
        });

        var closeOnSelect = _this.props.closeOnSelect;
        if (closeOnSelect) _this.setState({
          open: false
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onToggleHandler", function (o, type) {
        switch (type) {
          case 'outsideClick':
            _this.setState({
              open: o
            });

            break;

          case 'onClick':
            _this.setState({
              open: true
            });

            break;
        }
      });

      var inputFormat = props.inputFormat,
          validators = props.validators;

      var _date = convertToDate(props.date, inputFormat, validators);

      var error = _this.getError(_date);

      _this.state = {
        date: _date,
        error: error,
        init: false,
        open: props.open || false
      };
      return _this;
    }

    _createClass$p(DatePicker, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (prevProps.date !== this.props.date) {
          var _this$props2 = this.props,
              inputFormat = _this$props2.inputFormat,
              validators = _this$props2.validators;
          var d = convertToDate(this.props.date, inputFormat, validators);
          this.setState({
            date: d
          });
        }

        if (prevProps.open !== this.props.open) {
          this.setState({
            open: this.props.open || false
          });
        }

        if (prevState.date !== this.state.date) {
          var _this$props3 = this.props,
              onDateChange = _this$props3.onDateChange,
              outputFormat = _this$props3.outputFormat;
          var _date2 = this.state.date;
          var newError = this.getError(_date2);
          this.setState({
            error: newError
          });

          if (onDateChange) {
            if (!newError) {
              var dVal = translateToString(outputFormat, _date2);
              onDateChange(_date2, dVal);
            } else {
              onDateChange(undefined, '');
            }
          }
        }
      }
    }, {
      key: "renderCalendar",
      value: function renderCalendar() {
        var _this$props4 = this.props;
            _this$props4.date;
            _this$props4.open;
            _this$props4.position;
            var inputFormat = _this$props4.inputFormat;
            _this$props4.outputFormat;
            _this$props4.inputOptions;
            var validators = _this$props4.validators;
            _this$props4.withInput;
            var disabledBefore = _this$props4.disabledBefore,
            disabledAfter = _this$props4.disabledAfter;
            _this$props4.onDateChange;
            _this$props4.closeOnSelect;
            var rest = _objectWithoutProperties$a(_this$props4, ["date", "open", "position", "inputFormat", "outputFormat", "inputOptions", "validators", "withInput", "disabledBefore", "disabledAfter", "onDateChange", "closeOnSelect"]);

        var date = this.state.date;
        return /*#__PURE__*/React.createElement(Calendar, _extends$p({}, rest, {
          date: convertToDate(date, inputFormat, validators),
          disabledBefore: convertToDate(disabledBefore, inputFormat, validators),
          disabledAfter: convertToDate(disabledAfter, inputFormat, validators),
          onDateChange: this.onDateChangeHandler
        }));
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props5 = this.props,
            position = _this$props5.position,
            withInput = _this$props5.withInput,
            inputFormat = _this$props5.inputFormat,
            inputOptions = _this$props5.inputOptions,
            validators = _this$props5.validators;
        var open = this.state.open;

        if (withInput) {
          return /*#__PURE__*/React.createElement(Popover, {
            trigger: /*#__PURE__*/React.createElement(Trigger$1, {
              inputFormat: inputFormat,
              inputOptions: inputOptions,
              validators: validators,
              state: this.state,
              setState: this.setState.bind(this)
            }),
            triggerClass: "w-100",
            position: position,
            appendToBody: true,
            open: open,
            onToggle: this.onToggleHandler
          }, this.renderCalendar());
        }

        return this.renderCalendar();
      }
    }]);

    return DatePicker;
  }(React.Component);

  _defineProperty$w(DatePicker, "defaultProps", _objectSpread2(_objectSpread2({}, Calendar.defaultProps), {}, {
    position: 'bottom-start',
    inputFormat: 'mm/dd/yyyy',
    outputFormat: 'mm/dd/yyyy',
    validators: [date$3],
    inputOptions: {},
    closeOnSelect: true
  }));

  var TimePicker = function TimePicker(props) {
    var validators = props.validators,
        inputOptions = props.inputOptions,
        inputFormat = props.inputFormat,
        outputFormat = props.outputFormat,
        onTimeChange = props.onTimeChange,
        timeProp = props.time;

    var _React$useState = React.useState(timeProp),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        time = _React$useState2[0],
        setTime = _React$useState2[1];

    var _React$useState3 = React.useState(false),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        init = _React$useState4[0],
        setInit = _React$useState4[1];

    var _inputOptions$placeho = inputOptions.placeholderChar,
        placeholderChar = _inputOptions$placeho === void 0 ? '_' : _inputOptions$placeho;
    React.useEffect(function () {
      var timeStr = translateToTime(inputFormat, time);
      var updatedTime = timeProp === undefined && timeStr.includes(placeholderChar) ? time : timeProp;
      setTime(updatedTime);
    }, [timeProp]);

    var onChangeHandler = function onChangeHandler(e) {
      var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var updatedTime = val === null || val === void 0 ? void 0 : val.toUpperCase();
      setTime(updatedTime);

      if (inputOptions.onChange) {
        inputOptions.onChange(e, val);
      }
    };

    var onBlurHandler = function onBlurHandler(e) {
      var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var updatedTime = translateToTime(inputFormat, time);
      setInit(true);

      if (onTimeChange) {
        var outputTimeStr = updatedTime && !isPlaceholderPresent(placeholderChar, updatedTime) ? getOutputTimeString(inputFormat, outputFormat, updatedTime) : undefined;
        onTimeChange(outputTimeStr);
      }

      if (inputOptions.onBlur) inputOptions.onBlur(e, val);
    };

    var onClearHandler = function onClearHandler(e) {
      var updatedTime = '';
      setInit(true);
      if (onTimeChange) onTimeChange(updatedTime);
      if (inputOptions.onClear) inputOptions.onClear(e);
    };

    var inputValidator = function inputValidator(val) {
      return isValid(validators, val, inputFormat);
    };

    var mask = time$1[inputFormat];
    return /*#__PURE__*/React.createElement(InputMask, _extends$p({
      placeholder: placeholders[inputFormat],
      placeholderChar: placeholderChar
    }, inputOptions, {
      mask: mask,
      value: time ? translateToTime(inputFormat, time) // @ts-ignore
      : init ? InputMask.utils.getDefaultValue(mask, placeholderChar) : '',
      validators: inputValidator,
      onChange: onChangeHandler,
      onClear: onClearHandler,
      onBlur: onBlurHandler
    }));
  };
  TimePicker.defaultProps = {
    inputFormat: 'hh:mm AM',
    outputFormat: 'hh:mm AM',
    inputOptions: {},
    validators: [time$2]
  };
  TimePicker.displayName = 'TimePicker';

  var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    // eslint-disable-next-line no-new-func
    : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  });

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.6.12' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  });
  _core.version;

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  // Thank's IE8 for his funny defineProperty
  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  var document$2 = _global.document;
  // typeof document.createElement is 'object' in old IE
  var is = _isObject(document$2) && _isObject(document$2.createElement);
  var _domCreate = function (it) {
    return is ? document$2.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  // 7.1.1 ToPrimitive(input [, PreferredType])

  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP$1 = Object.defineProperty;

  var f$4 = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP$1(O, P, Attributes);
    } catch (e) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var _objectDp = {
  	f: f$4
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty$b = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty$b.call(it, key);
  };

  var id$1 = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id$1 + px).toString(36));
  };

  var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});

  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode: 'global',
    copyright: ' 2020 Denis Pushkarev (zloirock.ru)'
  });
  });

  var _functionToString = _shared('native-function-to-string', Function.toString);

  var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src');

  var TO_STRING = 'toString';
  var TPL = ('' + _functionToString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return _functionToString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === _global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];
      _hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      _hide(O, key, val);
    }
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || _functionToString.call(this);
  });
  });

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  // optional / simple context binding

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var PROTOTYPE$1 = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE$1];
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE$1] || (exports[PROTOTYPE$1] = {});
    var key, own, out, exp;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      // export native or passed
      out = (own ? target : source)[key];
      // bind timers to global for call from export context
      exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      // extend global
      if (target) _redefine(target, key, out, type & $export.U);
      // export
      if (exports[key] != out) _hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };
  _global.core = _core;
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  var _export = $export;

  // 20.2.2.20 Math.log1p(x)
  var _mathLog1p = Math.log1p || function log1p(x) {
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
  };

  // 20.2.2.3 Math.acosh(x)


  var sqrt$1 = Math.sqrt;
  var $acosh = Math.acosh;

  _export(_export.S + _export.F * !($acosh
    // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
    && Math.floor($acosh(Number.MAX_VALUE)) == 710
    // Tor Browser bug: Math.acosh(Infinity) -> NaN
    && $acosh(Infinity) == Infinity
  ), 'Math', {
    acosh: function acosh(x) {
      return (x = +x) < 1 ? NaN : x > 94906265.62425156
        ? Math.log(x) + Math.LN2
        : _mathLog1p(x - 1 + sqrt$1(x - 1) * sqrt$1(x + 1));
    }
  });

  // 20.2.2.5 Math.asinh(x)

  var $asinh = Math.asinh;

  function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
  }

  // Tor Browser bug: Math.asinh(0) -> -0
  _export(_export.S + _export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

  // 20.2.2.7 Math.atanh(x)

  var $atanh = Math.atanh;

  // Tor Browser bug: Math.atanh(-0) -> 0
  _export(_export.S + _export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
    atanh: function atanh(x) {
      return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
    }
  });

  // 20.2.2.28 Math.sign(x)
  var _mathSign = Math.sign || function sign(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };

  // 20.2.2.9 Math.cbrt(x)



  _export(_export.S, 'Math', {
    cbrt: function cbrt(x) {
      return _mathSign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
    }
  });

  // 20.2.2.11 Math.clz32(x)


  _export(_export.S, 'Math', {
    clz32: function clz32(x) {
      return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
    }
  });

  // 20.2.2.12 Math.cosh(x)

  var exp$3 = Math.exp;

  _export(_export.S, 'Math', {
    cosh: function cosh(x) {
      return (exp$3(x = +x) + exp$3(-x)) / 2;
    }
  });

  // 20.2.2.14 Math.expm1(x)
  var $expm1 = Math.expm1;
  var _mathExpm1 = (!$expm1
    // Old FF bug
    || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
    // Tor Browser bug
    || $expm1(-2e-17) != -2e-17
  ) ? function expm1(x) {
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
  } : $expm1;

  // 20.2.2.14 Math.expm1(x)



  _export(_export.S + _export.F * (_mathExpm1 != Math.expm1), 'Math', { expm1: _mathExpm1 });

  // 20.2.2.16 Math.fround(x)

  var pow$2 = Math.pow;
  var EPSILON = pow$2(2, -52);
  var EPSILON32 = pow$2(2, -23);
  var MAX32 = pow$2(2, 127) * (2 - EPSILON32);
  var MIN32 = pow$2(2, -126);

  var roundTiesToEven = function (n) {
    return n + 1 / EPSILON - 1 / EPSILON;
  };

  var _mathFround = Math.fround || function fround(x) {
    var $abs = Math.abs(x);
    var $sign = _mathSign(x);
    var a, result;
    if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    // eslint-disable-next-line no-self-compare
    if (result > MAX32 || result != result) return $sign * Infinity;
    return $sign * result;
  };

  // 20.2.2.16 Math.fround(x)


  _export(_export.S, 'Math', { fround: _mathFround });

  // 20.2.2.17 Math.hypot([value1[, value2[,  ]]])

  var abs$1 = Math.abs;

  _export(_export.S, 'Math', {
    hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
      var sum = 0;
      var i = 0;
      var aLen = arguments.length;
      var larg = 0;
      var arg, div;
      while (i < aLen) {
        arg = abs$1(arguments[i++]);
        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else sum += arg;
      }
      return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
    }
  });

  // 20.2.2.18 Math.imul(x, y)

  var $imul = Math.imul;

  // some WebKit versions fails with big numbers, some has wrong arity
  _export(_export.S + _export.F * _fails(function () {
    return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
  }), 'Math', {
    imul: function imul(x, y) {
      var UINT16 = 0xffff;
      var xn = +x;
      var yn = +y;
      var xl = UINT16 & xn;
      var yl = UINT16 & yn;
      return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }
  });

  // 20.2.2.21 Math.log10(x)


  _export(_export.S, 'Math', {
    log10: function log10(x) {
      return Math.log(x) * Math.LOG10E;
    }
  });

  // 20.2.2.20 Math.log1p(x)


  _export(_export.S, 'Math', { log1p: _mathLog1p });

  // 20.2.2.22 Math.log2(x)


  _export(_export.S, 'Math', {
    log2: function log2(x) {
      return Math.log(x) / Math.LN2;
    }
  });

  // 20.2.2.28 Math.sign(x)


  _export(_export.S, 'Math', { sign: _mathSign });

  // 20.2.2.30 Math.sinh(x)


  var exp$2 = Math.exp;

  // V8 near Chromium 38 has a problem with very small numbers
  _export(_export.S + _export.F * _fails(function () {
    return !Math.sinh(-2e-17) != -2e-17;
  }), 'Math', {
    sinh: function sinh(x) {
      return Math.abs(x = +x) < 1
        ? (_mathExpm1(x) - _mathExpm1(-x)) / 2
        : (exp$2(x - 1) - exp$2(-x - 1)) * (Math.E / 2);
    }
  });

  // 20.2.2.33 Math.tanh(x)


  var exp$1 = Math.exp;

  _export(_export.S, 'Math', {
    tanh: function tanh(x) {
      var a = _mathExpm1(x = +x);
      var b = _mathExpm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$1(x) + exp$1(-x));
    }
  });

  // 20.2.2.34 Math.trunc(x)


  _export(_export.S, 'Math', {
    trunc: function trunc(it) {
      return (it > 0 ? Math.floor : Math.ceil)(it);
    }
  });

  _core.Math;

  var toString$2 = {}.toString;

  var _cof = function (it) {
    return toString$2.call(it).slice(8, -1);
  };

  var f$3 = {}.propertyIsEnumerable;

  var _objectPie = {
  	f: f$3
  };

  // fallback for non-array-like ES3 and non-enumerable old V8 strings

  // eslint-disable-next-line no-prototype-builtins
  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  // 7.2.1 RequireObjectCoercible(argument)
  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  // to indexed object, toObject with fallback for non-array-like ES3 strings


  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var gOPD$3 = Object.getOwnPropertyDescriptor;

  var f$2 = _descriptors ? gOPD$3 : function getOwnPropertyDescriptor(O, P) {
    O = _toIobject(O);
    P = _toPrimitive(P, true);
    if (_ie8DomDefine) try {
      return gOPD$3(O, P);
    } catch (e) { /* empty */ }
    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
  };

  var _objectGopd = {
  	f: f$2
  };

  // Works with __proto__ only. Old v8 can't work with null proto objects.
  /* eslint-disable no-proto */


  var check = function (O, proto) {
    _anObject(O);
    if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  var _setProto = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
      function (test, buggy, set) {
        try {
          set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
          set(test, []);
          buggy = !(test instanceof Array);
        } catch (e) { buggy = true; }
        return function setPrototypeOf(O, proto) {
          check(O, proto);
          if (buggy) O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }({}, false) : undefined),
    check: check
  };

  var setPrototypeOf$1 = _setProto.set;
  var _inheritIfRequired = function (that, target, C) {
    var S = target.constructor;
    var P;
    if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf$1) {
      setPrototypeOf$1(that, P);
    } return that;
  };

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor$2 = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor$2 : ceil)(it);
  };

  // 7.1.15 ToLength

  var min$2 = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min$2(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };

  var max$1 = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max$1(index + length, 0) : min$1(index, length);
  };

  // false -> Array#indexOf
  // true  -> Array#includes



  var _arrayIncludes$1 = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var shared = _shared('keys');

  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes$1(false);
  var IE_PROTO$1 = _sharedKey('IE_PROTO');

  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO$1) _has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  // IE 8- don't enum bug keys
  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

  var f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return _objectKeysInternal(O, hiddenKeys);
  };

  var _objectGopn = {
  	f: f$1
  };

  var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var space = '[' + _stringWs + ']';
  var non = '\u200b\u0085';
  var ltrim = RegExp('^' + space + space + '*');
  var rtrim = RegExp(space + space + '*$');

  var exporter = function (KEY, exec, ALIAS) {
    var exp = {};
    var FORCE = _fails(function () {
      return !!_stringWs[KEY]() || non[KEY]() != non;
    });
    var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
    if (ALIAS) exp[ALIAS] = fn;
    _export(_export.P + _export.F * FORCE, 'String', exp);
  };

  // 1 -> String#trimLeft
  // 2 -> String#trimRight
  // 3 -> String#trim
  var trim = exporter.trim = function (string, TYPE) {
    string = String(_defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };

  var _stringTrim = exporter;

  // 19.1.2.14 / 15.2.3.14 Object.keys(O)



  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
    return O;
  };

  var document$1 = _global.document;
  var _html = document$1 && document$1.documentElement;

  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



  var IE_PROTO = _sharedKey('IE_PROTO');
  var Empty = function () { /* empty */ };
  var PROTOTYPE = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE][_enumBugKeys[i]];
    return createDict();
  };

  var _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  var gOPN = _objectGopn.f;
  var gOPD$2 = _objectGopd.f;
  var dP = _objectDp.f;
  var $trim$2 = _stringTrim.trim;
  var NUMBER = 'Number';
  var $Number = _global[NUMBER];
  var Base = $Number;
  var proto$1 = $Number.prototype;
  // Opera ~12 has broken Object#toString
  var BROKEN_COF = _cof(_objectCreate(proto$1)) == NUMBER;
  var TRIM = 'trim' in String.prototype;

  // 7.1.3 ToNumber(argument)
  var toNumber$3 = function (argument) {
    var it = _toPrimitive(argument, false);
    if (typeof it == 'string' && it.length > 2) {
      it = TRIM ? it.trim() : $trim$2(it, 3);
      var first = it.charCodeAt(0);
      var third, radix, maxCode;
      if (first === 43 || first === 45) {
        third = it.charCodeAt(2);
        if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
      } else if (first === 48) {
        switch (it.charCodeAt(1)) {
          case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
          case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
          default: return +it;
        }
        for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
          code = digits.charCodeAt(i);
          // parseInt parses a string to a first unavailable symbol
          // but ToNumber should return NaN if a string contains unavailable symbols
          if (code < 48 || code > maxCode) return NaN;
        } return parseInt(digits, radix);
      }
    } return +it;
  };

  if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
    $Number = function Number(value) {
      var it = arguments.length < 1 ? 0 : value;
      var that = this;
      return that instanceof $Number
        // check on 1..constructor(foo) case
        && (BROKEN_COF ? _fails(function () { proto$1.valueOf.call(that); }) : _cof(that) != NUMBER)
          ? _inheritIfRequired(new Base(toNumber$3(it)), that, $Number) : toNumber$3(it);
    };
    for (var keys$1 = _descriptors ? gOPN(Base) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES6 (in case, if modules with ES6 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
    ).split(','), j = 0, key$1; keys$1.length > j; j++) {
      if (_has(Base, key$1 = keys$1[j]) && !_has($Number, key$1)) {
        dP($Number, key$1, gOPD$2(Base, key$1));
      }
    }
    $Number.prototype = proto$1;
    proto$1.constructor = $Number;
    _redefine(_global, NUMBER, $Number);
  }

  var _aNumberValue = function (it, msg) {
    if (typeof it != 'number' && _cof(it) != 'Number') throw TypeError(msg);
    return +it;
  };

  var _stringRepeat = function repeat(count) {
    var str = String(_defined(this));
    var res = '';
    var n = _toInteger(count);
    if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
    for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
    return res;
  };

  var $toFixed = 1.0.toFixed;
  var floor$1 = Math.floor;
  var data = [0, 0, 0, 0, 0, 0];
  var ERROR = 'Number.toFixed: incorrect invocation!';
  var ZERO = '0';

  var multiply = function (n, c) {
    var i = -1;
    var c2 = c;
    while (++i < 6) {
      c2 += n * data[i];
      data[i] = c2 % 1e7;
      c2 = floor$1(c2 / 1e7);
    }
  };
  var divide$1 = function (n) {
    var i = 6;
    var c = 0;
    while (--i >= 0) {
      c += data[i];
      data[i] = floor$1(c / n);
      c = (c % n) * 1e7;
    }
  };
  var numToString = function () {
    var i = 6;
    var s = '';
    while (--i >= 0) {
      if (s !== '' || i === 0 || data[i] !== 0) {
        var t = String(data[i]);
        s = s === '' ? t : s + _stringRepeat.call(ZERO, 7 - t.length) + t;
      }
    } return s;
  };
  var pow$1 = function (x, n, acc) {
    return n === 0 ? acc : n % 2 === 1 ? pow$1(x, n - 1, acc * x) : pow$1(x * x, n / 2, acc);
  };
  var log$1 = function (x) {
    var n = 0;
    var x2 = x;
    while (x2 >= 4096) {
      n += 12;
      x2 /= 4096;
    }
    while (x2 >= 2) {
      n += 1;
      x2 /= 2;
    } return n;
  };

  _export(_export.P + _export.F * (!!$toFixed && (
    0.00008.toFixed(3) !== '0.000' ||
    0.9.toFixed(0) !== '1' ||
    1.255.toFixed(2) !== '1.25' ||
    1000000000000000128.0.toFixed(0) !== '1000000000000000128'
  ) || !_fails(function () {
    // V8 ~ Android 4.3-
    $toFixed.call({});
  })), 'Number', {
    toFixed: function toFixed(fractionDigits) {
      var x = _aNumberValue(this, ERROR);
      var f = _toInteger(fractionDigits);
      var s = '';
      var m = ZERO;
      var e, z, j, k;
      if (f < 0 || f > 20) throw RangeError(ERROR);
      // eslint-disable-next-line no-self-compare
      if (x != x) return 'NaN';
      if (x <= -1e21 || x >= 1e21) return String(x);
      if (x < 0) {
        s = '-';
        x = -x;
      }
      if (x > 1e-21) {
        e = log$1(x * pow$1(2, 69, 1)) - 69;
        z = e < 0 ? x * pow$1(2, -e, 1) : x / pow$1(2, e, 1);
        z *= 0x10000000000000;
        e = 52 - e;
        if (e > 0) {
          multiply(0, z);
          j = f;
          while (j >= 7) {
            multiply(1e7, 0);
            j -= 7;
          }
          multiply(pow$1(10, j, 1), 0);
          j = e - 1;
          while (j >= 23) {
            divide$1(1 << 23);
            j -= 23;
          }
          divide$1(1 << j);
          multiply(1, 1);
          divide$1(2);
          m = numToString();
        } else {
          multiply(0, z);
          multiply(1 << -e, 0);
          m = numToString() + _stringRepeat.call(ZERO, f);
        }
      }
      if (f > 0) {
        k = m.length;
        m = s + (k <= f ? '0.' + _stringRepeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
      } else {
        m = s + m;
      } return m;
    }
  });

  var $toPrecision = 1.0.toPrecision;

  _export(_export.P + _export.F * (_fails(function () {
    // IE7-
    return $toPrecision.call(1, undefined) !== '1';
  }) || !_fails(function () {
    // V8 ~ Android 4.3-
    $toPrecision.call({});
  })), 'Number', {
    toPrecision: function toPrecision(precision) {
      var that = _aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
      return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
    }
  });

  // 20.1.2.1 Number.EPSILON


  _export(_export.S, 'Number', { EPSILON: Math.pow(2, -52) });

  // 20.1.2.2 Number.isFinite(number)

  var _isFinite = _global.isFinite;

  _export(_export.S, 'Number', {
    isFinite: function isFinite(it) {
      return typeof it == 'number' && _isFinite(it);
    }
  });

  // 20.1.2.3 Number.isInteger(number)

  var floor = Math.floor;
  var _isInteger = function isInteger(it) {
    return !_isObject(it) && isFinite(it) && floor(it) === it;
  };

  // 20.1.2.3 Number.isInteger(number)


  _export(_export.S, 'Number', { isInteger: _isInteger });

  // 20.1.2.4 Number.isNaN(number)


  _export(_export.S, 'Number', {
    isNaN: function isNaN(number) {
      // eslint-disable-next-line no-self-compare
      return number != number;
    }
  });

  // 20.1.2.5 Number.isSafeInteger(number)


  var abs = Math.abs;

  _export(_export.S, 'Number', {
    isSafeInteger: function isSafeInteger(number) {
      return _isInteger(number) && abs(number) <= 0x1fffffffffffff;
    }
  });

  // 20.1.2.6 Number.MAX_SAFE_INTEGER


  _export(_export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

  // 20.1.2.10 Number.MIN_SAFE_INTEGER


  _export(_export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

  var $parseFloat = _global.parseFloat;
  var $trim$1 = _stringTrim.trim;

  var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
    var string = $trim$1(String(str), 3);
    var result = $parseFloat(string);
    return result === 0 && string.charAt(0) == '-' ? -0 : result;
  } : $parseFloat;

  // 20.1.2.12 Number.parseFloat(string)
  _export(_export.S + _export.F * (Number.parseFloat != _parseFloat), 'Number', { parseFloat: _parseFloat });

  var $parseInt = _global.parseInt;
  var $trim = _stringTrim.trim;

  var hex$1 = /^[-+]?0[xX]/;

  var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
    var string = $trim(String(str), 3);
    return $parseInt(string, (radix >>> 0) || (hex$1.test(string) ? 16 : 10));
  } : $parseInt;

  // 20.1.2.13 Number.parseInt(string, radix)
  _export(_export.S + _export.F * (Number.parseInt != _parseInt), 'Number', { parseInt: _parseInt });

  _core.Number;

  /* eslint no-proto: 0 */

  var testObject = {};

  if (!(Object.setPrototypeOf || testObject.__proto__)) {
    var nativeGetPrototypeOf = Object.getPrototypeOf;

    Object.getPrototypeOf = function (object) {
      if (object.__proto__) {
        return object.__proto__;
      }

      return nativeGetPrototypeOf.call(Object, object);
    };
  }

  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b="function"===typeof Symbol&&Symbol.for,c$1=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k$1=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
  Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x$1=b?Symbol.for("react.responder"):60118,y$1=b?Symbol.for("react.scope"):60119;
  function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c$1:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k$1:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k$1;var ContextProvider=h;var Element$1=c$1;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
  var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k$1};var isContextProvider=function(a){return z(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c$1};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
  var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
  var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k$1||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x$1||a.$$typeof===y$1||a.$$typeof===v)};var typeOf=z;

  var reactIs_production_min = {
  	AsyncMode: AsyncMode,
  	ConcurrentMode: ConcurrentMode,
  	ContextConsumer: ContextConsumer,
  	ContextProvider: ContextProvider,
  	Element: Element$1,
  	ForwardRef: ForwardRef,
  	Fragment: Fragment,
  	Lazy: Lazy,
  	Memo: Memo,
  	Portal: Portal,
  	Profiler: Profiler,
  	StrictMode: StrictMode,
  	Suspense: Suspense,
  	isAsyncMode: isAsyncMode,
  	isConcurrentMode: isConcurrentMode,
  	isContextConsumer: isContextConsumer,
  	isContextProvider: isContextProvider,
  	isElement: isElement,
  	isForwardRef: isForwardRef,
  	isFragment: isFragment,
  	isLazy: isLazy,
  	isMemo: isMemo,
  	isPortal: isPortal,
  	isProfiler: isProfiler,
  	isStrictMode: isStrictMode,
  	isSuspense: isSuspense,
  	isValidElementType: isValidElementType,
  	typeOf: typeOf
  };

  var reactIs_development = createCommonjsModule(function (module, exports) {
  });
  reactIs_development.AsyncMode;
  reactIs_development.ConcurrentMode;
  reactIs_development.ContextConsumer;
  reactIs_development.ContextProvider;
  reactIs_development.Element;
  reactIs_development.ForwardRef;
  reactIs_development.Fragment;
  reactIs_development.Lazy;
  reactIs_development.Memo;
  reactIs_development.Portal;
  reactIs_development.Profiler;
  reactIs_development.StrictMode;
  reactIs_development.Suspense;
  reactIs_development.isAsyncMode;
  reactIs_development.isConcurrentMode;
  reactIs_development.isContextConsumer;
  reactIs_development.isContextProvider;
  reactIs_development.isElement;
  reactIs_development.isForwardRef;
  reactIs_development.isFragment;
  reactIs_development.isLazy;
  reactIs_development.isMemo;
  reactIs_development.isPortal;
  reactIs_development.isProfiler;
  reactIs_development.isStrictMode;
  reactIs_development.isSuspense;
  reactIs_development.isValidElementType;
  reactIs_development.typeOf;

  createCommonjsModule(function (module) {

  {
    module.exports = reactIs_production_min;
  }
  });

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty$a = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
  	if (val === null || val === undefined) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}

  	return Object(val);
  }

  function shouldUseNative() {
  	try {
  		if (!Object.assign) {
  			return false;
  		}

  		// Detect buggy property enumeration order in older V8 versions.

  		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
  		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
  		test1[5] = 'de';
  		if (Object.getOwnPropertyNames(test1)[0] === '5') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test2 = {};
  		for (var i = 0; i < 10; i++) {
  			test2['_' + String.fromCharCode(i)] = i;
  		}
  		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
  			return test2[n];
  		});
  		if (order2.join('') !== '0123456789') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test3 = {};
  		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
  			test3[letter] = letter;
  		});
  		if (Object.keys(Object.assign({}, test3)).join('') !==
  				'abcdefghijklmnopqrst') {
  			return false;
  		}

  		return true;
  	} catch (err) {
  		// We don't expect any of the above to throw, but better to be safe.
  		return false;
  	}
  }

  shouldUseNative() ? Object.assign : function (target, source) {
  	var from;
  	var to = toObject(target);
  	var symbols;

  	for (var s = 1; s < arguments.length; s++) {
  		from = Object(arguments[s]);

  		for (var key in from) {
  			if (hasOwnProperty$a.call(from, key)) {
  				to[key] = from[key];
  			}
  		}

  		if (getOwnPropertySymbols) {
  			symbols = getOwnPropertySymbols(from);
  			for (var i = 0; i < symbols.length; i++) {
  				if (propIsEnumerable.call(from, symbols[i])) {
  					to[symbols[i]] = from[symbols[i]];
  				}
  			}
  		}
  	}

  	return to;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  var ReactPropTypesSecret_1 = ReactPropTypesSecret;

  Function.call.bind(Object.prototype.hasOwnProperty);

  function emptyFunction() {}
  function emptyFunctionWithReset() {}
  emptyFunctionWithReset.resetWarningCache = emptyFunction;

  var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret_1) {
        // It is still safe when called from React.
        return;
      }
      var err = new Error(
        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
        'Use PropTypes.checkPropTypes() to call them. ' +
        'Read more at http://fb.me/use-check-prop-types'
      );
      err.name = 'Invariant Violation';
      throw err;
    }  shim.isRequired = shim;
    function getShim() {
      return shim;
    }  // Important!
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,

      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,

      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };

    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  var propTypes$5 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    module.exports = factoryWithThrowingShims();
  }
  });

  /**
   * Checks if `value` is `null` or `undefined`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
   * @example
   *
   * _.isNil(null);
   * // => true
   *
   * _.isNil(void 0);
   * // => true
   *
   * _.isNil(NaN);
   * // => false
   */
  function isNil(value) {
    return value == null;
  }

  var isNil_1 = isNil;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal$2 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal$2;

  /** Detect free variable `self`. */
  var freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$3 = _freeGlobal || freeSelf$2 || Function('return this')();

  var _root = root$3;

  /** Built-in value references. */
  var Symbol$1 = _root.Symbol;

  var _Symbol = Symbol$1;

  /** Used for built-in method references. */
  var objectProto$e = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$e.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$e.toString;

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$d = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$d.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$2(value) {
    return nativeObjectToString.call(value);
  }

  var _objectToString = objectToString$2;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  var isArray_1 = isArray;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike$2(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike$2;

  /** `Object#toString` result references. */
  var stringTag$2 = '[object String]';

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' ||
      (!isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$2);
  }

  var isString_1 = isString;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$2(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject$2;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$2(value) {
    if (!isObject_1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTag(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction$2;

  /** `Object#toString` result references. */
  var symbolTag$3 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$2(value) {
    return typeof value == 'symbol' ||
      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$3);
  }

  var isSymbol_1 = isSymbol$2;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol_1(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  var _isKey = isKey;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = _root['__core-js_shared__'];

  var _coreJsData = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  var _isMasked = isMasked;

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  var _toSource = toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$c = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$c.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$8).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }
    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$b.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }
    return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$a.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
  }

  var _hashHas = hashHas;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;

  var _Hash = Hash;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;

  var _ListCache = ListCache;

  /* Built-in method references that are verified to be native. */
  var Map$2 = _getNative(_root, 'Map');

  var _Map = Map$2;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash,
      'map': new (_Map || _ListCache),
      'string': new _Hash
    };
  }

  var _mapCacheClear = mapCacheClear;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  var _isKeyable = isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  var _getMapData = getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;

  var _MapCache = MapCache;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$4 = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT$4);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || _MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = _MapCache;

  var memoize_1 = memoize;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize_1(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar$1 = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath$1 = _memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName$1, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar$1, '$1') : (number || match));
    });
    return result;
  });

  var _stringToPath = stringToPath$1;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  var _arrayMap = arrayMap;

  /** Used as references for various `Number` constants. */
  var INFINITY$3 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }
    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
  }

  var _baseToString = baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString$1(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString$1;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }
    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  /** Used as references for various `Number` constants. */
  var INFINITY$2 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
  }

  var _toKey = toKey;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = _castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  var _baseGet = baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;

  /** `Object#toString` result references. */
  var numberTag$2 = '[object Number]';

  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */
  function isNumber$1(value) {
    return typeof value == 'number' ||
      (isObjectLike_1(value) && _baseGetTag(value) == numberTag$2);
  }

  var isNumber_1 = isNumber$1;

  /**
   * Checks if `value` is `NaN`.
   *
   * **Note:** This method is based on
   * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
   * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
   * `undefined` and other non-number values.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */
  function isNaN$1(value) {
    // An `NaN` primitive is the only value that is not equal to itself.
    // Perform the `toStringTag` check first to avoid errors with some
    // ActiveX objects in IE.
    return isNumber_1(value) && value != +value;
  }

  var _isNaN = isNaN$1;

  var mathSign = function mathSign(value) {
    if (value === 0) {
      return 0;
    }

    if (value > 0) {
      return 1;
    }

    return -1;
  };
  var isPercent = function isPercent(value) {
    return isString_1(value) && value.indexOf('%') === value.length - 1;
  };
  var isNumber = function isNumber(value) {
    return isNumber_1(value) && !_isNaN(value);
  };
  var isNumOrStr = function isNumOrStr(value) {
    return isNumber(value) || isString_1(value);
  };
  var idCounter = 0;
  var uniqueId = function uniqueId(prefix) {
    var id = ++idCounter;
    return "".concat(prefix || '').concat(id);
  };
  /**
   * Get percent value of a total value
   * @param {Number|String} percent A percent
   * @param {Number} totalValue     Total value
   * @param {NUmber} defaultValue   The value returned when percent is undefined or invalid
   * @param {Boolean} validate      If set to be true, the result will be validated
   * @return {Number} value
   */

  var getPercentValue = function getPercentValue(percent, totalValue) {
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var validate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (!isNumber(percent) && !isString_1(percent)) {
      return defaultValue;
    }

    var value;

    if (isPercent(percent)) {
      var index = percent.indexOf('%');
      value = totalValue * parseFloat(percent.slice(0, index)) / 100;
    } else {
      value = +percent;
    }

    if (_isNaN(value)) {
      value = defaultValue;
    }

    if (validate && value > totalValue) {
      value = totalValue;
    }

    return value;
  };
  var getAnyElementOfObject = function getAnyElementOfObject(obj) {
    if (!obj) {
      return null;
    }

    var keys = Object.keys(obj);

    if (keys && keys.length) {
      return obj[keys[0]];
    }

    return null;
  };
  var hasDuplicate = function hasDuplicate(ary) {
    if (!isArray_1(ary)) {
      return false;
    }

    var len = ary.length;
    var cache = {};

    for (var i = 0; i < len; i++) {
      if (!cache[ary[i]]) {
        cache[ary[i]] = true;
      } else {
        return true;
      }
    }

    return false;
  };
  var interpolateNumber$1 = function interpolateNumber(numberA, numberB) {
    if (isNumber(numberA) && isNumber(numberB)) {
      return function (t) {
        return numberA + t * (numberB - numberA);
      };
    }

    return function () {
      return numberB;
    };
  };
  var findEntryInArray = function findEntryInArray(ary, specifiedKey, specifiedValue) {
    if (!ary || !ary.length) {
      return null;
    }

    return ary.find(function (entry) {
      return entry && (typeof specifiedKey === 'function' ? specifiedKey(entry) : get_1(entry, specifiedKey)) === specifiedValue;
    });
  };

  function shallowEqual(a, b) {
    /* eslint-disable no-restricted-syntax */
    for (var key in a) {
      if ({}.hasOwnProperty.call(a, key) && (!{}.hasOwnProperty.call(b, key) || a[key] !== b[key])) {
        return false;
      }
    }

    for (var _key in b) {
      if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a, _key)) {
        return false;
      }
    }

    return true;
  }

  function _toConsumableArray$8(arr) { return _arrayWithoutHoles$8(arr) || _iterableToArray$9(arr) || _nonIterableSpread$8(); }

  function _nonIterableSpread$8() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray$9(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles$8(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _objectWithoutProperties$9(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$a(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$a(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
  var PRESENTATION_ATTRIBUTES = {
    'aria-current': propTypes$5.string,
    // state
    'aria-details': propTypes$5.any,
    'aria-disabled': propTypes$5.any,
    // state
    'aria-hidden': propTypes$5.any,
    // state
    'aria-invalid': propTypes$5.any,
    // state
    'aria-keyshortcuts': propTypes$5.any,
    'aria-label': propTypes$5.any,
    'aria-roledescription': propTypes$5.any,
    // Widget Attributes
    'aria-autocomplete': propTypes$5.any,
    'aria-checked': propTypes$5.any,
    'aria-expanded': propTypes$5.any,
    'aria-haspopup': propTypes$5.any,
    'aria-level': propTypes$5.any,
    'aria-modal': propTypes$5.any,
    'aria-multiline': propTypes$5.any,
    'aria-multiselectable': propTypes$5.any,
    'aria-orientation': propTypes$5.any,
    'aria-placeholder': propTypes$5.any,
    'aria-pressed': propTypes$5.any,
    'aria-readonly': propTypes$5.any,
    'aria-required': propTypes$5.any,
    'aria-selected': propTypes$5.any,
    'aria-sort': propTypes$5.any,
    'aria-valuemax': propTypes$5.any,
    'aria-valuemin': propTypes$5.any,
    'aria-valuenow': propTypes$5.any,
    'aria-valuetext': propTypes$5.any,
    // Live Region Attributes
    'aria-atomic': propTypes$5.any,
    'aria-busy': propTypes$5.any,
    'aria-live': propTypes$5.any,
    'aria-relevant': propTypes$5.any,
    // Drag-and-Drop Attributes
    'aria-dropeffect': propTypes$5.any,
    'aria-grabbed': propTypes$5.any,
    // Relationship Attributes
    'aria-activedescendant': propTypes$5.any,
    'aria-colcount': propTypes$5.any,
    'aria-colindex': propTypes$5.any,
    'aria-colspan': propTypes$5.any,
    'aria-controls': propTypes$5.any,
    'aria-describedby': propTypes$5.any,
    'aria-errormessage': propTypes$5.any,
    'aria-flowto': propTypes$5.any,
    'aria-labelledby': propTypes$5.any,
    'aria-owns': propTypes$5.any,
    'aria-posinset': propTypes$5.any,
    'aria-rowcount': propTypes$5.any,
    'aria-rowindex': propTypes$5.any,
    'aria-rowspan': propTypes$5.any,
    'aria-setsize': propTypes$5.any,
    alignmentBaseline: propTypes$5.string,
    angle: propTypes$5.number,
    baselineShift: propTypes$5.string,
    clip: propTypes$5.string,
    clipPath: propTypes$5.string,
    clipRule: propTypes$5.string,
    color: propTypes$5.string,
    colorInterpolation: propTypes$5.string,
    colorInterpolationFilters: propTypes$5.string,
    colorProfile: propTypes$5.string,
    colorRendering: propTypes$5.string,
    cursor: propTypes$5.string,
    direction: propTypes$5.oneOf(['ltr', 'rtl', 'inherit']),
    display: propTypes$5.string,
    dominantBaseline: propTypes$5.string,
    enableBackground: propTypes$5.string,
    fill: propTypes$5.string,
    fillOpacity: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    fillRule: propTypes$5.oneOf(['nonzero', 'evenodd', 'inherit']),
    filter: propTypes$5.string,
    floodColor: propTypes$5.string,
    floodOpacity: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    font: propTypes$5.string,
    fontFamily: propTypes$5.string,
    fontSize: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    fontSizeAdjust: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    fontStretch: propTypes$5.oneOf(['normal', 'wider', 'narrower', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded', 'inherit']),
    fontStyle: propTypes$5.oneOf(['normal', 'italic', 'oblique', 'inherit']),
    fontVariant: propTypes$5.oneOf(['normal', 'small-caps', 'inherit']),
    fontWeight: propTypes$5.oneOf(['normal', 'bold', 'bolder', 'lighter', 100, 200, 300, 400, 500, 600, 700, 800, 900, 'inherit']),
    glyphOrientationHorizontal: propTypes$5.string,
    glyphOrientationVertical: propTypes$5.string,
    imageRendering: propTypes$5.oneOf(['auto', 'optimizeSpeed', 'optimizeQuality', 'inherit']),
    kerning: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    letterSpacing: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    lightingColor: propTypes$5.string,
    lineHeight: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    markerEnd: propTypes$5.string,
    markerMid: propTypes$5.string,
    markerStart: propTypes$5.string,
    mask: propTypes$5.string,
    opacity: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    overflow: propTypes$5.oneOf(['visible', 'hidden', 'scroll', 'auto', 'inherit']),
    pointerEvents: propTypes$5.oneOf(['visiblePainted', 'visibleFill', 'visibleStroke', 'visible', 'painted', 'fill', 'stroke', 'all', 'none', 'inherit']),
    shapeRendering: propTypes$5.oneOf(['auto', 'optimizeSpeed', 'crispEdges', 'geometricPrecision', 'inherit']),
    stopColor: propTypes$5.string,
    stopOpacity: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    stroke: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    strokeDasharray: propTypes$5.string,
    strokeDashoffset: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    strokeLinecap: propTypes$5.oneOf(['butt', 'round', 'square', 'inherit']),
    strokeLinejoin: propTypes$5.oneOf(['miter', 'round', 'bevel', 'inherit']),
    strokeMiterlimit: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    strokeOpacity: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    strokeWidth: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    textAnchor: propTypes$5.oneOf(['start', 'middle', 'end', 'inherit']),
    textDecoration: propTypes$5.oneOf(['none', 'underline', 'overline', 'line-through', 'blink', 'inherit']),
    textRendering: propTypes$5.oneOf(['auto', 'optimizeSpeed', 'optimizeLegibility', 'geometricPrecision', 'inherit']),
    unicodeBidi: propTypes$5.oneOf(['normal', 'embed', 'bidi-override', 'inherit']),
    visibility: propTypes$5.oneOf(['visible', 'hidden', 'collapse', 'inherit']),
    wordSpacing: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    writingMode: propTypes$5.oneOf(['lr-tb', 'rl-tb', 'tb-rl', 'lr', 'rl', 'tb', 'inherit']),
    transform: propTypes$5.string,
    role: propTypes$5.string,
    focusable: propTypes$5.string,
    tabIndex: propTypes$5.string,
    style: propTypes$5.object,
    width: propTypes$5.number,
    height: propTypes$5.number,
    dx: propTypes$5.number,
    dy: propTypes$5.number,
    x: propTypes$5.number,
    y: propTypes$5.number,
    r: propTypes$5.number,
    // The radius of Rectangle
    radius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.array])
  };
  var EVENT_ATTRIBUTES = {
    onClick: propTypes$5.func,
    onMouseDown: propTypes$5.func,
    onMouseUp: propTypes$5.func,
    onMouseOver: propTypes$5.func,
    onMouseMove: propTypes$5.func,
    onMouseOut: propTypes$5.func,
    onMouseEnter: propTypes$5.func,
    onMouseLeave: propTypes$5.func,
    onTouchEnd: propTypes$5.func,
    onTouchMove: propTypes$5.func,
    onTouchStart: propTypes$5.func,
    onTouchCancel: propTypes$5.func
  };
  var REACT_BROWSER_EVENT_MAP = {
    click: 'onClick',
    mousedown: 'onMouseDown',
    mouseup: 'onMouseUp',
    mouseover: 'onMouseOver',
    mousemove: 'onMouseMove',
    mouseout: 'onMouseOut',
    mouseenter: 'onMouseEnter',
    mouseleave: 'onMouseLeave',
    touchcancel: 'onTouchCancel',
    touchend: 'onTouchEnd',
    touchmove: 'onTouchMove',
    touchstart: 'onTouchStart'
  };
  var SCALE_TYPES = ['auto', 'linear', 'pow', 'sqrt', 'log', 'identity', 'time', 'band', 'point', 'ordinal', 'quantile', 'quantize', 'utc', 'sequential', 'threshold'];
  var LEGEND_TYPES = ['plainline', 'line', 'square', 'rect', 'circle', 'cross', 'diamond', 'star', 'triangle', 'wye', 'none'];
  var TOOLTIP_TYPES = ['none'];
  /**
   * Get the display name of a component
   * @param  {Object} Comp Specified Component
   * @return {String}      Display name of Component
   */

  var getDisplayName = function getDisplayName(Comp) {
    if (typeof Comp === 'string') {
      return Comp;
    }

    if (!Comp) {
      return '';
    }

    return Comp.displayName || Comp.name || 'Component';
  };
  /*
   * Find and return all matched children by type. `type` can be a React element class or
   * string
   */

  var findAllByType = function findAllByType(children, type) {
    var result = [];
    var types = [];

    if (isArray_1(type)) {
      types = type.map(function (t) {
        return getDisplayName(t);
      });
    } else {
      types = [getDisplayName(type)];
    }

    React__default['default'].Children.forEach(children, function (child) {
      var childType = child && child.type && (child.type.displayName || child.type.name);

      if (types.indexOf(childType) !== -1) {
        result.push(child);
      }
    });
    return result;
  };
  /*
   * Return the first matched child by type, return null otherwise.
   * `type` can be a React element class or string.
   */

  var findChildByType = function findChildByType(children, type) {
    var result = findAllByType(children, type);
    return result && result[0];
  };
  /**
   * get all the presentation attribute of svg element
   * @param  {Object} el A react element or the props of a react element
   * @return {Object}    attributes or null
   */

  var getPresentationAttributes = function getPresentationAttributes(el) {
    if (!el || isFunction_1(el)) {
      return null;
    }

    var props = React__default['default'].isValidElement(el) ? el.props : el;

    if (!isObject_1(props)) {
      return null;
    }

    var out = null; // eslint-disable-next-line no-restricted-syntax

    for (var i in props) {
      if ({}.hasOwnProperty.call(props, i) && PRESENTATION_ATTRIBUTES[i]) {
        if (!out) out = {};
        out[i] = props[i];
      }
    }

    return out;
  };

  var getEventHandlerOfElement = function getEventHandlerOfElement(originalHandler, props) {
    return function (e) {
      originalHandler(props, e);
      return null;
    };
  };
  /**
   * get all the event attribute of svg element
   * @param  {Object}   el           A react element or the props of a react element
   * @param  {Function} newHandler   New handler of event
   * @param  {Boolean}  wrapCallback Wrap callback and return more parameters or not
   * @return {Object}                attributes or null
   */


  var filterEventAttributes = function filterEventAttributes(el, newHandler) {
    var wrapCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!el || isFunction_1(el)) {
      return null;
    }

    var props = React__default['default'].isValidElement(el) ? el.props : el;

    if (!isObject_1(props)) {
      return null;
    }

    var out = null; // eslint-disable-next-line no-restricted-syntax

    for (var i in props) {
      if ({}.hasOwnProperty.call(props, i) && EVENT_ATTRIBUTES[i]) {
        if (!out) out = {};
        out[i] = newHandler || (wrapCallback ? getEventHandlerOfElement(props[i], props) : props[i]);
      }
    }

    return out;
  };

  var getEventHandlerOfChild = function getEventHandlerOfChild(originalHandler, data, index) {
    return function (e) {
      originalHandler(data, index, e);
      return null;
    };
  };

  var filterEventsOfChild = function filterEventsOfChild(props, data, index) {
    if (!isObject_1(props)) {
      return null;
    }

    var out = null; // eslint-disable-next-line no-restricted-syntax

    for (var i in props) {
      if ({}.hasOwnProperty.call(props, i) && EVENT_ATTRIBUTES[i] && isFunction_1(props[i])) {
        if (!out) out = {};
        out[i] = getEventHandlerOfChild(props[i], data, index);
      }
    }

    return out;
  };
  /**
   * validate the width and height props of a chart element
   * @param  {Object} el A chart element
   * @return {Boolean}   true If the props width and height are number, and greater than 0
   */

  var validateWidthHeight = function validateWidthHeight(el) {
    if (!el || !el.props) {
      return false;
    }

    var _el$props = el.props,
        width = _el$props.width,
        height = _el$props.height;

    if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0) {
      return false;
    }

    return true;
  };
  var isSsr = function isSsr() {
    return !(typeof window !== 'undefined' && window.document && window.document.createElement && window.setTimeout);
  };
  var SVG_TAGS = ['a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColormatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-url', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line', 'lineGradient', 'marker', 'mask', 'metadata', 'missing-glyph', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script', 'set', 'stop', 'style', 'svg', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'];

  var isSvgElement = function isSvgElement(child) {
    return child && child.type && isString_1(child.type) && SVG_TAGS.indexOf(child.type) >= 0;
  };
  var isSingleChildEqual = function isSingleChildEqual(nextChild, prevChild) {
    if (isNil_1(nextChild) && isNil_1(prevChild)) {
      return true;
    }

    if (!isNil_1(nextChild) && !isNil_1(prevChild)) {
      var _ref = nextChild.props || {},
          nextChildren = _ref.children,
          nextProps = _objectWithoutProperties$9(_ref, ["children"]);

      var _ref2 = prevChild.props || {},
          prevChildren = _ref2.children,
          prevProps = _objectWithoutProperties$9(_ref2, ["children"]);

      if (nextChildren && prevChildren) {
        // eslint-disable-next-line no-use-before-define
        return shallowEqual(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);
      }

      if (!nextChildren && !prevChildren) {
        return shallowEqual(nextProps, prevProps);
      }

      return false;
    }

    return false;
  };
  /**
   * Wether props of children changed
   * @param  {Object} nextChildren The latest children
   * @param  {Object} prevChildren The prev children
   * @return {Boolean}             equal or not
   */

  var isChildrenEqual = function isChildrenEqual(nextChildren, prevChildren) {
    if (nextChildren === prevChildren) {
      return true;
    }

    if (React.Children.count(nextChildren) !== React.Children.count(prevChildren)) {
      return false;
    }

    var count = React.Children.count(nextChildren);

    if (count === 0) {
      return true;
    }

    if (count === 1) {
      return isSingleChildEqual(isArray_1(nextChildren) ? nextChildren[0] : nextChildren, isArray_1(prevChildren) ? prevChildren[0] : prevChildren);
    }

    for (var _i = 0; _i < count; _i++) {
      var nextChild = nextChildren[_i];
      var prevChild = prevChildren[_i];

      if (isArray_1(nextChild) || isArray_1(prevChild)) {
        if (!isChildrenEqual(nextChild, prevChild)) {
          return false;
        }
      } else if (!isSingleChildEqual(nextChild, prevChild)) {
        return false;
      }
    }

    return true;
  };
  var renderByOrder = function renderByOrder(children, renderMap) {
    var elements = [];
    var record = {};
    React.Children.forEach(children, function (child, index) {
      if (child && isSvgElement(child)) {
        elements.push(child);
      } else if (child && renderMap[getDisplayName(child.type)]) {
        var displayName = getDisplayName(child.type);
        var _renderMap$displayNam = renderMap[displayName],
            handler = _renderMap$displayNam.handler,
            once = _renderMap$displayNam.once;

        if (once && !record[displayName] || !once) {
          var results = handler(child, displayName, index);

          if (isArray_1(results)) {
            elements = [elements].concat(_toConsumableArray$8(results));
          } else {
            elements.push(results);
          }

          record[displayName] = true;
        }
      }
    });
    return elements;
  };
  var getReactEventByType = function getReactEventByType(e) {
    var type = e && e.type;

    if (type && REACT_BROWSER_EVENT_MAP[type]) {
      return REACT_BROWSER_EVENT_MAP[type];
    }

    return null;
  };
  var parseChildIndex = function parseChildIndex(child, children) {
    var result = -1;
    React.Children.forEach(children, function (entry, index) {
      if (entry === child) {
        result = index;
      }
    });
    return result;
  };

  function _extends$o() { _extends$o = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$o.apply(this, arguments); }

  function _objectWithoutProperties$8(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$9(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$9(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
  var propTypes$4 = {
    width: propTypes$5.number.isRequired,
    height: propTypes$5.number.isRequired,
    viewBox: propTypes$5.shape({
      x: propTypes$5.number,
      y: propTypes$5.number,
      width: propTypes$5.number,
      height: propTypes$5.number
    }),
    className: propTypes$5.string,
    style: propTypes$5.object,
    children: propTypes$5.oneOfType([propTypes$5.arrayOf(propTypes$5.node), propTypes$5.node])
  };

  function Surface(props) {
    var children = props.children,
        width = props.width,
        height = props.height,
        viewBox = props.viewBox,
        className = props.className,
        style = props.style,
        others = _objectWithoutProperties$8(props, ["children", "width", "height", "viewBox", "className", "style"]);

    var svgView = viewBox || {
      width: width,
      height: height,
      x: 0,
      y: 0
    };
    var layerClass = classnames('recharts-surface', className);
    var attrs = getPresentationAttributes(others);
    return React__default['default'].createElement("svg", _extends$o({}, attrs, {
      className: layerClass,
      width: width,
      height: height,
      style: style,
      viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height),
      version: "1.1"
    }), children);
  }

  Surface.propTypes = propTypes$4;

  function _extends$n() { _extends$n = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$n.apply(this, arguments); }

  function _objectWithoutProperties$7(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$8(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$8(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
  var propTypes$3 = {
    className: propTypes$5.string,
    children: propTypes$5.oneOfType([propTypes$5.arrayOf(propTypes$5.node), propTypes$5.node])
  };

  function Layer(props) {
    var children = props.children,
        className = props.className,
        others = _objectWithoutProperties$7(props, ["children", "className"]);

    var layerClass = classnames('recharts-layer', className);
    return React__default['default'].createElement("g", _extends$n({
      className: layerClass
    }, others), children);
  }

  Layer.propTypes = propTypes$3;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new _ListCache;
    this.size = 0;
  }

  var _stackClear = stackClear;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE$1 = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof _ListCache) {
      var pairs = data.__data__;
      if (!_Map || (pairs.length < LARGE_ARRAY_SIZE$1 - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new _MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;

  var _Stack = Stack;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  var _setCacheAdd = setCacheAdd;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new _MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;

  var _SetCache = SetCache;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  var _arraySome = arraySome;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new _SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!_arraySome(other, function(othValue, othIndex) {
              if (!_cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  /** Built-in value references. */
  var Uint8Array$1 = _root.Uint8Array;

  var _Uint8Array = Uint8Array$1;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$2 = '[object Symbol]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag$1:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$1:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag$2:
        var convert = _mapToArray;

      case setTag$2:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  var _equalByTag = equalByTag;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  var _arrayPush = arrayPush;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  var _arrayFilter = arrayFilter;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };

  var _getSymbols = getSymbols;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
  }

  var _baseIsArguments = baseIsArguments;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$8.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments$2 = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
    return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments_1 = isArguments$2;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse_1;

  module.exports = isBuffer;
  });

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$2 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$2 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  var _isIndex = isIndex;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  var isLength_1 = isLength;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag$1 = '[object Map]',
      numberTag = '[object Number]',
      objectTag$3 = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag = '[object String]',
      weakMapTag$1 = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag$1] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag$3] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag$1] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag$1] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike_1(value) &&
      isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && _freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  module.exports = nodeUtil;
  });

  /* Node.js helper references. */
  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

  var isTypedArray_1 = isTypedArray;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$7.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$4.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             _isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;

    return value === proto;
  }

  var _isPrototype = isPrototype;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeys = baseKeys;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$4.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
        return false;
      }
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  /* Built-in method references that are verified to be native. */
  var DataView$1 = _getNative(_root, 'DataView');

  var _DataView = DataView$1;

  /* Built-in method references that are verified to be native. */
  var Promise$1 = _getNative(_root, 'Promise');

  var _Promise = Promise$1;

  /* Built-in method references that are verified to be native. */
  var Set$2 = _getNative(_root, 'Set');

  var _Set = Set$2;

  /* Built-in method references that are verified to be native. */
  var WeakMap$1 = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap$1;

  /** `Object#toString` result references. */
  var mapTag = '[object Map]',
      objectTag$2 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag = '[object Set]',
      weakMapTag = '[object WeakMap]';

  var dataViewTag = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = _baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag) ||
      (_Map && getTag(new _Map) != mapTag) ||
      (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
      (_Set && getTag(new _Set) != setTag) ||
      (_WeakMap && getTag(new _WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$2 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  var _getTag = getTag;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag$1 = '[object Object]';

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$3.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag : _getTag(object),
        othTag = othIsArr ? arrayTag : _getTag(other);

    objTag = objTag == argsTag ? objectTag$1 : objTag;
    othTag = othTag == argsTag ? objectTag$1 : othTag;

    var objIsObj = objTag == objectTag$1,
        othIsObj = othTag == objectTag$1,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack);
      return (objIsArr || isTypedArray_1(object))
        ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$1.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new _Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new _Stack);
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
      return value !== value && other !== other;
    }
    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new _Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  var _baseIsMatch = baseIsMatch;

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject_1(value);
  }

  var _isStrictComparable = isStrictComparable;

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys_1(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, _isStrictComparable(value)];
    }
    return result;
  }

  var _getMatchData = getMatchData;

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  var _matchesStrictComparable = matchesStrictComparable;

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = _getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || _baseIsMatch(object, source, matchData);
    };
  }

  var _baseMatches = baseMatches;

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) &&
      (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (_isKey(path) && _isStrictComparable(srcValue)) {
      return _matchesStrictComparable(_toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get_1(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn_1(object, path)
        : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  var _baseMatchesProperty = baseMatchesProperty;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$4(value) {
    return value;
  }

  var identity_1 = identity$4;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return _baseGet(object, path);
    };
  }

  var _basePropertyDeep = basePropertyDeep;

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
  }

  var property_1 = property;

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity_1;
    }
    if (typeof value == 'object') {
      return isArray_1(value)
        ? _baseMatchesProperty(value[0], value[1])
        : _baseMatches(value);
    }
    return property_1(value);
  }

  var _baseIteratee = baseIteratee;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  var _baseFindIndex = baseFindIndex;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  var _strictIndexOf = strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? _strictIndexOf(array, value, fromIndex)
      : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOf(array, value, 0) > -1;
  }

  var _arrayIncludes = arrayIncludes;

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  var _arrayIncludesWith = arrayIncludesWith;

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop$1() {
    // No operation performed.
  }

  var noop_1 = noop$1;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Creates a set object of `values`.
   *
   * @private
   * @param {Array} values The values to add to the set.
   * @returns {Object} Returns the new set.
   */
  var createSet = !(_Set && (1 / _setToArray(new _Set([,-0]))[1]) == INFINITY$1) ? noop_1 : function(values) {
    return new _Set(values);
  };

  var _createSet = createSet;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * The base implementation of `_.uniqBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   */
  function baseUniq(array, iteratee, comparator) {
    var index = -1,
        includes = _arrayIncludes,
        length = array.length,
        isCommon = true,
        result = [],
        seen = result;

    if (comparator) {
      isCommon = false;
      includes = _arrayIncludesWith;
    }
    else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : _createSet(array);
      if (set) {
        return _setToArray(set);
      }
      isCommon = false;
      includes = _cacheHas;
      seen = new _SetCache;
    }
    else {
      seen = iteratee ? [] : result;
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      }
      else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  var _baseUniq = baseUniq;

  /**
   * This method is like `_.uniq` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * uniqueness is computed. The order of result values is determined by the
   * order they occur in the array. The iteratee is invoked with one argument:
   * (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
   * // => [2.1, 1.2]
   *
   * // The `_.property` iteratee shorthand.
   * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }, { 'x': 2 }]
   */
  function uniqBy(array, iteratee) {
    return (array && array.length) ? _baseUniq(array, _baseIteratee(iteratee)) : [];
  }

  var uniqBy_1 = uniqBy;

  var pi$1 = Math.PI,
      tau$1 = 2 * pi$1,
      epsilon = 1e-6,
      tauEpsilon = tau$1 - epsilon;

  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }

  function path() {
    return new Path;
  }

  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo: function(x, y) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x, y) {
      this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
      this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x1,y1).
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
      else if (!(l01_2 > epsilon));

      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Otherwise, draw an arc!
      else {
        var x20 = x2 - x0,
            y20 = y2 - y0,
            l21_2 = x21 * x21 + y21 * y21,
            l20_2 = x20 * x20 + y20 * y20,
            l21 = Math.sqrt(l21_2),
            l01 = Math.sqrt(l01_2),
            l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
            t01 = l / l01,
            t21 = l / l21;

        // If the start tangent is not coincident with (x0,y0), line to.
        if (Math.abs(t01 - 1) > epsilon) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }

        this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc: function(x, y, r, a0, a1, ccw) {
      x = +x, y = +y, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x0,y0).
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      }

      // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
      else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._ += "L" + x0 + "," + y0;
      }

      // Is this arc empty? Were done.
      if (!r) return;

      // Does the angle go the wrong way? Flip the direction.
      if (da < 0) da = da % tau$1 + tau$1;

      // Is this a complete circle? Draw two arcs to complete the circle.
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      }

      // Is this arc non-empty? Draw an arc!
      else if (da > epsilon) {
        this._ += "A" + r + "," + r + ",0," + (+(da >= pi$1)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
    },
    rect: function(x, y, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
    },
    toString: function() {
      return this._;
    }
  };

  function constant$3(x) {
    return function constant() {
      return x;
    };
  }

  var pi = Math.PI;
  var tau = 2 * pi;

  function Linear(context) {
    this._context = context;
  }

  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; // proceed
        default: this._context.lineTo(x, y); break;
      }
    }
  };

  function curveLinear(context) {
    return new Linear(context);
  }

  function x(p) {
    return p[0];
  }

  function y(p) {
    return p[1];
  }

  function shapeLine() {
    var x$1 = x,
        y$1 = y,
        defined = constant$3(true),
        context = null,
        curve = curveLinear,
        output = null;

    function line(data) {
      var i,
          n = data.length,
          d,
          defined0 = false,
          buffer;

      if (context == null) output = curve(buffer = path());

      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) output.lineStart();
          else output.lineEnd();
        }
        if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
      }

      if (buffer) return output = null, buffer + "" || null;
    }

    line.x = function(_) {
      return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$3(+_), line) : x$1;
    };

    line.y = function(_) {
      return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$3(+_), line) : y$1;
    };

    line.defined = function(_) {
      return arguments.length ? (defined = typeof _ === "function" ? _ : constant$3(!!_), line) : defined;
    };

    line.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
    };

    line.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
    };

    return line;
  }

  function shapeArea() {
    var x0 = x,
        x1 = null,
        y0 = constant$3(0),
        y1 = y,
        defined = constant$3(true),
        context = null,
        curve = curveLinear,
        output = null;

    function area(data) {
      var i,
          j,
          k,
          n = data.length,
          d,
          defined0 = false,
          buffer,
          x0z = new Array(n),
          y0z = new Array(n);

      if (context == null) output = curve(buffer = path());

      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) {
            j = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k = i - 1; k >= j; --k) {
              output.point(x0z[k], y0z[k]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
          output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
        }
      }

      if (buffer) return output = null, buffer + "" || null;
    }

    function arealine() {
      return shapeLine().defined(defined).curve(curve).context(context);
    }

    area.x = function(_) {
      return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$3(+_), x1 = null, area) : x0;
    };

    area.x0 = function(_) {
      return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$3(+_), area) : x0;
    };

    area.x1 = function(_) {
      return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), area) : x1;
    };

    area.y = function(_) {
      return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$3(+_), y1 = null, area) : y0;
    };

    area.y0 = function(_) {
      return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$3(+_), area) : y0;
    };

    area.y1 = function(_) {
      return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), area) : y1;
    };

    area.lineX0 =
    area.lineY0 = function() {
      return arealine().x(x0).y(y0);
    };

    area.lineY1 = function() {
      return arealine().x(x0).y(y1);
    };

    area.lineX1 = function() {
      return arealine().x(x1).y(y0);
    };

    area.defined = function(_) {
      return arguments.length ? (defined = typeof _ === "function" ? _ : constant$3(!!_), area) : defined;
    };

    area.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
    };

    area.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
    };

    return area;
  }

  var slice$3 = Array.prototype.slice;

  var symbolCircle = {
    draw: function(context, size) {
      var r = Math.sqrt(size / pi);
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, tau);
    }
  };

  var symbolCross = {
    draw: function(context, size) {
      var r = Math.sqrt(size / 5) / 2;
      context.moveTo(-3 * r, -r);
      context.lineTo(-r, -r);
      context.lineTo(-r, -3 * r);
      context.lineTo(r, -3 * r);
      context.lineTo(r, -r);
      context.lineTo(3 * r, -r);
      context.lineTo(3 * r, r);
      context.lineTo(r, r);
      context.lineTo(r, 3 * r);
      context.lineTo(-r, 3 * r);
      context.lineTo(-r, r);
      context.lineTo(-3 * r, r);
      context.closePath();
    }
  };

  var tan30 = Math.sqrt(1 / 3),
      tan30_2 = tan30 * 2;

  var symbolDiamond = {
    draw: function(context, size) {
      var y = Math.sqrt(size / tan30_2),
          x = y * tan30;
      context.moveTo(0, -y);
      context.lineTo(x, 0);
      context.lineTo(0, y);
      context.lineTo(-x, 0);
      context.closePath();
    }
  };

  var ka = 0.89081309152928522810,
      kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
      kx = Math.sin(tau / 10) * kr,
      ky = -Math.cos(tau / 10) * kr;

  var symbolStar = {
    draw: function(context, size) {
      var r = Math.sqrt(size * ka),
          x = kx * r,
          y = ky * r;
      context.moveTo(0, -r);
      context.lineTo(x, y);
      for (var i = 1; i < 5; ++i) {
        var a = tau * i / 5,
            c = Math.cos(a),
            s = Math.sin(a);
        context.lineTo(s * r, -c * r);
        context.lineTo(c * x - s * y, s * x + c * y);
      }
      context.closePath();
    }
  };

  var symbolSquare = {
    draw: function(context, size) {
      var w = Math.sqrt(size),
          x = -w / 2;
      context.rect(x, x, w, w);
    }
  };

  var sqrt3 = Math.sqrt(3);

  var symbolTriangle = {
    draw: function(context, size) {
      var y = -Math.sqrt(size / (sqrt3 * 3));
      context.moveTo(0, y * 2);
      context.lineTo(-sqrt3 * y, -y);
      context.lineTo(sqrt3 * y, -y);
      context.closePath();
    }
  };

  var c = -0.5,
      s = Math.sqrt(3) / 2,
      k = 1 / Math.sqrt(12),
      a = (k / 2 + 1) * 3;

  var symbolWye = {
    draw: function(context, size) {
      var r = Math.sqrt(size / a),
          x0 = r / 2,
          y0 = r * k,
          x1 = x0,
          y1 = r * k + r,
          x2 = -x1,
          y2 = y1;
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
      context.lineTo(x2, y2);
      context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
      context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
      context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
      context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
      context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
      context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
      context.closePath();
    }
  };

  function shapeSymbol() {
    var type = constant$3(symbolCircle),
        size = constant$3(64),
        context = null;

    function symbol() {
      var buffer;
      if (!context) context = buffer = path();
      type.apply(this, arguments).draw(context, +size.apply(this, arguments));
      if (buffer) return context = null, buffer + "" || null;
    }

    symbol.type = function(_) {
      return arguments.length ? (type = typeof _ === "function" ? _ : constant$3(_), symbol) : type;
    };

    symbol.size = function(_) {
      return arguments.length ? (size = typeof _ === "function" ? _ : constant$3(+_), symbol) : size;
    };

    symbol.context = function(_) {
      return arguments.length ? (context = _ == null ? null : _, symbol) : context;
    };

    return symbol;
  }

  function noop() {}

  function point$2(that, x, y) {
    that._context.bezierCurveTo(
      (2 * that._x0 + that._x1) / 3,
      (2 * that._y0 + that._y1) / 3,
      (that._x0 + 2 * that._x1) / 3,
      (that._y0 + 2 * that._y1) / 3,
      (that._x0 + 4 * that._x1 + x) / 6,
      (that._y0 + 4 * that._y1 + y) / 6
    );
  }

  function Basis(context) {
    this._context = context;
  }

  Basis.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3: point$2(this, this._x1, this._y1); // proceed
        case 2: this._context.lineTo(this._x1, this._y1); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
        default: point$2(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  function curveBasis(context) {
    return new Basis(context);
  }

  function BasisClosed(context) {
    this._context = context;
  }

  BasisClosed.prototype = {
    areaStart: noop,
    areaEnd: noop,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
      this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
        case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
        case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
        default: point$2(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  function curveBasisClosed(context) {
    return new BasisClosed(context);
  }

  function BasisOpen(context) {
    this._context = context;
  }

  BasisOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
        case 3: this._point = 4; // proceed
        default: point$2(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  function curveBasisOpen(context) {
    return new BasisOpen(context);
  }

  function LinearClosed(context) {
    this._context = context;
  }

  LinearClosed.prototype = {
    areaStart: noop,
    areaEnd: noop,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._point) this._context.closePath();
    },
    point: function(x, y) {
      x = +x, y = +y;
      if (this._point) this._context.lineTo(x, y);
      else this._point = 1, this._context.moveTo(x, y);
    }
  };

  function curveLinearClosed(context) {
    return new LinearClosed(context);
  }

  function sign(x) {
    return x < 0 ? -1 : 1;
  }

  // Calculate the slopes of the tangents (Hermite-type interpolation) based on
  // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
  // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
  // NOV(II), P. 443, 1990.
  function slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0,
        h1 = x2 - that._x1,
        s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
        s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
        p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }

  // Calculate a one-sided slope.
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }

  // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
  // "you can express cubic Hermite interpolation in terms of cubic Bzier curves
  // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
  function point$1(that, t0, t1) {
    var x0 = that._x0,
        y0 = that._y0,
        x1 = that._x1,
        y1 = that._y1,
        dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
  }

  function MonotoneX(context) {
    this._context = context;
  }

  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 =
      this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2: this._context.lineTo(this._x1, this._y1); break;
        case 3: point$1(this, this._t0, slope2(this, this._t0)); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      var t1 = NaN;

      x = +x, y = +y;
      if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; point$1(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
        default: point$1(this, this._t0, t1 = slope3(this, x, y)); break;
      }

      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
      this._t0 = t1;
    }
  };

  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }

  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
    MonotoneX.prototype.point.call(this, y, x);
  };

  function ReflectContext(context) {
    this._context = context;
  }

  ReflectContext.prototype = {
    moveTo: function(x, y) { this._context.moveTo(y, x); },
    closePath: function() { this._context.closePath(); },
    lineTo: function(x, y) { this._context.lineTo(y, x); },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
  };

  function monotoneX(context) {
    return new MonotoneX(context);
  }

  function monotoneY(context) {
    return new MonotoneY(context);
  }

  function Natural(context) {
    this._context = context;
  }

  Natural.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = [];
      this._y = [];
    },
    lineEnd: function() {
      var x = this._x,
          y = this._y,
          n = x.length;

      if (n) {
        this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
        if (n === 2) {
          this._context.lineTo(x[1], y[1]);
        } else {
          var px = controlPoints(x),
              py = controlPoints(y);
          for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
            this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
          }
        }
      }

      if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
      this._line = 1 - this._line;
      this._x = this._y = null;
    },
    point: function(x, y) {
      this._x.push(+x);
      this._y.push(+y);
    }
  };

  // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
  function controlPoints(x) {
    var i,
        n = x.length - 1,
        m,
        a = new Array(n),
        b = new Array(n),
        r = new Array(n);
    a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
    for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
    a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
    for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
    a[n - 1] = r[n - 1] / b[n - 1];
    for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
    b[n - 1] = (x[n] + a[n - 1]) / 2;
    for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
    return [a, b];
  }

  function curveNatural(context) {
    return new Natural(context);
  }

  function Step$1(context, t) {
    this._context = context;
    this._t = t;
  }

  Step$1.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; // proceed
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);
            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;
            this._context.lineTo(x1, this._y);
            this._context.lineTo(x1, y);
          }
          break;
        }
      }
      this._x = x, this._y = y;
    }
  };

  function curveStep(context) {
    return new Step$1(context, 0.5);
  }

  function stepBefore(context) {
    return new Step$1(context, 0);
  }

  function stepAfter(context) {
    return new Step$1(context, 1);
  }

  function stackOffsetNone(series, order) {
    if (!((n = series.length) > 1)) return;
    for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order[i]];
      for (j = 0; j < m; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  }

  function stackOrderNone(series) {
    var n = series.length, o = new Array(n);
    while (--n >= 0) o[n] = n;
    return o;
  }

  function stackValue(d, key) {
    return d[key];
  }

  function shapeStack() {
    var keys = constant$3([]),
        order = stackOrderNone,
        offset = stackOffsetNone,
        value = stackValue;

    function stack(data) {
      var kz = keys.apply(this, arguments),
          i,
          m = data.length,
          n = kz.length,
          sz = new Array(n),
          oz;

      for (i = 0; i < n; ++i) {
        for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
          si[j] = sij = [0, +value(data[j], ki, j, data)];
          sij.data = data[j];
        }
        si.key = ki;
      }

      for (i = 0, oz = order(sz); i < n; ++i) {
        sz[oz[i]].index = i;
      }

      offset(sz, oz);
      return sz;
    }

    stack.keys = function(_) {
      return arguments.length ? (keys = typeof _ === "function" ? _ : constant$3(slice$3.call(_)), stack) : keys;
    };

    stack.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$3(+_), stack) : value;
    };

    stack.order = function(_) {
      return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === "function" ? _ : constant$3(slice$3.call(_)), stack) : order;
    };

    stack.offset = function(_) {
      return arguments.length ? (offset = _ == null ? stackOffsetNone : _, stack) : offset;
    };

    return stack;
  }

  function stackOffsetExpand(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
      for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
      if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
    }
    stackOffsetNone(series, order);
  }

  function stackOffsetSilhouette(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
      for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
      s0[j][1] += s0[j][0] = -y / 2;
    }
    stackOffsetNone(series, order);
  }

  function stackOffsetWiggle(series, order) {
    if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
    for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
      for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
        var si = series[order[i]],
            sij0 = si[j][1] || 0,
            sij1 = si[j - 1][1] || 0,
            s3 = (sij0 - sij1) / 2;
        for (var k = 0; k < i; ++k) {
          var sk = series[order[k]],
              skj0 = sk[j][1] || 0,
              skj1 = sk[j - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      if (s1) y -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    stackOffsetNone(series, order);
  }

  function ownKeys$o(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$o(source, true).forEach(function (key) { _defineProperty$v(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$o(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$v(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof$o(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$o = function _typeof(obj) { return typeof obj; }; } else { _typeof$o = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$o(obj); }

  function _extends$m() { _extends$m = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$m.apply(this, arguments); }

  function _classCallCheck$o(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$o(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$o(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$o(Constructor.prototype, protoProps); if (staticProps) _defineProperties$o(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$n(self, call) { if (call && (_typeof$o(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$o(self); }

  function _assertThisInitialized$o(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$n(o) { _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$n(o); }

  function _inherits$n(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$n(subClass, superClass); }

  function _setPrototypeOf$n(o, p) { _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$n(o, p); }
  var SYMBOL_FACTORIES = {
    symbolCircle: symbolCircle,
    symbolCross: symbolCross,
    symbolDiamond: symbolDiamond,
    symbolSquare: symbolSquare,
    symbolStar: symbolStar,
    symbolTriangle: symbolTriangle,
    symbolWye: symbolWye
  };
  var RADIAN$2 = Math.PI / 180;

  var getSymbolFactory = function getSymbolFactory(type) {
    var name = "symbol".concat(type.slice(0, 1).toUpperCase()).concat(type.slice(1));
    return SYMBOL_FACTORIES[name] || symbolCircle;
  };

  var calculateAreaSize = function calculateAreaSize(size, sizeType, type) {
    if (sizeType === 'area') {
      return size;
    }

    switch (type) {
      case 'cross':
        return 5 * size * size / 9;

      case 'diamond':
        return 0.5 * size * size / Math.sqrt(3);

      case 'square':
        return size * size;

      case 'star':
        {
          var angle = 18 * RADIAN$2;
          return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));
        }

      case 'triangle':
        return Math.sqrt(3) * size * size / 4;

      case 'wye':
        return (21 - 10 * Math.sqrt(3)) * size * size / 8;

      default:
        return Math.PI * size * size / 4;
    }
  };

  var Symbols =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$n(Symbols, _PureComponent);

    function Symbols() {
      _classCallCheck$o(this, Symbols);

      return _possibleConstructorReturn$n(this, _getPrototypeOf$n(Symbols).apply(this, arguments));
    }

    _createClass$o(Symbols, [{
      key: "getPath",

      /**
       * Calculate the path of curve
       * @return {String} path
       */
      value: function getPath() {
        var _this$props = this.props,
            size = _this$props.size,
            sizeType = _this$props.sizeType,
            type = _this$props.type;
        var symbolFactory = getSymbolFactory(type);
        var symbol = shapeSymbol().type(symbolFactory).size(calculateAreaSize(size, sizeType, type));
        return symbol();
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            className = _this$props2.className,
            cx = _this$props2.cx,
            cy = _this$props2.cy,
            size = _this$props2.size;

        if (cx === +cx && cy === +cy && size === +size) {
          return React__default['default'].createElement("path", _extends$m({}, getPresentationAttributes(this.props), filterEventAttributes(this.props), {
            className: classnames('recharts-symbols', className),
            transform: "translate(".concat(cx, ", ").concat(cy, ")"),
            d: this.getPath()
          }));
        }

        return null;
      }
    }]);

    return Symbols;
  }(React.PureComponent);

  Symbols.displayName = 'Symbols';
  Symbols.propTypes = _objectSpread$r({}, PRESENTATION_ATTRIBUTES, {
    className: propTypes$5.string,
    type: propTypes$5.oneOf(['circle', 'cross', 'diamond', 'square', 'star', 'triangle', 'wye']),
    cx: propTypes$5.number,
    cy: propTypes$5.number,
    size: propTypes$5.number,
    sizeType: propTypes$5.oneOf(['area', 'diameter'])
  });
  Symbols.defaultProps = {
    type: 'circle',
    size: 64,
    sizeType: 'area'
  };

  function _typeof$n(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$n = function _typeof(obj) { return typeof obj; }; } else { _typeof$n = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$n(obj); }

  function _extends$l() { _extends$l = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$l.apply(this, arguments); }

  function _defineProperty$u(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$n(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$n(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$n(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$n(Constructor.prototype, protoProps); if (staticProps) _defineProperties$n(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$m(self, call) { if (call && (_typeof$n(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$n(self); }

  function _assertThisInitialized$n(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$m(o) { _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$m(o); }

  function _inherits$m(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$m(subClass, superClass); }

  function _setPrototypeOf$m(o, p) { _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$m(o, p); }
  var SIZE = 32;
  var ICON_TYPES$1 = LEGEND_TYPES.filter(function (type) {
    return type !== 'none';
  });

  var DefaultLegendContent =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$m(DefaultLegendContent, _PureComponent);

    function DefaultLegendContent() {
      _classCallCheck$n(this, DefaultLegendContent);

      return _possibleConstructorReturn$m(this, _getPrototypeOf$m(DefaultLegendContent).apply(this, arguments));
    }

    _createClass$n(DefaultLegendContent, [{
      key: "renderIcon",

      /**
       * Render the path of icon
       * @param {Object} data Data of each legend item
       * @return {String} Path element
       */
      value: function renderIcon(data) {
        var inactiveColor = this.props.inactiveColor;
        var halfSize = SIZE / 2;
        var sixthSize = SIZE / 6;
        var thirdSize = SIZE / 3;
        var color = data.inactive ? inactiveColor : data.color;

        if (data.type === 'plainline') {
          return React__default['default'].createElement("line", {
            strokeWidth: 4,
            fill: "none",
            stroke: color,
            strokeDasharray: data.payload.strokeDasharray,
            x1: 0,
            y1: halfSize,
            x2: SIZE,
            y2: halfSize,
            className: "recharts-legend-icon"
          });
        }

        if (data.type === 'line') {
          return React__default['default'].createElement("path", {
            strokeWidth: 4,
            fill: "none",
            stroke: color,
            d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
            className: "recharts-legend-icon"
          });
        }

        if (data.type === 'rect') {
          return React__default['default'].createElement("path", {
            stroke: "none",
            fill: color,
            d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
            className: "recharts-legend-icon"
          });
        }

        return React__default['default'].createElement(Symbols, {
          fill: color,
          cx: halfSize,
          cy: halfSize,
          size: SIZE,
          sizeType: "diameter",
          type: data.type
        });
      }
      /**
       * Draw items of legend
       * @return {ReactElement} Items
       */

    }, {
      key: "renderItems",
      value: function renderItems() {
        var _this = this;

        var _this$props = this.props,
            payload = _this$props.payload,
            iconSize = _this$props.iconSize,
            layout = _this$props.layout,
            formatter = _this$props.formatter;
        var viewBox = {
          x: 0,
          y: 0,
          width: SIZE,
          height: SIZE
        };
        var itemStyle = {
          display: layout === 'horizontal' ? 'inline-block' : 'block',
          marginRight: 10
        };
        var svgStyle = {
          display: 'inline-block',
          verticalAlign: 'middle',
          marginRight: 4
        };
        return payload.map(function (entry, i) {
          var _classNames;

          var finalFormatter = entry.formatter || formatter;
          var className = classnames((_classNames = {
            'recharts-legend-item': true
          }, _defineProperty$u(_classNames, "legend-item-".concat(i), true), _defineProperty$u(_classNames, "inactive", entry.inactive), _classNames));

          if (entry.type === 'none') {
            return null;
          }

          return React__default['default'].createElement("li", _extends$l({
            className: className,
            style: itemStyle,
            key: "legend-item-".concat(i) // eslint-disable-line react/no-array-index-key

          }, filterEventsOfChild(_this.props, entry, i)), React__default['default'].createElement(Surface, {
            width: iconSize,
            height: iconSize,
            viewBox: viewBox,
            style: svgStyle
          }, _this.renderIcon(entry)), React__default['default'].createElement("span", {
            className: "recharts-legend-item-text"
          }, finalFormatter ? finalFormatter(entry.value, entry, i) : entry.value));
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            payload = _this$props2.payload,
            layout = _this$props2.layout,
            align = _this$props2.align;

        if (!payload || !payload.length) {
          return null;
        }

        var finalStyle = {
          padding: 0,
          margin: 0,
          textAlign: layout === 'horizontal' ? align : 'left'
        };
        return React__default['default'].createElement("ul", {
          className: "recharts-default-legend",
          style: finalStyle
        }, this.renderItems());
      }
    }]);

    return DefaultLegendContent;
  }(React.PureComponent);

  DefaultLegendContent.displayName = 'Legend';
  DefaultLegendContent.propTypes = {
    content: propTypes$5.element,
    iconSize: propTypes$5.number,
    iconType: propTypes$5.oneOf(ICON_TYPES$1),
    layout: propTypes$5.oneOf(['horizontal', 'vertical']),
    align: propTypes$5.oneOf(['center', 'left', 'right']),
    verticalAlign: propTypes$5.oneOf(['top', 'bottom', 'middle']),
    payload: propTypes$5.arrayOf(propTypes$5.shape({
      value: propTypes$5.any,
      id: propTypes$5.any,
      type: propTypes$5.oneOf(LEGEND_TYPES)
    })),
    inactiveColor: propTypes$5.string,
    formatter: propTypes$5.func,
    onMouseEnter: propTypes$5.func,
    onMouseLeave: propTypes$5.func,
    onClick: propTypes$5.func
  };
  DefaultLegendContent.defaultProps = {
    iconSize: 14,
    layout: 'horizontal',
    align: 'center',
    verticalAlign: 'middle',
    inactiveColor: '#ccc'
  };

  function _typeof$m(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$m = function _typeof(obj) { return typeof obj; }; } else { _typeof$m = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$m(obj); }

  function ownKeys$n(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$n(source, true).forEach(function (key) { _defineProperty$t(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$n(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$t(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$m(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$m(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$m(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$m(Constructor.prototype, protoProps); if (staticProps) _defineProperties$m(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$l(self, call) { if (call && (_typeof$m(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$m(self); }

  function _assertThisInitialized$m(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$l(o) { _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$l(o); }

  function _inherits$l(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$l(subClass, superClass); }

  function _setPrototypeOf$l(o, p) { _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$l(o, p); }

  var defaultUniqBy$1 = function defaultUniqBy(entry) {
    return entry.value;
  };

  var getUniqPaylod$1 = function getUniqPaylod(option, payload) {
    if (option === true) {
      return uniqBy_1(payload, defaultUniqBy$1);
    }

    if (isFunction_1(option)) {
      return uniqBy_1(payload, option);
    }

    return payload;
  };

  var renderContent$1 = function renderContent(content, props) {
    if (React__default['default'].isValidElement(content)) {
      return React__default['default'].cloneElement(content, props);
    }

    if (isFunction_1(content)) {
      return content(props);
    }

    return React__default['default'].createElement(DefaultLegendContent, props);
  };

  var EPS$2 = 1;
  var ICON_TYPES = LEGEND_TYPES.filter(function (type) {
    return type !== 'none';
  });

  var Legend$1 =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$l(Legend, _PureComponent);

    function Legend() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck$m(this, Legend);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn$l(this, (_getPrototypeOf2 = _getPrototypeOf$l(Legend)).call.apply(_getPrototypeOf2, [this].concat(args)));
      _this.state = {
        boxWidth: -1,
        boxHeight: -1
      };
      return _this;
    }

    _createClass$m(Legend, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateBBox();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.updateBBox();
      }
    }, {
      key: "getBBox",
      value: function getBBox() {
        var _this$state = this.state,
            boxWidth = _this$state.boxWidth,
            boxHeight = _this$state.boxHeight;

        if (boxWidth >= 0 && boxHeight >= 0) {
          return {
            width: boxWidth,
            height: boxHeight
          };
        }

        return null;
      }
    }, {
      key: "getDefaultPosition",
      value: function getDefaultPosition(style) {
        var _this$props = this.props,
            layout = _this$props.layout,
            align = _this$props.align,
            verticalAlign = _this$props.verticalAlign,
            margin = _this$props.margin,
            chartWidth = _this$props.chartWidth,
            chartHeight = _this$props.chartHeight;
        var hPos, vPos;

        if (!style || (style.left === undefined || style.left === null) && (style.right === undefined || style.right === null)) {
          if (align === 'center' && layout === 'vertical') {
            var box = this.getBBox() || {
              width: 0
            };
            hPos = {
              left: ((chartWidth || 0) - box.width) / 2
            };
          } else {
            hPos = align === 'right' ? {
              right: margin && margin.right || 0
            } : {
              left: margin && margin.left || 0
            };
          }
        }

        if (!style || (style.top === undefined || style.top === null) && (style.bottom === undefined || style.bottom === null)) {
          if (verticalAlign === 'middle') {
            var _box = this.getBBox() || {
              height: 0
            };

            vPos = {
              top: ((chartHeight || 0) - _box.height) / 2
            };
          } else {
            vPos = verticalAlign === 'bottom' ? {
              bottom: margin && margin.bottom || 0
            } : {
              top: margin && margin.top || 0
            };
          }
        }

        return _objectSpread$q({}, hPos, {}, vPos);
      }
    }, {
      key: "updateBBox",
      value: function updateBBox() {
        var _this$state2 = this.state,
            boxWidth = _this$state2.boxWidth,
            boxHeight = _this$state2.boxHeight;
        var onBBoxUpdate = this.props.onBBoxUpdate;

        if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
          var box = this.wrapperNode.getBoundingClientRect();

          if (Math.abs(box.width - boxWidth) > EPS$2 || Math.abs(box.height - boxHeight) > EPS$2) {
            this.setState({
              boxWidth: box.width,
              boxHeight: box.height
            }, function () {
              if (onBBoxUpdate) {
                onBBoxUpdate(box);
              }
            });
          }
        } else if (boxWidth !== -1 || boxHeight !== -1) {
          this.setState({
            boxWidth: -1,
            boxHeight: -1
          }, function () {
            if (onBBoxUpdate) {
              onBBoxUpdate(null);
            }
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props2 = this.props,
            content = _this$props2.content,
            width = _this$props2.width,
            height = _this$props2.height,
            wrapperStyle = _this$props2.wrapperStyle,
            paylodUniqBy = _this$props2.paylodUniqBy,
            payload = _this$props2.payload;

        var outerStyle = _objectSpread$q({
          position: 'absolute',
          width: width || 'auto',
          height: height || 'auto'
        }, this.getDefaultPosition(wrapperStyle), {}, wrapperStyle);

        return React__default['default'].createElement("div", {
          className: "recharts-legend-wrapper",
          style: outerStyle,
          ref: function ref(node) {
            _this2.wrapperNode = node;
          }
        }, renderContent$1(content, _objectSpread$q({}, this.props, {
          payload: getUniqPaylod$1(paylodUniqBy, payload)
        })));
      }
    }], [{
      key: "getWithHeight",
      value: function getWithHeight(item, chartWidth) {
        var layout = item.props.layout;

        if (layout === 'vertical' && isNumber(item.props.height)) {
          return {
            height: item.props.height
          };
        }

        if (layout === 'horizontal') {
          return {
            width: item.props.width || chartWidth
          };
        }

        return null;
      }
    }]);

    return Legend;
  }(React.PureComponent);

  Legend$1.displayName = 'Legend';
  Legend$1.propTypes = {
    content: propTypes$5.oneOfType([propTypes$5.element, propTypes$5.func]),
    wrapperStyle: propTypes$5.object,
    chartWidth: propTypes$5.number,
    chartHeight: propTypes$5.number,
    width: propTypes$5.number,
    height: propTypes$5.number,
    iconSize: propTypes$5.number,
    iconType: propTypes$5.oneOf(ICON_TYPES),
    layout: propTypes$5.oneOf(['horizontal', 'vertical']),
    align: propTypes$5.oneOf(['center', 'left', 'right']),
    verticalAlign: propTypes$5.oneOf(['top', 'bottom', 'middle']),
    margin: propTypes$5.shape({
      top: propTypes$5.number,
      left: propTypes$5.number,
      bottom: propTypes$5.number,
      right: propTypes$5.number
    }),
    payload: propTypes$5.arrayOf(propTypes$5.shape({
      value: propTypes$5.any,
      id: propTypes$5.any,
      type: propTypes$5.oneOf(LEGEND_TYPES)
    })),
    paylodUniqBy: propTypes$5.oneOfType([propTypes$5.func, propTypes$5.bool]),
    formatter: propTypes$5.func,
    onMouseEnter: propTypes$5.func,
    onMouseLeave: propTypes$5.func,
    onClick: propTypes$5.func,
    onBBoxUpdate: propTypes$5.func
  };
  Legend$1.defaultProps = {
    iconSize: 14,
    layout: 'horizontal',
    align: 'center',
    verticalAlign: 'bottom'
  };

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */
  function isEqual(value, other) {
    return _baseIsEqual(value, other);
  }

  var isEqual_1 = isEqual;

  var performanceNow = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.2
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

    if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
      module.exports = function() {
        return performance.now();
      };
    } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
      module.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }

  }).call(commonjsGlobal);


  });

  var root$2 = typeof window === 'undefined' ? commonjsGlobal : window
    , vendors = ['moz', 'webkit']
    , suffix = 'AnimationFrame'
    , raf = root$2['request' + suffix]
    , caf = root$2['cancel' + suffix] || root$2['cancelRequest' + suffix];

  for(var i = 0; !raf && i < vendors.length; i++) {
    raf = root$2[vendors[i] + 'Request' + suffix];
    caf = root$2[vendors[i] + 'Cancel' + suffix]
        || root$2[vendors[i] + 'CancelRequest' + suffix];
  }

  // Some versions of FF have rAF but not cAF
  if(!raf || !caf) {
    var last$1 = 0
      , id = 0
      , queue = []
      , frameDuration = 1000 / 60;

    raf = function(callback) {
      if(queue.length === 0) {
        var _now = performanceNow()
          , next = Math.max(0, frameDuration - (_now - last$1));
        last$1 = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0;
          for(var i = 0; i < cp.length; i++) {
            if(!cp[i].cancelled) {
              try{
                cp[i].callback(last$1);
              } catch(e) {
                setTimeout(function() { throw e }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false
      });
      return id
    };

    caf = function(handle) {
      for(var i = 0; i < queue.length; i++) {
        if(queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  var raf_1 = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root$2, fn)
  };
  var cancel = function() {
    caf.apply(root$2, arguments);
  };
  var polyfill$3 = function(object) {
    if (!object) {
      object = root$2;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };
  raf_1.cancel = cancel;
  raf_1.polyfill = polyfill$3;

  function setRafTimeout(callback) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var currTime = -1;

    var shouldUpdate = function shouldUpdate(now) {
      if (currTime < 0) {
        currTime = now;
      }

      if (now - currTime > timeout) {
        callback(now);
        currTime = -1;
      } else {
        raf_1(shouldUpdate);
      }
    };

    raf_1(shouldUpdate);
  }

  function _typeof$l(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$l = function _typeof(obj) { return typeof obj; }; } else { _typeof$l = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$l(obj); }

  function _toArray(arr) { return _arrayWithHoles$6(arr) || _iterableToArray$8(arr) || _nonIterableRest$6(); }

  function _nonIterableRest$6() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArray$8(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithHoles$6(arr) { if (Array.isArray(arr)) return arr; }
  function createAnimateManager() {
    var currStyle = {};

    var handleChange = function handleChange() {
      return null;
    };

    var shouldStop = false;

    var setStyle = function setStyle(_style) {
      if (shouldStop) {
        return;
      }

      if (Array.isArray(_style)) {
        if (!_style.length) {
          return;
        }

        var styles = _style;

        var _styles = _toArray(styles),
            curr = _styles[0],
            restStyles = _styles.slice(1);

        if (typeof curr === 'number') {
          setRafTimeout(setStyle.bind(null, restStyles), curr);
          return;
        }

        setStyle(curr);
        setRafTimeout(setStyle.bind(null, restStyles));
        return;
      }

      if (_typeof$l(_style) === 'object') {
        currStyle = _style;
        handleChange(currStyle);
      }

      if (typeof _style === 'function') {
        _style();
      }
    };

    return {
      stop: function stop() {
        shouldStop = true;
      },
      start: function start(style) {
        shouldStop = false;
        setStyle(style);
      },
      subscribe: function subscribe(_handleChange) {
        handleChange = _handleChange;
        return function () {
          handleChange = function handleChange() {
            return null;
          };
        };
      }
    };
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMin$3 = Math.min;

  /**
   * The base implementation of methods like `_.intersection`, without support
   * for iteratee shorthands, that accepts an array of arrays to inspect.
   *
   * @private
   * @param {Array} arrays The arrays to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of shared values.
   */
  function baseIntersection(arrays, iteratee, comparator) {
    var includes = comparator ? _arrayIncludesWith : _arrayIncludes,
        length = arrays[0].length,
        othLength = arrays.length,
        othIndex = othLength,
        caches = Array(othLength),
        maxLength = Infinity,
        result = [];

    while (othIndex--) {
      var array = arrays[othIndex];
      if (othIndex && iteratee) {
        array = _arrayMap(array, _baseUnary(iteratee));
      }
      maxLength = nativeMin$3(array.length, maxLength);
      caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
        ? new _SetCache(othIndex && array)
        : undefined;
    }
    array = arrays[0];

    var index = -1,
        seen = caches[0];

    outer:
    while (++index < length && result.length < maxLength) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;

      value = (comparator || value !== 0) ? value : 0;
      if (!(seen
            ? _cacheHas(seen, computed)
            : includes(result, computed, comparator)
          )) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache
                ? _cacheHas(cache, computed)
                : includes(arrays[othIndex], computed, comparator))
              ) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  var _baseIntersection = baseIntersection;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  var _apply = apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$5 = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax$5(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax$5(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant$2(value) {
    return function() {
      return value;
    };
  }

  var constant_1 = constant$2;

  var defineProperty$4 = (function() {
    try {
      var func = _getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  var _defineProperty$s = defineProperty$4;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !_defineProperty$s ? identity_1 : function(func, string) {
    return _defineProperty$s(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };

  var _baseSetToString = baseSetToString;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = _shortOut(_baseSetToString);

  var _setToString = setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike_1(value) && isArrayLike_1(value);
  }

  var isArrayLikeObject_1 = isArrayLikeObject;

  /**
   * Casts `value` to an empty array if it's not an array like object.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Array|Object} Returns the cast array-like object.
   */
  function castArrayLikeObject(value) {
    return isArrayLikeObject_1(value) ? value : [];
  }

  var _castArrayLikeObject = castArrayLikeObject;

  /**
   * Creates an array of unique values that are included in all given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * _.intersection([2, 1], [2, 3]);
   * // => [2]
   */
  var intersection = _baseRest(function(arrays) {
    var mapped = _arrayMap(arrays, _castArrayLikeObject);
    return (mapped.length && mapped[0] === arrays[0])
      ? _baseIntersection(mapped)
      : [];
  });

  var intersection_1 = intersection;

  function _objectSpread$p(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$r(target, key, source[key]); }); } return target; }

  function _defineProperty$r(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  /* eslint no-console: 0 */
  var PREFIX_LIST$1 = ['Webkit', 'Moz', 'O', 'ms'];
  var IN_LINE_PREFIX_LIST = ['-webkit-', '-moz-', '-o-', '-ms-'];
  var IN_COMPATIBLE_PROPERTY = ['transform', 'transformOrigin', 'transition'];
  var getIntersectionKeys = function getIntersectionKeys(preObj, nextObj) {
    return intersection_1(Object.keys(preObj), Object.keys(nextObj));
  };
  var identity$3 = function identity(param) {
    return param;
  };
  /*
   * @description: convert camel case to dash case
   * string => string
   */

  var getDashCase = function getDashCase(name) {
    return name.replace(/([A-Z])/g, function (v) {
      return "-".concat(v.toLowerCase());
    });
  };
  /*
   * @description: add compatible style prefix
   * (string, string) => object
   */

  var generatePrefixStyle$1 = function generatePrefixStyle(name, value) {
    if (IN_COMPATIBLE_PROPERTY.indexOf(name) === -1) {
      return _defineProperty$r({}, name, value);
    }

    var isTransition = name === 'transition';
    var camelName = name.replace(/(\w)/, function (v) {
      return v.toUpperCase();
    });
    var styleVal = value;
    return PREFIX_LIST$1.reduce(function (result, property, i) {
      if (isTransition) {
        styleVal = value.replace(/(transform|transform-origin)/gim, "".concat(IN_LINE_PREFIX_LIST[i], "$1"));
      }

      return _objectSpread$p({}, result, _defineProperty$r({}, property + camelName, styleVal));
    }, {});
  };
  /*
   * @description: map object on every element in this object.
   * (function, object) => object
   */

  var mapObject = function mapObject(fn, obj) {
    return Object.keys(obj).reduce(function (res, key) {
      return _objectSpread$p({}, res, _defineProperty$r({}, key, fn(key, obj[key])));
    }, {});
  };
  /*
   * @description: add compatible prefix to style
   * object => object
   */

  var translateStyle = function translateStyle(style) {
    return Object.keys(style).reduce(function (res, key) {
      return _objectSpread$p({}, res, generatePrefixStyle$1(key, res[key]));
    }, style);
  };
  var getTransitionVal = function getTransitionVal(props, duration, easing) {
    return props.map(function (prop) {
      return "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing);
    }).join(',');
  };

  function _slicedToArray$5(arr, i) { return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _nonIterableRest$5(); }

  function _nonIterableRest$5() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$5(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$5(arr) { if (Array.isArray(arr)) return arr; }

  function _toConsumableArray$7(arr) { return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _nonIterableSpread$7(); }

  function _nonIterableSpread$7() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray$7(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles$7(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }
  var ACCURACY = 1e-4;

  var cubicBezierFactor = function cubicBezierFactor(c1, c2) {
    return [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
  };

  var multyTime = function multyTime(params, t) {
    return params.map(function (param, i) {
      return param * Math.pow(t, i);
    }).reduce(function (pre, curr) {
      return pre + curr;
    });
  };

  var cubicBezier = function cubicBezier(c1, c2) {
    return function (t) {
      var params = cubicBezierFactor(c1, c2);
      return multyTime(params, t);
    };
  };

  var derivativeCubicBezier = function derivativeCubicBezier(c1, c2) {
    return function (t) {
      var params = cubicBezierFactor(c1, c2);

      var newParams = _toConsumableArray$7(params.map(function (param, i) {
        return param * i;
      }).slice(1)).concat([0]);

      return multyTime(newParams, t);
    };
  }; // calculate cubic-bezier using Newton's method


  var configBezier = function configBezier() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var x1 = args[0],
        y1 = args[1],
        x2 = args[2],
        y2 = args[3];

    if (args.length === 1) {
      switch (args[0]) {
        case 'linear':
          x1 = 0.0;
          y1 = 0.0;
          x2 = 1.0;
          y2 = 1.0;
          break;

        case 'ease':
          x1 = 0.25;
          y1 = 0.1;
          x2 = 0.25;
          y2 = 1.0;
          break;

        case 'ease-in':
          x1 = 0.42;
          y1 = 0.0;
          x2 = 1.0;
          y2 = 1.0;
          break;

        case 'ease-out':
          x1 = 0.42;
          y1 = 0.0;
          x2 = 0.58;
          y2 = 1.0;
          break;

        case 'ease-in-out':
          x1 = 0.0;
          y1 = 0.0;
          x2 = 0.58;
          y2 = 1.0;
          break;

        default:
          {
            var easing = args[0].split('(');

            if (easing[0] === 'cubic-bezier' && easing[1].split(')')[0].split(',').length === 4) {
              var _easing$1$split$0$spl = easing[1].split(')')[0].split(',').map(function (x) {
                return parseFloat(x);
              });

              var _easing$1$split$0$spl2 = _slicedToArray$5(_easing$1$split$0$spl, 4);

              x1 = _easing$1$split$0$spl2[0];
              y1 = _easing$1$split$0$spl2[1];
              x2 = _easing$1$split$0$spl2[2];
              y2 = _easing$1$split$0$spl2[3];
            }
          }
      }
    }
    var curveX = cubicBezier(x1, x2);
    var curveY = cubicBezier(y1, y2);
    var derCurveX = derivativeCubicBezier(x1, x2);

    var rangeValue = function rangeValue(value) {
      if (value > 1) {
        return 1;
      } else if (value < 0) {
        return 0;
      }

      return value;
    };

    var bezier = function bezier(_t) {
      var t = _t > 1 ? 1 : _t;
      var x = t;

      for (var i = 0; i < 8; ++i) {
        var evalT = curveX(x) - t;
        var derVal = derCurveX(x);

        if (Math.abs(evalT - t) < ACCURACY || derVal < ACCURACY) {
          return curveY(x);
        }

        x = rangeValue(x - evalT / derVal);
      }

      return curveY(x);
    };

    bezier.isStepper = false;
    return bezier;
  };
  var configSpring = function configSpring() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _config$stiff = config.stiff,
        stiff = _config$stiff === void 0 ? 100 : _config$stiff,
        _config$damping = config.damping,
        damping = _config$damping === void 0 ? 8 : _config$damping,
        _config$dt = config.dt,
        dt = _config$dt === void 0 ? 17 : _config$dt;

    var stepper = function stepper(currX, destX, currV) {
      var FSpring = -(currX - destX) * stiff;
      var FDamping = currV * damping;
      var newV = currV + (FSpring - FDamping) * dt / 1000;
      var newX = currV * dt / 1000 + currX;

      if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
        return [destX, 0];
      }

      return [newX, newV];
    };

    stepper.isStepper = true;
    stepper.dt = dt;
    return stepper;
  };
  var configEasing = function configEasing() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var easing = args[0];

    if (typeof easing === 'string') {
      switch (easing) {
        case 'ease':
        case 'ease-in-out':
        case 'ease-out':
        case 'ease-in':
        case 'linear':
          return configBezier(easing);

        case 'spring':
          return configSpring();

        default:
          if (easing.split('(')[0] === 'cubic-bezier') {
            return configBezier(easing);
          }
      }
    }

    if (typeof easing === 'function') {
      return easing;
    }
    return null;
  };

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = _createBaseFor();

  var _baseFor = baseFor;

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  var _createBaseEach = createBaseEach;

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = _createBaseEach(_baseForOwn);

  var _baseEach = baseEach;

  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function baseFilter(collection, predicate) {
    var result = [];
    _baseEach(collection, function(value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  var _baseFilter = baseFilter;

  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   *
   * // Combining several predicates using `_.overEvery` or `_.overSome`.
   * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
   * // => objects for ['fred', 'barney']
   */
  function filter(collection, predicate) {
    var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
    return func(collection, _baseIteratee(predicate));
  }

  var filter_1 = filter;

  function _toConsumableArray$6(arr) { return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _nonIterableSpread$6(); }

  function _nonIterableSpread$6() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray$6(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles$6(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _objectSpread$o(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$q(target, key, source[key]); }); } return target; }

  function _defineProperty$q(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _slicedToArray$4(arr, i) { return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _nonIterableRest$4(); }

  function _nonIterableRest$4() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$4(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$4(arr) { if (Array.isArray(arr)) return arr; }

  var alpha = function alpha(begin, end, k) {
    return begin + (end - begin) * k;
  };

  var needContinue = function needContinue(_ref) {
    var from = _ref.from,
        to = _ref.to;
    return from !== to;
  };
  /*
   * @description: cal new from value and velocity in each stepper
   * @return: { [styleProperty]: { from, to, velocity } }
   */


  var calStepperVals = function calStepperVals(easing, preVals, steps) {
    var nextStepVals = mapObject(function (key, val) {
      if (needContinue(val)) {
        var _easing = easing(val.from, val.to, val.velocity),
            _easing2 = _slicedToArray$4(_easing, 2),
            newX = _easing2[0],
            newV = _easing2[1];

        return _objectSpread$o({}, val, {
          from: newX,
          velocity: newV
        });
      }

      return val;
    }, preVals);

    if (steps < 1) {
      return mapObject(function (key, val) {
        if (needContinue(val)) {
          return _objectSpread$o({}, val, {
            velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
            from: alpha(val.from, nextStepVals[key].from, steps)
          });
        }

        return val;
      }, preVals);
    }

    return calStepperVals(easing, nextStepVals, steps - 1);
  }; // configure update function


  var configUpdate = (function (from, to, easing, duration, render) {
    var interKeys = getIntersectionKeys(from, to);
    var timingStyle = interKeys.reduce(function (res, key) {
      return _objectSpread$o({}, res, _defineProperty$q({}, key, [from[key], to[key]]));
    }, {});
    var stepperStyle = interKeys.reduce(function (res, key) {
      return _objectSpread$o({}, res, _defineProperty$q({}, key, {
        from: from[key],
        velocity: 0,
        to: to[key]
      }));
    }, {});
    var cafId = -1;
    var preTime;
    var beginTime;

    var update = function update() {
      return null;
    };

    var getCurrStyle = function getCurrStyle() {
      return mapObject(function (key, val) {
        return val.from;
      }, stepperStyle);
    };

    var shouldStopAnimation = function shouldStopAnimation() {
      return !filter_1(stepperStyle, needContinue).length;
    }; // stepper timing function like spring


    var stepperUpdate = function stepperUpdate(now) {
      if (!preTime) {
        preTime = now;
      }

      var deltaTime = now - preTime;
      var steps = deltaTime / easing.dt;
      stepperStyle = calStepperVals(easing, stepperStyle, steps); // get union set and add compatible prefix

      render(_objectSpread$o({}, from, to, getCurrStyle()));
      preTime = now;

      if (!shouldStopAnimation()) {
        cafId = raf_1(update);
      }
    }; // t => val timing function like cubic-bezier


    var timingUpdate = function timingUpdate(now) {
      if (!beginTime) {
        beginTime = now;
      }

      var t = (now - beginTime) / duration;
      var currStyle = mapObject(function (key, val) {
        return alpha.apply(void 0, _toConsumableArray$6(val).concat([easing(t)]));
      }, timingStyle); // get union set and add compatible prefix

      render(_objectSpread$o({}, from, to, currStyle));

      if (t < 1) {
        cafId = raf_1(update);
      } else {
        var finalStyle = mapObject(function (key, val) {
          return alpha.apply(void 0, _toConsumableArray$6(val).concat([easing(1)]));
        }, timingStyle);
        render(_objectSpread$o({}, from, to, finalStyle));
      }
    };

    update = easing.isStepper ? stepperUpdate : timingUpdate; // return start animation method

    return function () {
      raf_1(update); // return stop animation method

      return function () {
        cancel(cafId);
      };
    };
  });

  function _typeof$k(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$k = function _typeof(obj) { return typeof obj; }; } else { _typeof$k = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$k(obj); }

  function _objectWithoutProperties$6(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$7(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$7(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _toConsumableArray$5(arr) { return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _nonIterableSpread$5(); }

  function _nonIterableSpread$5() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray$5(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles$5(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _objectSpread$n(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$p(target, key, source[key]); }); } return target; }

  function _defineProperty$p(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$l(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$l(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$l(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$l(Constructor.prototype, protoProps); if (staticProps) _defineProperties$l(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$k(self, call) { if (call && (_typeof$k(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$l(self); }

  function _getPrototypeOf$k(o) { _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$k(o); }

  function _inherits$k(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$k(subClass, superClass); }

  function _setPrototypeOf$k(o, p) { _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$k(o, p); }

  function _assertThisInitialized$l(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  var Animate =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$k(Animate, _PureComponent);

    function Animate(props, context) {
      var _this;

      _classCallCheck$l(this, Animate);

      _this = _possibleConstructorReturn$k(this, _getPrototypeOf$k(Animate).call(this, props, context));
      var _this$props = _this.props,
          isActive = _this$props.isActive,
          attributeName = _this$props.attributeName,
          from = _this$props.from,
          to = _this$props.to,
          steps = _this$props.steps,
          children = _this$props.children;
      _this.handleStyleChange = _this.handleStyleChange.bind(_assertThisInitialized$l(_assertThisInitialized$l(_this)));
      _this.changeStyle = _this.changeStyle.bind(_assertThisInitialized$l(_assertThisInitialized$l(_this)));

      if (!isActive) {
        _this.state = {
          style: {}
        }; // if children is a function and animation is not active, set style to 'to'

        if (typeof children === 'function') {
          _this.state = {
            style: to
          };
        }

        return _possibleConstructorReturn$k(_this);
      }

      if (steps && steps.length) {
        _this.state = {
          style: steps[0].style
        };
      } else if (from) {
        if (typeof children === 'function') {
          _this.state = {
            style: from
          };
          return _possibleConstructorReturn$k(_this);
        }

        _this.state = {
          style: attributeName ? _defineProperty$p({}, attributeName, from) : from
        };
      } else {
        _this.state = {
          style: {}
        };
      }

      return _this;
    }

    _createClass$l(Animate, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props2 = this.props,
            isActive = _this$props2.isActive,
            canBegin = _this$props2.canBegin;
        this.mounted = true;

        if (!isActive || !canBegin) {
          return;
        }

        this.runAnimation(this.props);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props3 = this.props,
            isActive = _this$props3.isActive,
            canBegin = _this$props3.canBegin,
            attributeName = _this$props3.attributeName,
            shouldReAnimate = _this$props3.shouldReAnimate;

        if (!canBegin) {
          return;
        }

        if (!isActive) {
          var newState = {
            style: attributeName ? _defineProperty$p({}, attributeName, this.props.to) : this.props.to
          };

          if (this.state && this.state.style) {
            if (attributeName && this.state.style[attributeName] !== this.props.to || !attributeName && this.state.style !== this.props.to) {
              // eslint-disable-next-line react/no-did-update-set-state
              this.setState(newState);
            }
          }

          return;
        }

        if (isEqual_1(prevProps.to, this.props.to) && prevProps.canBegin && prevProps.isActive) {
          return;
        }

        var isTriggered = !prevProps.canBegin || !prevProps.isActive;

        if (this.manager) {
          this.manager.stop();
        }

        if (this.stopJSAnimation) {
          this.stopJSAnimation();
        }

        var from = isTriggered || shouldReAnimate ? this.props.from : prevProps.to;

        if (this.state && this.state.style) {
          var _newState = {
            style: attributeName ? _defineProperty$p({}, attributeName, from) : from
          };

          if (attributeName && this.state.style[attributeName] !== from || !attributeName && this.state.style !== from) {
            // eslint-disable-next-line react/no-did-update-set-state
            this.setState(_newState);
          }
        }

        this.runAnimation(_objectSpread$n({}, this.props, {
          from: from,
          begin: 0
        }));
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.mounted = false;

        if (this.unSubscribe) {
          this.unSubscribe();
        }

        if (this.manager) {
          this.manager.stop();
          this.manager = null;
        }

        if (this.stopJSAnimation) {
          this.stopJSAnimation();
        }
      }
    }, {
      key: "runJSAnimation",
      value: function runJSAnimation(props) {
        var _this2 = this;

        var from = props.from,
            to = props.to,
            duration = props.duration,
            easing = props.easing,
            begin = props.begin,
            onAnimationEnd = props.onAnimationEnd,
            onAnimationStart = props.onAnimationStart;
        var startAnimation = configUpdate(from, to, configEasing(easing), duration, this.changeStyle);

        var finalStartAnimation = function finalStartAnimation() {
          _this2.stopJSAnimation = startAnimation();
        };

        this.manager.start([onAnimationStart, begin, finalStartAnimation, duration, onAnimationEnd]);
      }
    }, {
      key: "runStepAnimation",
      value: function runStepAnimation(props) {
        var _this3 = this;

        var steps = props.steps,
            begin = props.begin,
            onAnimationStart = props.onAnimationStart;
        var _steps$ = steps[0],
            initialStyle = _steps$.style,
            _steps$$duration = _steps$.duration,
            initialTime = _steps$$duration === void 0 ? 0 : _steps$$duration;

        var addStyle = function addStyle(sequence, nextItem, index) {
          if (index === 0) {
            return sequence;
          }

          var duration = nextItem.duration,
              _nextItem$easing = nextItem.easing,
              easing = _nextItem$easing === void 0 ? 'ease' : _nextItem$easing,
              style = nextItem.style,
              nextProperties = nextItem.properties,
              onAnimationEnd = nextItem.onAnimationEnd;
          var preItem = index > 0 ? steps[index - 1] : nextItem;
          var properties = nextProperties || Object.keys(style);

          if (typeof easing === 'function' || easing === 'spring') {
            return _toConsumableArray$5(sequence).concat([_this3.runJSAnimation.bind(_this3, {
              from: preItem.style,
              to: style,
              duration: duration,
              easing: easing
            }), duration]);
          }

          var transition = getTransitionVal(properties, duration, easing);

          var newStyle = _objectSpread$n({}, preItem.style, style, {
            transition: transition
          });

          return _toConsumableArray$5(sequence).concat([newStyle, duration, onAnimationEnd]).filter(identity$3);
        };

        return this.manager.start([onAnimationStart].concat(_toConsumableArray$5(steps.reduce(addStyle, [initialStyle, Math.max(initialTime, begin)])), [props.onAnimationEnd]));
      }
    }, {
      key: "runAnimation",
      value: function runAnimation(props) {
        if (!this.manager) {
          this.manager = createAnimateManager();
        }

        var begin = props.begin,
            duration = props.duration,
            attributeName = props.attributeName,
            propsTo = props.to,
            easing = props.easing,
            onAnimationStart = props.onAnimationStart,
            onAnimationEnd = props.onAnimationEnd,
            steps = props.steps,
            children = props.children;
        var manager = this.manager;
        this.unSubscribe = manager.subscribe(this.handleStyleChange);

        if (typeof easing === 'function' || typeof children === 'function' || easing === 'spring') {
          this.runJSAnimation(props);
          return;
        }

        if (steps.length > 1) {
          this.runStepAnimation(props);
          return;
        }

        var to = attributeName ? _defineProperty$p({}, attributeName, propsTo) : propsTo;
        var transition = getTransitionVal(Object.keys(to), duration, easing);
        manager.start([onAnimationStart, begin, _objectSpread$n({}, to, {
          transition: transition
        }), duration, onAnimationEnd]);
      }
    }, {
      key: "handleStyleChange",
      value: function handleStyleChange(style) {
        this.changeStyle(style);
      }
    }, {
      key: "changeStyle",
      value: function changeStyle(style) {
        if (this.mounted) {
          this.setState({
            style: style
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props4 = this.props,
            children = _this$props4.children;
            _this$props4.begin;
            _this$props4.duration;
            _this$props4.attributeName;
            _this$props4.easing;
            var isActive = _this$props4.isActive;
            _this$props4.steps;
            _this$props4.from;
            _this$props4.to;
            _this$props4.canBegin;
            _this$props4.onAnimationEnd;
            _this$props4.shouldReAnimate;
            _this$props4.onAnimationReStart;
            var others = _objectWithoutProperties$6(_this$props4, ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"]);

        var count = React.Children.count(children);
        var stateStyle = translateStyle(this.state.style);

        if (typeof children === 'function') {
          return children(stateStyle);
        }

        if (!isActive || count === 0) {
          return children;
        }

        var cloneContainer = function cloneContainer(container) {
          var _container$props = container.props,
              _container$props$styl = _container$props.style,
              style = _container$props$styl === void 0 ? {} : _container$props$styl,
              className = _container$props.className;
          var res = React.cloneElement(container, _objectSpread$n({}, others, {
            style: _objectSpread$n({}, style, stateStyle),
            className: className
          }));
          return res;
        };

        if (count === 1) {
          return cloneContainer(React.Children.only(children));
        }

        return React__default['default'].createElement("div", null, React.Children.map(children, function (child) {
          return cloneContainer(child);
        }));
      }
    }]);

    return Animate;
  }(React.PureComponent);

  Animate.displayName = 'Animate';
  Animate.propTypes = {
    from: propTypes$5.oneOfType([propTypes$5.object, propTypes$5.string]),
    to: propTypes$5.oneOfType([propTypes$5.object, propTypes$5.string]),
    attributeName: propTypes$5.string,
    // animation duration
    duration: propTypes$5.number,
    begin: propTypes$5.number,
    easing: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.func]),
    steps: propTypes$5.arrayOf(propTypes$5.shape({
      duration: propTypes$5.number.isRequired,
      style: propTypes$5.object.isRequired,
      easing: propTypes$5.oneOfType([propTypes$5.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']), propTypes$5.func]),
      // transition css properties(dash case), optional
      properties: propTypes$5.arrayOf('string'),
      onAnimationEnd: propTypes$5.func
    })),
    children: propTypes$5.oneOfType([propTypes$5.node, propTypes$5.func]),
    isActive: propTypes$5.bool,
    canBegin: propTypes$5.bool,
    onAnimationEnd: propTypes$5.func,
    // decide if it should reanimate with initial from style when props change
    shouldReAnimate: propTypes$5.bool,
    onAnimationStart: propTypes$5.func,
    onAnimationReStart: propTypes$5.func
  };
  Animate.defaultProps = {
    begin: 0,
    duration: 1000,
    from: '',
    to: '',
    attributeName: '',
    easing: 'ease',
    isActive: true,
    canBegin: true,
    steps: [],
    onAnimationEnd: function onAnimationEnd() {},
    onAnimationStart: function onAnimationStart() {}
  };

  ({
    appearOptions: propTypes$5.object,
    enterOptions: propTypes$5.object,
    leaveOptions: propTypes$5.object,
    children: propTypes$5.element
  });

  ({
    appear: propTypes$5.object,
    enter: propTypes$5.object,
    leave: propTypes$5.object,
    children: propTypes$5.oneOfType([propTypes$5.array, propTypes$5.element]),
    component: propTypes$5.any
  });

  /** Built-in value references. */
  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) ||
      !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;

    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  var _baseFlatten = baseFlatten;

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike_1(collection) ? Array(collection.length) : [];

    _baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  var _baseMap = baseMap;

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  var _baseSortBy = baseSortBy;

  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol_1(value);

      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol_1(other);

      if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
          (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
          (valIsNull && othIsDefined && othIsReflexive) ||
          (!valIsDefined && othIsReflexive) ||
          !valIsReflexive) {
        return 1;
      }
      if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
          (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
          (othIsNull && valIsDefined && valIsReflexive) ||
          (!othIsDefined && valIsReflexive) ||
          !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }

  var _compareAscending = compareAscending;

  /**
   * Used by `_.orderBy` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
   * specify an order of "desc" for descending or "asc" for ascending sort order
   * of corresponding values.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]|string[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = _compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  var _compareMultiple = compareMultiple;

  /**
   * The base implementation of `_.orderBy` without param guards.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
   * @param {string[]} orders The sort orders of `iteratees`.
   * @returns {Array} Returns the new sorted array.
   */
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = _arrayMap(iteratees, function(iteratee) {
        if (isArray_1(iteratee)) {
          return function(value) {
            return _baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          }
        }
        return iteratee;
      });
    } else {
      iteratees = [identity_1];
    }

    var index = -1;
    iteratees = _arrayMap(iteratees, _baseUnary(_baseIteratee));

    var result = _baseMap(collection, function(value, key, collection) {
      var criteria = _arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { 'criteria': criteria, 'index': ++index, 'value': value };
    });

    return _baseSortBy(result, function(object, other) {
      return _compareMultiple(object, other, orders);
    });
  }

  var _baseOrderBy = baseOrderBy;

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike_1(object) && _isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq_1(object[index], value);
    }
    return false;
  }

  var _isIterateeCall = isIterateeCall;

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection thru each iteratee. This method
   * performs a stable sort, that is, it preserves the original sort order of
   * equal elements. The iteratees are invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {...(Function|Function[])} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 30 },
   *   { 'user': 'barney', 'age': 34 }
   * ];
   *
   * _.sortBy(users, [function(o) { return o.user; }]);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
   *
   * _.sortBy(users, ['user', 'age']);
   * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
   */
  var sortBy = _baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
  });

  var sortBy_1 = sortBy;

  function _typeof$j(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$j = function _typeof(obj) { return typeof obj; }; } else { _typeof$j = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$j(obj); }

  function _slicedToArray$3(arr, i) { return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _nonIterableRest$3(); }

  function _nonIterableRest$3() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$3(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$3(arr) { if (Array.isArray(arr)) return arr; }

  function ownKeys$m(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$m(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$m(source, true).forEach(function (key) { _defineProperty$o(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$m(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$o(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$k(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$k(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$k(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$k(Constructor.prototype, protoProps); if (staticProps) _defineProperties$k(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$j(self, call) { if (call && (_typeof$j(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$k(self); }

  function _assertThisInitialized$k(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$j(o) { _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$j(o); }

  function _inherits$j(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$j(subClass, superClass); }

  function _setPrototypeOf$j(o, p) { _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$j(o, p); }

  var defaultFormatter = function defaultFormatter(value) {
    return isArray_1(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(' ~ ') : value;
  };

  var DefaultTooltipContent =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$j(DefaultTooltipContent, _PureComponent);

    function DefaultTooltipContent() {
      _classCallCheck$k(this, DefaultTooltipContent);

      return _possibleConstructorReturn$j(this, _getPrototypeOf$j(DefaultTooltipContent).apply(this, arguments));
    }

    _createClass$k(DefaultTooltipContent, [{
      key: "renderContent",
      value: function renderContent() {
        var _this$props = this.props,
            payload = _this$props.payload,
            separator = _this$props.separator,
            formatter = _this$props.formatter,
            itemStyle = _this$props.itemStyle,
            itemSorter = _this$props.itemSorter;

        if (payload && payload.length) {
          var listStyle = {
            padding: 0,
            margin: 0
          };
          var items = (itemSorter ? sortBy_1(payload, itemSorter) : payload).map(function (entry, i) {
            if (entry.type === 'none') {
              return null;
            }

            var finalItemStyle = _objectSpread$m({
              display: 'block',
              paddingTop: 4,
              paddingBottom: 4,
              color: entry.color || '#000'
            }, itemStyle);

            var finalFormatter = entry.formatter || formatter || defaultFormatter;
            var name = entry.name,
                value = entry.value;

            if (finalFormatter) {
              var formatted = finalFormatter(value, name, entry, i);

              if (Array.isArray(formatted)) {
                var _formatted = _slicedToArray$3(formatted, 2);

                value = _formatted[0];
                name = _formatted[1];
              } else {
                value = formatted;
              }
            }

            return (// eslint-disable-next-line react/no-array-index-key
              React__default['default'].createElement("li", {
                className: "recharts-tooltip-item",
                key: "tooltip-item-".concat(i),
                style: finalItemStyle
              }, isNumOrStr(name) ? React__default['default'].createElement("span", {
                className: "recharts-tooltip-item-name"
              }, name) : null, isNumOrStr(name) ? React__default['default'].createElement("span", {
                className: "recharts-tooltip-item-separator"
              }, separator) : null, React__default['default'].createElement("span", {
                className: "recharts-tooltip-item-value"
              }, value), React__default['default'].createElement("span", {
                className: "recharts-tooltip-item-unit"
              }, entry.unit || ''))
            );
          });
          return React__default['default'].createElement("ul", {
            className: "recharts-tooltip-item-list",
            style: listStyle
          }, items);
        }

        return null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            wrapperClassName = _this$props2.wrapperClassName,
            contentStyle = _this$props2.contentStyle,
            labelClassName = _this$props2.labelClassName,
            labelStyle = _this$props2.labelStyle,
            label = _this$props2.label,
            labelFormatter = _this$props2.labelFormatter;

        var finalStyle = _objectSpread$m({
          margin: 0,
          padding: 10,
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          whiteSpace: 'nowrap'
        }, contentStyle);

        var finalLabelStyle = _objectSpread$m({
          margin: 0
        }, labelStyle);

        var hasLabel = isNumOrStr(label);
        var finalLabel = hasLabel ? label : '';
        var wrapperCN = classnames('recharts-default-tooltip', wrapperClassName);
        var labelCN = classnames('recharts-tooltip-label', labelClassName);

        if (hasLabel && labelFormatter) {
          finalLabel = labelFormatter(label);
        }

        return React__default['default'].createElement("div", {
          className: wrapperCN,
          style: finalStyle
        }, React__default['default'].createElement("p", {
          className: labelCN,
          style: finalLabelStyle
        }, finalLabel), this.renderContent());
      }
    }]);

    return DefaultTooltipContent;
  }(React.PureComponent);

  DefaultTooltipContent.displayName = 'DefaultTooltipContent';
  DefaultTooltipContent.propTypes = {
    separator: propTypes$5.string,
    wrapperClassName: propTypes$5.string,
    labelClassName: propTypes$5.string,
    formatter: propTypes$5.func,
    contentStyle: propTypes$5.object,
    itemStyle: propTypes$5.object,
    labelStyle: propTypes$5.object,
    labelFormatter: propTypes$5.func,
    label: propTypes$5.any,
    payload: propTypes$5.arrayOf(propTypes$5.shape({
      name: propTypes$5.any,
      value: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string, propTypes$5.array]),
      unit: propTypes$5.any
    })),
    itemSorter: propTypes$5.func
  };
  DefaultTooltipContent.defaultProps = {
    separator: ' : ',
    contentStyle: {},
    itemStyle: {},
    labelStyle: {}
  };

  function _typeof$i(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$i = function _typeof(obj) { return typeof obj; }; } else { _typeof$i = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$i(obj); }

  function ownKeys$l(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$l(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$l(source, true).forEach(function (key) { _defineProperty$n(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$l(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$n(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$j(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$j(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$j(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$j(Constructor.prototype, protoProps); if (staticProps) _defineProperties$j(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$i(self, call) { if (call && (_typeof$i(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$j(self); }

  function _assertThisInitialized$j(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$i(o) { _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$i(o); }

  function _inherits$i(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$i(subClass, superClass); }

  function _setPrototypeOf$i(o, p) { _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$i(o, p); }
  var CLS_PREFIX = 'recharts-tooltip-wrapper';
  var EPS$1 = 1;

  var defaultUniqBy = function defaultUniqBy(entry) {
    return entry.dataKey;
  };

  var getUniqPaylod = function getUniqPaylod(option, payload) {
    if (option === true) {
      return uniqBy_1(payload, defaultUniqBy);
    }

    if (isFunction_1(option)) {
      return uniqBy_1(payload, option);
    }

    return payload;
  };

  var propTypes$2 = {
    allowEscapeViewBox: propTypes$5.shape({
      x: propTypes$5["boolean"],
      y: propTypes$5["boolean"]
    }),
    content: propTypes$5.oneOfType([propTypes$5.element, propTypes$5.func]),
    viewBox: propTypes$5.shape({
      x: propTypes$5.number,
      y: propTypes$5.number,
      width: propTypes$5.number,
      height: propTypes$5.number
    }),
    active: propTypes$5.bool,
    separator: propTypes$5.string,
    formatter: propTypes$5.func,
    offset: propTypes$5.number,
    itemStyle: propTypes$5.object,
    labelStyle: propTypes$5.object,
    wrapperStyle: propTypes$5.object,
    contentStyle: propTypes$5.object,
    cursor: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.element, propTypes$5.object]),
    coordinate: propTypes$5.shape({
      x: propTypes$5.number,
      y: propTypes$5.number
    }),
    position: propTypes$5.shape({
      x: propTypes$5.number,
      y: propTypes$5.number
    }),
    label: propTypes$5.any,
    payload: propTypes$5.arrayOf(propTypes$5.shape({
      name: propTypes$5.any,
      value: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string, propTypes$5.array]),
      unit: propTypes$5.any,
      type: propTypes$5.oneOf(TOOLTIP_TYPES)
    })),
    paylodUniqBy: propTypes$5.oneOfType([propTypes$5.func, propTypes$5.bool]),
    isAnimationActive: propTypes$5.bool,
    animationDuration: propTypes$5.number,
    animationEasing: propTypes$5.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']),
    itemSorter: propTypes$5.func,
    filterNull: propTypes$5.bool,
    useTranslate3d: propTypes$5.bool
  };
  var defaultProps$3 = {
    active: false,
    allowEscapeViewBox: {
      x: false,
      y: false
    },
    offset: 10,
    viewBox: {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    },
    coordinate: {
      x: 0,
      y: 0
    },
    cursorStyle: {},
    separator: ' : ',
    wrapperStyle: {},
    contentStyle: {},
    itemStyle: {},
    labelStyle: {},
    cursor: true,
    isAnimationActive: !isSsr(),
    animationEasing: 'ease',
    animationDuration: 400,
    filterNull: true,
    useTranslate3d: false
  };

  var renderContent = function renderContent(content, props) {
    if (React__default['default'].isValidElement(content)) {
      return React__default['default'].cloneElement(content, props);
    }

    if (isFunction_1(content)) {
      return content(props);
    }

    return React__default['default'].createElement(DefaultTooltipContent, props);
  };

  var Tooltip$1 =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$i(Tooltip, _PureComponent);

    function Tooltip() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck$j(this, Tooltip);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn$i(this, (_getPrototypeOf2 = _getPrototypeOf$i(Tooltip)).call.apply(_getPrototypeOf2, [this].concat(args)));
      _this.state = {
        boxWidth: -1,
        boxHeight: -1
      };

      _this.getTranslate = function (_ref) {
        var key = _ref.key,
            tooltipDimension = _ref.tooltipDimension,
            viewBoxDimension = _ref.viewBoxDimension;
        var _this$props = _this.props,
            allowEscapeViewBox = _this$props.allowEscapeViewBox,
            coordinate = _this$props.coordinate,
            offset = _this$props.offset,
            position = _this$props.position,
            viewBox = _this$props.viewBox;

        if (position && isNumber(position[key])) {
          return position[key];
        }

        var restricted = coordinate[key] - tooltipDimension - offset;
        var unrestricted = coordinate[key] + offset;

        if (allowEscapeViewBox[key]) {
          return unrestricted;
        }

        var tooltipBoundary = coordinate[key] + tooltipDimension + offset;
        var viewBoxBoundary = viewBox[key] + viewBoxDimension;

        if (tooltipBoundary > viewBoxBoundary) {
          return Math.max(restricted, viewBox[key]);
        }

        return Math.max(unrestricted, viewBox[key]);
      };

      return _this;
    }

    _createClass$j(Tooltip, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateBBox();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.updateBBox();
      }
    }, {
      key: "updateBBox",
      value: function updateBBox() {
        var _this$state = this.state,
            boxWidth = _this$state.boxWidth,
            boxHeight = _this$state.boxHeight;

        if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
          var box = this.wrapperNode.getBoundingClientRect();

          if (Math.abs(box.width - boxWidth) > EPS$1 || Math.abs(box.height - boxHeight) > EPS$1) {
            this.setState({
              boxWidth: box.width,
              boxHeight: box.height
            });
          }
        } else if (boxWidth !== -1 || boxHeight !== -1) {
          this.setState({
            boxWidth: -1,
            boxHeight: -1
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames,
            _this2 = this;

        var _this$props2 = this.props,
            payload = _this$props2.payload,
            isAnimationActive = _this$props2.isAnimationActive,
            animationDuration = _this$props2.animationDuration,
            animationEasing = _this$props2.animationEasing,
            filterNull = _this$props2.filterNull,
            paylodUniqBy = _this$props2.paylodUniqBy;
        var finalPayload = getUniqPaylod(paylodUniqBy, filterNull && payload && payload.length ? payload.filter(function (entry) {
          return !isNil_1(entry.value);
        }) : payload);
        var hasPayload = finalPayload && finalPayload.length;
        var _this$props3 = this.props,
            content = _this$props3.content,
            viewBox = _this$props3.viewBox,
            coordinate = _this$props3.coordinate,
            position = _this$props3.position,
            active = _this$props3.active,
            wrapperStyle = _this$props3.wrapperStyle;

        var outerStyle = _objectSpread$l({
          pointerEvents: 'none',
          visibility: active && hasPayload ? 'visible' : 'hidden',
          position: 'absolute',
          top: 0
        }, wrapperStyle);

        var translateX, translateY;

        if (position && isNumber(position.x) && isNumber(position.y)) {
          translateX = position.x;
          translateY = position.y;
        } else {
          var _this$state2 = this.state,
              boxWidth = _this$state2.boxWidth,
              boxHeight = _this$state2.boxHeight;

          if (boxWidth > 0 && boxHeight > 0 && coordinate) {
            translateX = this.getTranslate({
              key: 'x',
              tooltipDimension: boxWidth,
              viewBoxDimension: viewBox.width
            });
            translateY = this.getTranslate({
              key: 'y',
              tooltipDimension: boxHeight,
              viewBoxDimension: viewBox.height
            });
          } else {
            outerStyle.visibility = 'hidden';
          }
        }

        outerStyle = _objectSpread$l({}, translateStyle({
          transform: this.props.useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
        }), {}, outerStyle);

        if (isAnimationActive && active) {
          outerStyle = _objectSpread$l({}, translateStyle({
            transition: "transform ".concat(animationDuration, "ms ").concat(animationEasing)
          }), {}, outerStyle);
        }

        var cls = classnames(CLS_PREFIX, (_classNames = {}, _defineProperty$n(_classNames, "".concat(CLS_PREFIX, "-right"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x), _defineProperty$n(_classNames, "".concat(CLS_PREFIX, "-left"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x), _defineProperty$n(_classNames, "".concat(CLS_PREFIX, "-bottom"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y), _defineProperty$n(_classNames, "".concat(CLS_PREFIX, "-top"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y), _classNames));
        return React__default['default'].createElement("div", {
          className: cls,
          style: outerStyle,
          ref: function ref(node) {
            _this2.wrapperNode = node;
          }
        }, renderContent(content, _objectSpread$l({}, this.props, {
          payload: finalPayload
        })));
      }
    }]);

    return Tooltip;
  }(React.PureComponent);

  Tooltip$1.displayName = 'Tooltip';
  Tooltip$1.propTypes = propTypes$2;
  Tooltip$1.defaultProps = defaultProps$3;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now$2 = function() {
    return _root.Date.now();
  };

  var now_1 = now$2;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  var _trimmedEndIndex = trimmedEndIndex;

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  var _baseTrim = baseTrim;

  /** Used as references for various `Number` constants. */
  var NAN$2 = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary$2 = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal$2 = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt$2 = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber$2(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol_1(value)) {
      return NAN$2;
    }
    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = _baseTrim(value);
    var isBinary = reIsBinary$2.test(value);
    return (isBinary || reIsOctal$2.test(value))
      ? freeParseInt$2(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex$2.test(value) ? NAN$2 : +value);
  }

  var toNumber_1 = toNumber$2;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$3 = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$4 = Math.max,
      nativeMin$2 = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce$3(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$3);
    }
    wait = toNumber_1(wait) || 0;
    if (isObject_1(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax$4(toNumber_1(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin$2(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now_1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now_1());
    }

    function debounced() {
      var time = now_1(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  var debounce_1 = debounce$3;

  /**
   * A collection of shims that provide minimal functionality of the ES6 collections.
   *
   * These implementations are not meant to be used outside of the ResizeObserver
   * modules as they cover only a limited range of use cases.
   */
  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = (function () {
      if (typeof Map !== 'undefined') {
          return Map;
      }
      /**
       * Returns index in provided array that matches the specified key.
       *
       * @param {Array<Array>} arr
       * @param {*} key
       * @returns {number}
       */
      function getIndex(arr, key) {
          var result = -1;
          arr.some(function (entry, index) {
              if (entry[0] === key) {
                  result = index;
                  return true;
              }
              return false;
          });
          return result;
      }
      return /** @class */ (function () {
          function class_1() {
              this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function () {
                  return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
          });
          /**
           * @param {*} key
           * @returns {*}
           */
          class_1.prototype.get = function (key) {
              var index = getIndex(this.__entries__, key);
              var entry = this.__entries__[index];
              return entry && entry[1];
          };
          /**
           * @param {*} key
           * @param {*} value
           * @returns {void}
           */
          class_1.prototype.set = function (key, value) {
              var index = getIndex(this.__entries__, key);
              if (~index) {
                  this.__entries__[index][1] = value;
              }
              else {
                  this.__entries__.push([key, value]);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.delete = function (key) {
              var entries = this.__entries__;
              var index = getIndex(entries, key);
              if (~index) {
                  entries.splice(index, 1);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.has = function (key) {
              return !!~getIndex(this.__entries__, key);
          };
          /**
           * @returns {void}
           */
          class_1.prototype.clear = function () {
              this.__entries__.splice(0);
          };
          /**
           * @param {Function} callback
           * @param {*} [ctx=null]
           * @returns {void}
           */
          class_1.prototype.forEach = function (callback, ctx) {
              if (ctx === void 0) { ctx = null; }
              for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                  var entry = _a[_i];
                  callback.call(ctx, entry[1], entry[0]);
              }
          };
          return class_1;
      }());
  })();

  /**
   * Detects whether window and document objects are available in current environment.
   */
  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

  // Returns global object of a current environment.
  var global$1 = (function () {
      if (typeof global !== 'undefined' && global.Math === Math) {
          return global;
      }
      if (typeof self !== 'undefined' && self.Math === Math) {
          return self;
      }
      if (typeof window !== 'undefined' && window.Math === Math) {
          return window;
      }
      // eslint-disable-next-line no-new-func
      return Function('return this')();
  })();

  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */
  var requestAnimationFrame$1 = (function () {
      if (typeof requestAnimationFrame === 'function') {
          // It's required to use a bounded function because IE sometimes throws
          // an "Invalid calling object" error if rAF is invoked without the global
          // object on the left hand side.
          return requestAnimationFrame.bind(global$1);
      }
      return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
  })();

  // Defines minimum timeout before adding a trailing call.
  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */
  function throttle$2 (callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      /**
       * Invokes the original callback function and schedules new invocation if
       * the "proxy" was called during current request.
       *
       * @returns {void}
       */
      function resolvePending() {
          if (leadingCall) {
              leadingCall = false;
              callback();
          }
          if (trailingCall) {
              proxy();
          }
      }
      /**
       * Callback invoked after the specified delay. It will further postpone
       * invocation of the original function delegating it to the
       * requestAnimationFrame.
       *
       * @returns {void}
       */
      function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
      }
      /**
       * Schedules invocation of the original function.
       *
       * @returns {void}
       */
      function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
              // Reject immediately following calls.
              if (timeStamp - lastCallTime < trailingTimeout) {
                  return;
              }
              // Schedule new call to be in invoked when the pending one is resolved.
              // This is important for "transitions" which never actually start
              // immediately so there is a chance that we might miss one if change
              // happens amids the pending invocation.
              trailingCall = true;
          }
          else {
              leadingCall = true;
              trailingCall = false;
              setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
      }
      return proxy;
  }

  // Minimum delay before invoking the update of observers.
  var REFRESH_DELAY = 20;
  // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.
  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
  // Check if MutationObserver is available.
  var mutationObserverSupported = typeof MutationObserver !== 'undefined';
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */
  var ResizeObserverController = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserverController.
       *
       * @private
       */
      function ResizeObserverController() {
          /**
           * Indicates whether DOM listeners have been added.
           *
           * @private {boolean}
           */
          this.connected_ = false;
          /**
           * Tells that controller has subscribed for Mutation Events.
           *
           * @private {boolean}
           */
          this.mutationEventsAdded_ = false;
          /**
           * Keeps reference to the instance of MutationObserver.
           *
           * @private {MutationObserver}
           */
          this.mutationsObserver_ = null;
          /**
           * A list of connected observers.
           *
           * @private {Array<ResizeObserverSPI>}
           */
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle$2(this.refresh.bind(this), REFRESH_DELAY);
      }
      /**
       * Adds observer to observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be added.
       * @returns {void}
       */
      ResizeObserverController.prototype.addObserver = function (observer) {
          if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
          }
          // Add listeners if they haven't been added yet.
          if (!this.connected_) {
              this.connect_();
          }
      };
      /**
       * Removes observer from observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be removed.
       * @returns {void}
       */
      ResizeObserverController.prototype.removeObserver = function (observer) {
          var observers = this.observers_;
          var index = observers.indexOf(observer);
          // Remove observer if it's present in registry.
          if (~index) {
              observers.splice(index, 1);
          }
          // Remove listeners if controller has no connected observers.
          if (!observers.length && this.connected_) {
              this.disconnect_();
          }
      };
      /**
       * Invokes the update of observers. It will continue running updates insofar
       * it detects changes.
       *
       * @returns {void}
       */
      ResizeObserverController.prototype.refresh = function () {
          var changesDetected = this.updateObservers_();
          // Continue running updates if changes have been detected as there might
          // be future ones caused by CSS transitions.
          if (changesDetected) {
              this.refresh();
          }
      };
      /**
       * Updates every observer from observers list and notifies them of queued
       * entries.
       *
       * @private
       * @returns {boolean} Returns "true" if any observer has detected changes in
       *      dimensions of it's elements.
       */
      ResizeObserverController.prototype.updateObservers_ = function () {
          // Collect observers that have active observations.
          var activeObservers = this.observers_.filter(function (observer) {
              return observer.gatherActive(), observer.hasActive();
          });
          // Deliver notifications in a separate cycle in order to avoid any
          // collisions between observers, e.g. when multiple instances of
          // ResizeObserver are tracking the same element and the callback of one
          // of them changes content dimensions of the observed target. Sometimes
          // this may result in notifications being blocked for the rest of observers.
          activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
          return activeObservers.length > 0;
      };
      /**
       * Initializes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.connect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already added.
          if (!isBrowser$1 || this.connected_) {
              return;
          }
          // Subscription to the "Transitionend" event is used as a workaround for
          // delayed transitions. This way it's possible to capture at least the
          // final state of an element.
          document.addEventListener('transitionend', this.onTransitionEnd_);
          window.addEventListener('resize', this.refresh);
          if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                  attributes: true,
                  childList: true,
                  characterData: true,
                  subtree: true
              });
          }
          else {
              document.addEventListener('DOMSubtreeModified', this.refresh);
              this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
      };
      /**
       * Removes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.disconnect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already removed.
          if (!isBrowser$1 || !this.connected_) {
              return;
          }
          document.removeEventListener('transitionend', this.onTransitionEnd_);
          window.removeEventListener('resize', this.refresh);
          if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
              document.removeEventListener('DOMSubtreeModified', this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
      };
      /**
       * "Transitionend" event handler.
       *
       * @private
       * @param {TransitionEvent} event
       * @returns {void}
       */
      ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
          var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
          // Detect whether transition may affect dimensions of an element.
          var isReflowProperty = transitionKeys.some(function (key) {
              return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
              this.refresh();
          }
      };
      /**
       * Returns instance of the ResizeObserverController.
       *
       * @returns {ResizeObserverController}
       */
      ResizeObserverController.getInstance = function () {
          if (!this.instance_) {
              this.instance_ = new ResizeObserverController();
          }
          return this.instance_;
      };
      /**
       * Holds reference to the controller's instance.
       *
       * @private {ResizeObserverController}
       */
      ResizeObserverController.instance_ = null;
      return ResizeObserverController;
  }());

  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */
  var defineConfigurable = (function (target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
          var key = _a[_i];
          Object.defineProperty(target, key, {
              value: props[key],
              enumerable: false,
              writable: false,
              configurable: true
          });
      }
      return target;
  });

  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */
  var getWindowOf = (function (target) {
      // Assume that the element is an instance of Node, which means that it
      // has the "ownerDocument" property from which we can retrieve a
      // corresponding global object.
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      // Return the local global object if it's not possible extract one from
      // provided element.
      return ownerGlobal || global$1;
  });

  // Placeholder of an empty content rectangle.
  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */
  function toFloat(value) {
      return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */
  function getBordersSize$1(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function (size, position) {
          var value = styles['border-' + position + '-width'];
          return size + toFloat(value);
      }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */
  function getPaddings(styles) {
      var positions = ['top', 'right', 'bottom', 'left'];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles['padding-' + position];
          paddings[position] = toFloat(value);
      }
      return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */
  function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */
  function getHTMLElementContentRect(target) {
      // Client width & height properties can't be
      // used exclusively as they provide rounded values.
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      // By this condition we can catch all non-replaced inline, hidden and
      // detached elements. Though elements with width & height properties less
      // than 0.5 will be discarded as well.
      //
      // Without it we would need to implement separate methods for each of
      // those cases and it's not possible to perform a precise and performance
      // effective test for hidden elements. E.g. even jQuery's ':visible' filter
      // gives wrong results for elements with width & height less than 0.5.
      if (!clientWidth && !clientHeight) {
          return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      // Computed styles of width & height are being used because they are the
      // only dimensions available to JS that contain non-rounded values. It could
      // be possible to utilize the getBoundingClientRect if only it's data wasn't
      // affected by CSS transformations let alone paddings, borders and scroll bars.
      var width = toFloat(styles.width), height = toFloat(styles.height);
      // Width & height include paddings and borders when the 'border-box' box
      // model is applied (except for IE).
      if (styles.boxSizing === 'border-box') {
          // Following conditions are required to handle Internet Explorer which
          // doesn't include paddings and borders to computed CSS dimensions.
          //
          // We can say that if CSS dimensions + paddings are equal to the "client"
          // properties then it's either IE, and thus we don't need to subtract
          // anything, or an element merely doesn't have paddings/borders styles.
          if (Math.round(width + horizPad) !== clientWidth) {
              width -= getBordersSize$1(styles, 'left', 'right') + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
              height -= getBordersSize$1(styles, 'top', 'bottom') + vertPad;
          }
      }
      // Following steps can't be applied to the document's root element as its
      // client[Width/Height] properties represent viewport area of the window.
      // Besides, it's as well not necessary as the <html> itself neither has
      // rendered scroll bars nor it can be clipped.
      if (!isDocumentElement(target)) {
          // In some browsers (only in Firefox, actually) CSS width & height
          // include scroll bars size which can be removed at this step as scroll
          // bars are the only difference between rounded dimensions + paddings
          // and "client" properties, though that is not always true in Chrome.
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          // Chrome has a rather weird rounding of "client" properties.
          // E.g. for an element with content width of 314.2px it sometimes gives
          // the client width of 315px and for the width of 314.7px it may give
          // 314px. And it doesn't happen all the time. So just ignore this delta
          // as a non-relevant.
          if (Math.abs(vertScrollbar) !== 1) {
              width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
              height -= horizScrollbar;
          }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  var isSVGGraphicsElement = (function () {
      // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
      // interface.
      if (typeof SVGGraphicsElement !== 'undefined') {
          return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
      }
      // If it's so, then check that element is at least an instance of the
      // SVGElement and that it has the "getBBox" method.
      // eslint-disable-next-line no-extra-parens
      return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
          typeof target.getBBox === 'function'); };
  })();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */
  function getContentRect(target) {
      if (!isBrowser$1) {
          return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */
  function createReadOnlyRect(_a) {
      var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
      // If DOMRectReadOnly is available use it as a prototype for the rectangle.
      var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      // Rectangle's properties are not writable and non-enumerable.
      defineConfigurable(rect, {
          x: x, y: y, width: width, height: height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
      });
      return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */
  function createRectInit(x, y, width, height) {
      return { x: x, y: y, width: width, height: height };
  }

  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */
  var ResizeObservation = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObservation.
       *
       * @param {Element} target - Element to be observed.
       */
      function ResizeObservation(target) {
          /**
           * Broadcasted width of content rectangle.
           *
           * @type {number}
           */
          this.broadcastWidth = 0;
          /**
           * Broadcasted height of content rectangle.
           *
           * @type {number}
           */
          this.broadcastHeight = 0;
          /**
           * Reference to the last observed content rectangle.
           *
           * @private {DOMRectInit}
           */
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
      }
      /**
       * Updates content rectangle and tells whether it's width or height properties
       * have changed since the last broadcast.
       *
       * @returns {boolean}
       */
      ResizeObservation.prototype.isActive = function () {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return (rect.width !== this.broadcastWidth ||
              rect.height !== this.broadcastHeight);
      };
      /**
       * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
       * from the corresponding properties of the last observed content rectangle.
       *
       * @returns {DOMRectInit} Last observed content rectangle.
       */
      ResizeObservation.prototype.broadcastRect = function () {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
      };
      return ResizeObservation;
  }());

  var ResizeObserverEntry = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObserverEntry.
       *
       * @param {Element} target - Element that is being observed.
       * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
       */
      function ResizeObserverEntry(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          // According to the specification following properties are not writable
          // and are also not enumerable in the native implementation.
          //
          // Property accessors are not being used as they'd require to define a
          // private WeakMap storage which may cause memory leaks in browsers that
          // don't support this type of collections.
          defineConfigurable(this, { target: target, contentRect: contentRect });
      }
      return ResizeObserverEntry;
  }());

  var ResizeObserverSPI = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback function that is invoked
       *      when one of the observed elements changes it's content dimensions.
       * @param {ResizeObserverController} controller - Controller instance which
       *      is responsible for the updates of observer.
       * @param {ResizeObserver} callbackCtx - Reference to the public
       *      ResizeObserver instance which will be passed to callback function.
       */
      function ResizeObserverSPI(callback, controller, callbackCtx) {
          /**
           * Collection of resize observations that have detected changes in dimensions
           * of elements.
           *
           * @private {Array<ResizeObservation>}
           */
          this.activeObservations_ = [];
          /**
           * Registry of the ResizeObservation instances.
           *
           * @private {Map<Element, ResizeObservation>}
           */
          this.observations_ = new MapShim();
          if (typeof callback !== 'function') {
              throw new TypeError('The callback provided as parameter 1 is not a function.');
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
      }
      /**
       * Starts observing provided element.
       *
       * @param {Element} target - Element to be observed.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.observe = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is already being observed.
          if (observations.has(target)) {
              return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          // Force the update of observations.
          this.controller_.refresh();
      };
      /**
       * Stops observing provided element.
       *
       * @param {Element} target - Element to stop observing.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.unobserve = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is not being observed.
          if (!observations.has(target)) {
              return;
          }
          observations.delete(target);
          if (!observations.size) {
              this.controller_.removeObserver(this);
          }
      };
      /**
       * Stops observing all elements.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.disconnect = function () {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
      };
      /**
       * Collects observation instances the associated element of which has changed
       * it's content rectangle.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.gatherActive = function () {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function (observation) {
              if (observation.isActive()) {
                  _this.activeObservations_.push(observation);
              }
          });
      };
      /**
       * Invokes initial callback function with a list of ResizeObserverEntry
       * instances collected from active resize observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.broadcastActive = function () {
          // Do nothing if observer doesn't have active observations.
          if (!this.hasActive()) {
              return;
          }
          var ctx = this.callbackCtx_;
          // Create ResizeObserverEntry instance for every active observation.
          var entries = this.activeObservations_.map(function (observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
      };
      /**
       * Clears the collection of active observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.clearActive = function () {
          this.activeObservations_.splice(0);
      };
      /**
       * Tells whether observer has active observations.
       *
       * @returns {boolean}
       */
      ResizeObserverSPI.prototype.hasActive = function () {
          return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI;
  }());

  // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.
  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */
  var ResizeObserver = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback that is invoked when
       *      dimensions of the observed elements change.
       */
      function ResizeObserver(callback) {
          if (!(this instanceof ResizeObserver)) {
              throw new TypeError('Cannot call a class as a function.');
          }
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
      }
      return ResizeObserver;
  }());
  // Expose public methods of ResizeObserver.
  [
      'observe',
      'unobserve',
      'disconnect'
  ].forEach(function (method) {
      ResizeObserver.prototype[method] = function () {
          var _a;
          return (_a = observers.get(this))[method].apply(_a, arguments);
      };
  });

  var index = (function () {
      // Export existing implementation if available.
      if (typeof global$1.ResizeObserver !== 'undefined') {
          return global$1.ResizeObserver;
      }
      return ResizeObserver;
  })();

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT$2 = 'Expected a function';

  /** Used as references for various `Number` constants. */
  var NAN$1 = 0 / 0;

  /** `Object#toString` result references. */
  var symbolTag$1 = '[object Symbol]';

  /** Used to match leading and trailing whitespace. */
  var reTrim$1 = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary$1 = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal$1 = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt$1 = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString$1 = objectProto$2.toString;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$3 = Math.max,
      nativeMin$1 = Math.min;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now$1 = function() {
    return root$1.Date.now();
  };

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce$2(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$2);
    }
    wait = toNumber$1(wait) || 0;
    if (isObject$1(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax$3(toNumber$1(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          result = wait - timeSinceLastCall;

      return maxing ? nativeMin$1(result, maxWait - timeSinceLastInvoke) : result;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now$1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now$1());
    }

    function debounced() {
      var time = now$1(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$1(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike$1(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$1(value) {
    return typeof value == 'symbol' ||
      (isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1);
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber$1(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol$1(value)) {
      return NAN$1;
    }
    if (isObject$1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject$1(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim$1, '');
    var isBinary = reIsBinary$1.test(value);
    return (isBinary || reIsOctal$1.test(value))
      ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex$1.test(value) ? NAN$1 : +value);
  }

  var lodash_debounce = debounce$2;

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto$1.toString;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$2 = Math.max,
      nativeMin = Math.min;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce$1(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax$2(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          result = wait - timeSinceLastCall;

      return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle$1(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce$1(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag);
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  var lodash_throttle = throttle$1;

  var ResizeDetector_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



  var _react2 = _interopRequireDefault(React__default['default']);



  var _propTypes2 = _interopRequireDefault(propTypes$5);



  var _resizeObserverPolyfill2 = _interopRequireDefault(index);



  var _lodash2 = _interopRequireDefault(lodash_debounce);



  var _lodash4 = _interopRequireDefault(lodash_throttle);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var listMode = { debounce: _lodash2.default, throttle: _lodash4.default };

  var styles = {
    position: 'absolute',
    width: 0,
    height: 0,
    visibility: 'hidden',
    display: 'none'
  };

  var ResizeDetector = function (_PureComponent) {
    _inherits(ResizeDetector, _PureComponent);

    function ResizeDetector(props) {
      _classCallCheck(this, ResizeDetector);

      var _this = _possibleConstructorReturn(this, (ResizeDetector.__proto__ || Object.getPrototypeOf(ResizeDetector)).call(this, props));

      _this.createResizeObserver = function (entries) {
        var _this$props = _this.props,
            handleWidth = _this$props.handleWidth,
            handleHeight = _this$props.handleHeight,
            onResize = _this$props.onResize;

        entries.forEach(function (entry) {
          var _entry$contentRect = entry.contentRect,
              width = _entry$contentRect.width,
              height = _entry$contentRect.height;

          var notifyWidth = handleWidth && _this.width !== width;
          var notifyHeight = handleHeight && _this.height !== height;
          if (!_this.skipOnMount && (notifyWidth || notifyHeight)) {
            onResize(width, height);
          }
          _this.width = width;
          _this.height = height;
          _this.skipOnMount = false;
        });
      };

      var skipOnMount = props.skipOnMount,
          refreshMode = props.refreshMode,
          refreshRate = props.refreshRate;


      _this.width = undefined;
      _this.height = undefined;
      _this.skipOnMount = skipOnMount;

      var resizeObserver = listMode[refreshMode] && listMode[refreshMode](_this.createResizeObserver, refreshRate) || _this.createResizeObserver;

      _this.ro = new _resizeObserverPolyfill2.default(resizeObserver);
      return _this;
    }

    _createClass(ResizeDetector, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var resizableElementId = this.props.resizableElementId;

        var resizableElement = resizableElementId ? document.getElementById(resizableElementId) : this.el.parentElement;
        this.ro.observe(resizableElement);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var resizableElementId = this.props.resizableElementId;

        var resizableElement = resizableElementId ? document.getElementById(resizableElementId) : this.el.parentElement;
        this.ro.unobserve(resizableElement);
      }
    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        return _react2.default.createElement('div', {
          style: styles,
          ref: function ref(el) {
            _this2.el = el;
          }
        });
      }
    }]);

    return ResizeDetector;
  }(React__default['default'].PureComponent);

  exports.default = ResizeDetector;


  ResizeDetector.propTypes = {
    handleWidth: _propTypes2.default.bool,
    handleHeight: _propTypes2.default.bool,
    skipOnMount: _propTypes2.default.bool,
    refreshRate: _propTypes2.default.number,
    refreshMode: _propTypes2.default.string,
    resizableElementId: _propTypes2.default.string,
    onResize: _propTypes2.default.func
  };

  ResizeDetector.defaultProps = {
    handleWidth: false,
    handleHeight: false,
    skipOnMount: false,
    refreshRate: 1000,
    refreshMode: undefined,
    resizableElementId: '',
    onResize: function onResize(e) {
      return e;
    }
  };
  });

  unwrapExports(ResizeDetector_1);

  var lib$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _ResizeDetector2 = _interopRequireDefault(ResizeDetector_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _ResizeDetector2.default;
  });

  var ReactResizeDetector = unwrapExports(lib$2);

  /* eslint no-console: 0 */
  var warn = function warn(condition, format, a, b, c, d, e, f) {
  };

  function _typeof$h(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$h = function _typeof(obj) { return typeof obj; }; } else { _typeof$h = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$h(obj); }

  function _classCallCheck$i(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$i(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$i(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$i(Constructor.prototype, protoProps); if (staticProps) _defineProperties$i(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$h(self, call) { if (call && (_typeof$h(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$i(self); }

  function _assertThisInitialized$i(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$h(o) { _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$h(o); }

  function _inherits$h(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$h(subClass, superClass); }

  function _setPrototypeOf$h(o, p) { _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$h(o, p); }

  var ResponsiveContainer =
  /*#__PURE__*/
  function (_Component) {
    _inherits$h(ResponsiveContainer, _Component);

    function ResponsiveContainer(props) {
      var _this;

      _classCallCheck$i(this, ResponsiveContainer);

      _this = _possibleConstructorReturn$h(this, _getPrototypeOf$h(ResponsiveContainer).call(this, props));

      _this.updateDimensionsImmediate = function () {
        if (!_this.mounted) {
          return;
        }

        var newSize = _this.getContainerSize();

        if (newSize) {
          var _this$state = _this.state,
              oldWidth = _this$state.containerWidth,
              oldHeight = _this$state.containerHeight;
          var containerWidth = newSize.containerWidth,
              containerHeight = newSize.containerHeight;

          if (containerWidth !== oldWidth || containerHeight !== oldHeight) {
            _this.setState({
              containerWidth: containerWidth,
              containerHeight: containerHeight
            });
          }
        }
      };

      _this.state = {
        containerWidth: -1,
        containerHeight: -1
      };
      _this.handleResize = props.debounce > 0 ? debounce_1(_this.updateDimensionsImmediate, props.debounce) : _this.updateDimensionsImmediate;
      return _this;
    }
    /* eslint-disable  react/no-did-mount-set-state */


    _createClass$i(ResponsiveContainer, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.mounted = true;
        var size = this.getContainerSize();

        if (size) {
          this.setState(size);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.mounted = false;
      }
    }, {
      key: "getContainerSize",
      value: function getContainerSize() {
        if (!this.container) {
          return null;
        }

        return {
          containerWidth: this.container.clientWidth,
          containerHeight: this.container.clientHeight
        };
      }
    }, {
      key: "renderChart",
      value: function renderChart() {
        var _this$state2 = this.state,
            containerWidth = _this$state2.containerWidth,
            containerHeight = _this$state2.containerHeight;

        if (containerWidth < 0 || containerHeight < 0) {
          return null;
        }

        var _this$props = this.props,
            aspect = _this$props.aspect,
            width = _this$props.width,
            height = _this$props.height;
            _this$props.minWidth;
            _this$props.minHeight;
            var maxHeight = _this$props.maxHeight,
            children = _this$props.children;
        warn(isPercent(width) || isPercent(height));
        var calculatedWidth = isPercent(width) ? containerWidth : width;
        var calculatedHeight = isPercent(height) ? containerHeight : height;

        if (aspect && aspect > 0) {
          // Preserve the desired aspect ratio
          if (calculatedWidth) {
            // Will default to using width for aspect ratio
            calculatedHeight = calculatedWidth / aspect;
          } else if (calculatedHeight) {
            // But we should also take height into consideration
            calculatedWidth = calculatedHeight * aspect;
          } // if maxHeight is set, overwrite if calculatedHeight is greater than maxHeight


          if (maxHeight && calculatedHeight > maxHeight) {
            calculatedHeight = maxHeight;
          }
        }
        return React__default['default'].cloneElement(children, {
          width: calculatedWidth,
          height: calculatedHeight
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props2 = this.props,
            minWidth = _this$props2.minWidth,
            minHeight = _this$props2.minHeight,
            width = _this$props2.width,
            height = _this$props2.height,
            maxHeight = _this$props2.maxHeight,
            id = _this$props2.id,
            className = _this$props2.className;
        var style = {
          width: width,
          height: height,
          minWidth: minWidth,
          minHeight: minHeight,
          maxHeight: maxHeight
        };
        return React__default['default'].createElement("div", {
          id: id,
          className: classnames('recharts-responsive-container', className),
          style: style,
          ref: function ref(node) {
            _this2.container = node;
          }
        }, this.renderChart(), React__default['default'].createElement(ReactResizeDetector, {
          handleWidth: true,
          handleHeight: true,
          onResize: this.handleResize
        }));
      }
    }]);

    return ResponsiveContainer;
  }(React.Component);

  ResponsiveContainer.displayName = 'ResponsiveContainer';
  ResponsiveContainer.propTypes = {
    aspect: propTypes$5.number,
    width: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    height: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    minHeight: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    minWidth: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    maxHeight: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    children: propTypes$5.node.isRequired,
    debounce: propTypes$5.number,
    id: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    className: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number])
  };
  ResponsiveContainer.defaultProps = {
    width: '100%',
    height: '100%',
    debounce: 0
  };

  function ownKeys$k(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$k(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$k(source, true).forEach(function (key) { _defineProperty$m(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$k(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$m(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function Cell$1() {
    return null;
  }

  Cell$1.propTypes = _objectSpread$k({}, PRESENTATION_ATTRIBUTES);
  Cell$1.displayName = 'Cell';

  var balancedMatch$1 = balanced$1;
  function balanced$1(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch$1(a, str);
    if (b instanceof RegExp) b = maybeMatch$1(b, str);

    var r = range$2(a, b, str);

    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }

  function maybeMatch$1(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }

  balanced$1.range = range$2;
  function range$2(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;

    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;

      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [ begs.pop(), bi ];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }

          bi = str.indexOf(b, i + 1);
        }

        i = ai < bi && ai >= 0 ? ai : bi;
      }

      if (begs.length) {
        result = [ left, right ];
      }
    }

    return result;
  }

  var balancedMatch = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);

    var r = range$1(a, b, str);

    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }

  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }

  balanced.range = range$1;
  function range$1(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;

    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;

      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [ begs.pop(), bi ];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }

          bi = str.indexOf(b, i + 1);
        }

        i = ai < bi && ai >= 0 ? ai : bi;
      }

      if (begs.length) {
        result = [ left, right ];
      }
    }

    return result;
  }

  /*
   * Module dependencies
   */


  /**
   * Expose `reduceFunctionCall`
   *
   * @type {Function}
   */
  var reduceFunctionCall_1 = reduceFunctionCall;

  /**
   * Walkthrough all expressions, evaluate them and insert them into the declaration
   *
   * @param {Array} expressions
   * @param {Object} declaration
   */

  function reduceFunctionCall(string, functionRE, callback) {
    var call = string;
    return getFunctionCalls(string, functionRE).reduce(function(string, obj) {
      return string.replace(obj.functionIdentifier + "(" + obj.matches.body + ")", evalFunctionCall(obj.matches.body, obj.functionIdentifier, callback, call, functionRE))
    }, string)
  }

  /**
   * Parses expressions in a value
   *
   * @param {String} value
   * @returns {Array}
   * @api private
   */

  function getFunctionCalls(call, functionRE) {
    var expressions = [];

    var fnRE = typeof functionRE === "string" ? new RegExp("\\b(" + functionRE + ")\\(") : functionRE;
    do {
      var searchMatch = fnRE.exec(call);
      if (!searchMatch) {
        return expressions
      }
      if (searchMatch[1] === undefined) {
        throw new Error("Missing the first couple of parenthesis to get the function identifier in " + functionRE)
      }
      var fn = searchMatch[1];
      var startIndex = searchMatch.index;
      var matches = balancedMatch("(", ")", call.substring(startIndex));

      if (!matches || matches.start !== searchMatch[0].length - 1) {
        throw new SyntaxError(fn + "(): missing closing ')' in the value '" + call + "'")
      }

      expressions.push({matches: matches, functionIdentifier: fn});
      call = matches.post;
    }
    while (fnRE.test(call))

    return expressions
  }

  /**
   * Evaluates an expression
   *
   * @param {String} expression
   * @returns {String}
   * @api private
   */

  function evalFunctionCall (string, functionIdentifier, callback, call, functionRE) {
    // allow recursivity
    return callback(reduceFunctionCall(string, functionRE, callback), functionIdentifier, call)
  }

  var Mexp = function (parsed) {
    this.value = parsed;
  };

  Mexp.math = {
    isDegree: true, // mode of calculator
    acos: function (x) {
      return (Mexp.math.isDegree ? 180 / Math.PI * Math.acos(x) : Math.acos(x))
    },
    add: function (a, b) {
      return a + b
    },
    asin: function (x) {
      return (Mexp.math.isDegree ? 180 / Math.PI * Math.asin(x) : Math.asin(x))
    },
    atan: function (x) {
      return (Mexp.math.isDegree ? 180 / Math.PI * Math.atan(x) : Math.atan(x))
    },
    acosh: function (x) {
      return Math.log(x + Math.sqrt(x * x - 1))
    },
    asinh: function (x) {
      return Math.log(x + Math.sqrt(x * x + 1))
    },
    atanh: function (x) {
      return Math.log((1 + x) / (1 - x))
    },
    C: function (n, r) {
      var pro = 1;
      var other = n - r;
      var choice = r;
      if (choice < other) {
        choice = other;
        other = r;
      }
      for (var i = choice + 1; i <= n; i++) {
        pro *= i;
      }
      return pro / Mexp.math.fact(other)
    },
    changeSign: function (x) {
      return -x
    },
    cos: function (x) {
      if (Mexp.math.isDegree) x = Mexp.math.toRadian(x);
      return Math.cos(x)
    },
    cosh: function (x) {
      return (Math.pow(Math.E, x) + Math.pow(Math.E, -1 * x)) / 2
    },
    div: function (a, b) {
      return a / b
    },
    fact: function (n) {
      if (n % 1 !== 0) return 'NaN'
      var pro = 1;
      for (var i = 2; i <= n; i++) {
        pro *= i;
      }
      return pro
    },
    inverse: function (x) {
      return 1 / x
    },
    log: function (i) {
      return Math.log(i) / Math.log(10)
    },
    mod: function (a, b) {
      return a % b
    },
    mul: function (a, b) {
      return a * b
    },
    P: function (n, r) {
      var pro = 1;
      for (var i = Math.floor(n) - Math.floor(r) + 1; i <= Math.floor(n); i++) {
        pro *= i;
      }
      return pro
    },
    Pi: function (low, high, ex) {
      var pro = 1;
      for (var i = low; i <= high; i++) {
        pro *= Number(ex.postfixEval({
          n: i
        }));
      }
      return pro
    },
    pow10x: function (e) {
      var x = 1;
      while (e--) {
        x *= 10;
      }
      return x
    },
    sigma: function (low, high, ex) {
      var sum = 0;
      for (var i = low; i <= high; i++) {
        sum += Number(ex.postfixEval({
          n: i
        }));
      }
      return sum
    },
    sin: function (x) {
      if (Mexp.math.isDegree) x = Mexp.math.toRadian(x);
      return Math.sin(x)
    },
    sinh: function (x) {
      return (Math.pow(Math.E, x) - Math.pow(Math.E, -1 * x)) / 2
    },
    sub: function (a, b) {
      return a - b
    },
    tan: function (x) {
      if (Mexp.math.isDegree) x = Mexp.math.toRadian(x);
      return Math.tan(x)
    },
    tanh: function (x) {
      return Mexp.sinha(x) / Mexp.cosha(x)
    },
    toRadian: function (x) {
      return x * Math.PI / 180
    }
  };
  Mexp.Exception = function (message) {
    this.message = message;
  };
  var math_function = Mexp;

  function inc(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      arr[i] += val;
    }
    return arr
  }
  var token = ['sin', 'cos', 'tan', 'pi', '(', ')', 'P', 'C', ' ',
    'asin', 'acos', 'atan', '7', '8', '9', 'int',
    'cosh', 'acosh', 'ln', '^', 'root', '4', '5', '6', '/', '!',
    'tanh', 'atanh', 'Mod', '1', '2', '3', '*',
    'sinh', 'asinh', 'e', 'log', '0', '.', '+', '-', ',', 'Sigma', 'n', 'Pi', 'pow'];
  var show = ['sin', 'cos', 'tan', '&pi;', '(', ')', 'P', 'C', ' ',
    'asin', 'acos', 'atan', '7', '8', '9', 'Int',
    'cosh', 'acosh', ' ln', '^', 'root', '4', '5', '6', '&divide;', '!',
    'tanh', 'atanh', ' Mod ', '1', '2', '3', '&times;',
    'sinh', 'asinh', 'e', ' log', '0', '.', '+', '-', ',', '&Sigma;', 'n', '&Pi;', 'pow'];
  var eva = [math_function.math.sin, math_function.math.cos, math_function.math.tan, 'PI', '(', ')', math_function.math.P, math_function.math.C, ' '.anchor,
  math_function.math.asin, math_function.math.acos, math_function.math.atan, '7', '8', '9', Math.floor,
  math_function.math.cosh, math_function.math.acosh, Math.log, Math.pow, Math.sqrt, '4', '5', '6', math_function.math.div, math_function.math.fact,
  math_function.math.tanh, math_function.math.atanh, math_function.math.mod, '1', '2', '3', math_function.math.mul,
  math_function.math.sinh, math_function.math.asinh, 'E', math_function.math.log, '0', '.', math_function.math.add, math_function.math.sub, ',', math_function.math.sigma, 'n', math_function.math.Pi, Math.pow];
  var preced = {
    0: 11,
    1: 0,
    2: 3,
    3: 0,
    4: 0,
    5: 0,
    6: 0,
    7: 11,
    8: 11,
    9: 1,
    10: 10,
    11: 0,
    12: 11,
    13: 0,
    14: -1 // will be filtered after lexer
  }; // stores precedence by types
  var type = [0, 0, 0, 3, 4, 5, 10, 10, 14,
    0, 0, 0, 1, 1, 1, 0,
    0, 0, 0, 10, 0, 1, 1, 1, 2, 7,
    0, 0, 2, 1, 1, 1, 2,
    0, 0, 3, 0, 1, 6, 9, 9, 11, 12, 13, 12, 8];
  /*
  0 : function with syntax function_name(Maths_exp)
  1 : numbers
  2 : binary operators like * / Mod left associate and same precedence
  3 : Math constant values like e,pi,Cruncher ans
  4 : opening bracket
  5 : closing bracket
  6 : decimal
  7 : function with syntax (Math_exp)function_name
  8: function with syntax function_name(Math_exp1,Math_exp2)
  9 : binary operator like +,-
  10: binary operator like P C or ^
  11: ,
  12: function with , seperated three parameters and third parameter is a string that will be mexp string
  13: variable of Sigma function
  */
  var type0 = {
    0: true,
    1: true,
    3: true,
    4: true,
    6: true,
    8: true,
    9: true,
    12: true,
    13: true,
    14: true
  }; // type2:true,type4:true,type9:true,type11:true,type21:true,type22
  var type1 = {
    0: true,
    1: true,
    2: true,
    3: true,
    4: true,
    5: true,
    6: true,
    7: true,
    8: true,
    9: true,
    10: true,
    11: true,
    12: true,
    13: true
  }; // type3:true,type5:true,type7:true,type23
  var type1Asterick = {
    0: true,
    3: true,
    4: true,
    8: true,
    12: true,
    13: true
  };
  var empty = {};
  var type3Asterick = {
    0: true,
    1: true,
    3: true,
    4: true,
    6: true,
    8: true,
    12: true,
    13: true
  }; // type_5:true,type_7:true,type_23
  var type6 = {
    1: true
  };
  var newAr = [
    [],
    ['1', '2', '3', '7', '8', '9', '4', '5', '6', '+', '-', '*', '/', '(', ')', '^', '!', 'P', 'C', 'e', '0', '.', ',', 'n', ' '],
    ['pi', 'ln', 'Pi'],
    ['sin', 'cos', 'tan', 'Del', 'int', 'Mod', 'log', 'pow'],
    ['asin', 'acos', 'atan', 'cosh', 'root', 'tanh', 'sinh'],
    ['acosh', 'atanh', 'asinh', 'Sigma']
  ];

  function match(str1, str2, i, x) {
    for (var f = 0; f < x; f++) {
      if (str1[i + f] !== str2[f]) {
        return false
      }
    }
    return true
  }
  math_function.addToken = function (tokens) {
    for (var i = 0; i < tokens.length; i++) {
      var x = tokens[i].token.length;
      var temp = -1;

      // newAr is a specially designed data structure index of 1d array = length of tokens
      newAr[x] = newAr[x] || [];
      for (var y = 0; y < newAr[x].length; y++) {
        if (tokens[i].token === newAr[x][y]) {
          temp = token.indexOf(newAr[x][y]);
          break
        }
      }
      if (temp === -1) {
        token.push(tokens[i].token);
        type.push(tokens[i].type);
        if (newAr.length <= tokens[i].token.length) {
          newAr[tokens[i].token.length] = [];
        }
        newAr[tokens[i].token.length].push(tokens[i].token);
        eva.push(tokens[i].value);
        show.push(tokens[i].show);
      } else { // overwrite
        token[temp] = tokens[i].token;
        type[temp] = tokens[i].type;
        eva[temp] = tokens[i].value;
        show[temp] = tokens[i].show;
      }
    }
  };

  function tokenize(string) {
    var nodes = [];
    var length = string.length;
    var key, x, y;
    for (var i = 0; i < length; i++) {
      if (i < length - 1 && string[i] === ' ' && string[i + 1] === ' ') {
        continue
      }
      key = '';
      for (x = (string.length - i > (newAr.length - 2) ? newAr.length - 1 : string.length - i); x > 0; x--) {
        if (newAr[x] === undefined) continue;
        for (y = 0; y < newAr[x].length; y++) {
          if (match(string, newAr[x][y], i, x)) {
            key = newAr[x][y];
            y = newAr[x].length;
            x = 0;
          }
        }
      }
      i += key.length - 1;
      if (key === '') {
        throw (new math_function.Exception('Can\'t understand after ' + string.slice(i)))
      }
      var index = token.indexOf(key);
      nodes.push({
        index: index,
        token: key,
        type: type[index],
        eval: eva[index],
        precedence: preced[type[index]],
        show: show[index]
      });
    }
    return nodes;
  }

  math_function.lex = function (inp, tokens) {


    var changeSignObj = {
      value: math_function.math.changeSign,
      type: 0,
      pre: 21,
      show: '-'
    };
    var closingParObj = {
      value: ')',
      show: ')',
      type: 5,
      pre: 0
    };
    var openingParObj = {
      value: '(',
      type: 4,
      pre: 0,
      show: '('
    };
    var str = [openingParObj];

    var ptc = []; // Parenthesis to close at the beginning is after one token
    var inpStr = inp;
    var allowed = type0;
    var bracToClose = 0;
    var asterick = empty;
    var prevKey = '';
    var i;
    if (typeof tokens !== 'undefined') {
      math_function.addToken(tokens);
    }
    var obj = {};
    var nodes = tokenize(inpStr);
    for (i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (node.type === 14) {
        if (i > 0 &&
          i < nodes.length - 1 &&
          nodes[i + 1].type === 1 &&
          (nodes[i - 1].type === 1 || nodes[i - 1].type === 6))
          throw new math_function.Exception('Unexpected Space')
        continue
      }

      node.index;
      var cToken = node.token;
      var cType = node.type;
      var cEv = node.eval;
      var cPre = node.precedence;
      var cShow = node.show;
      var pre = str[str.length - 1];
      var j;
      for (j = ptc.length; j--;) { // loop over ptc
        if (ptc[j] === 0) {
          if ([0, 2, 3, 4, 5, 9, 11, 12, 13].indexOf(cType) !== -1) {
            if (allowed[cType] !== true) {
              console.log(inp, node, nodes, allowed);
              throw (new math_function.Exception(cToken + ' is not allowed after ' + prevKey))
            }
            str.push(closingParObj);
            allowed = type1;
            asterick = type3Asterick;
            inc(ptc, -1).pop();
          }
        } else break
      }
      if (allowed[cType] !== true) {
        throw (new math_function.Exception(cToken + ' is not allowed after ' + prevKey))
      }
      if (asterick[cType] === true) {
        cType = 2;
        cEv = math_function.math.mul;
        cShow = '&times;';
        cPre = 3;
        i = i - cToken.length;
      }
      obj = {
        value: cEv,
        type: cType,
        pre: cPre,
        show: cShow
      };
      if (cType === 0) {
        allowed = type0;
        asterick = empty;
        inc(ptc, 2).push(2);
        str.push(obj);
        str.push(openingParObj);
      } else if (cType === 1) {
        if (pre.type === 1) {
          pre.value += cEv;
          inc(ptc, 1);
        } else {
          str.push(obj);
        }
        allowed = type1;
        asterick = type1Asterick;
      } else if (cType === 2) {
        allowed = type0;
        asterick = empty;
        inc(ptc, 2);
        str.push(obj);
      } else if (cType === 3) { // constant
        str.push(obj);
        allowed = type1;
        asterick = type3Asterick;
      } else if (cType === 4) {
        inc(ptc, 1);
        bracToClose++;
        allowed = type0;
        asterick = empty;
        str.push(obj);
      } else if (cType === 5) {
        if (!bracToClose) {
          throw (new math_function.Exception('Closing parenthesis are more than opening one, wait What!!!'))
        }
        bracToClose--;
        allowed = type1;
        asterick = type3Asterick;
        str.push(obj);
        inc(ptc, 1);
      } else if (cType === 6) {
        if (pre.hasDec) {
          throw (new math_function.Exception('Two decimals are not allowed in one number'))
        }
        if (pre.type !== 1) {
          pre = {
            value: 0,
            type: 1,
            pre: 0
          }; // pre needs to be changed as it will the last value now to be safe in later code
          str.push(pre);
          inc(ptc, -1);
        }
        allowed = type6;
        inc(ptc, 1);
        asterick = empty;
        pre.value += cEv;
        pre.hasDec = true;
      } else if (cType === 7) {
        allowed = type1;
        asterick = type3Asterick;
        inc(ptc, 1);
        str.push(obj);
      }
      if (cType === 8) {
        allowed = type0;
        asterick = empty;
        inc(ptc, 4).push(4);
        str.push(obj);
        str.push(openingParObj);
      } else if (cType === 9) {
        if (pre.type === 9) {
          if (pre.value === math_function.math.add) {
            pre.value = cEv;
            pre.show = cShow;
            inc(ptc, 1);
          } else if (pre.value === math_function.math.sub && cShow === '-') {
            pre.value = math_function.math.add;
            pre.show = '+';
            inc(ptc, 1);
          }
        } else if (pre.type !== 5 && pre.type !== 7 && pre.type !== 1 && pre.type !== 3 && pre.type !== 13) { // changesign only when negative is found
          if (cToken === '-') { // do nothing for + token
            // don't add with the above if statement as that will run the else statement of parent if on Ctoken +
            allowed = type0;
            asterick = empty;
            inc(ptc, 2).push(2);
            str.push(changeSignObj);
            str.push(openingParObj);
          }
        } else {
          str.push(obj);
          inc(ptc, 2);
        }
        allowed = type0;
        asterick = empty;
      } else if (cType === 10) {
        allowed = type0;
        asterick = empty;
        inc(ptc, 2);
        str.push(obj);
      } else if (cType === 11) {
        allowed = type0;
        asterick = empty;
        str.push(obj);
      } else if (cType === 12) {
        allowed = type0;
        asterick = empty;
        inc(ptc, 6).push(6);
        str.push(obj);
        str.push(openingParObj);
      } else if (cType === 13) {
        allowed = type1;
        asterick = type3Asterick;
        str.push(obj);
      }
      inc(ptc, -1);
      prevKey = cToken;
    }
    for (j = ptc.length; j--;) { // loop over ptc
      if (ptc[j] === 0) {
        str.push(closingParObj);
        inc(ptc, -1).pop();
      } else break  // if it is not zero so before ptc also cant be zero
    }
    if (allowed[5] !== true) {
      throw (new math_function.Exception('complete the expression'))
    }
    while (bracToClose--) {
      str.push(closingParObj);
    }

    str.push(closingParObj);
    //        console.log(str);
    return new math_function(str)
  };
  var lexer = math_function;

  lexer.prototype.toPostfix = function () {
  	var post = [], elem, popped, prep, pre, ele;
  	var stack = [{ value: "(", type: 4, pre: 0 }];
  	var arr = this.value;
  	for (var i = 1; i < arr.length; i++) {
  		if (arr[i].type === 1 || arr[i].type === 3 || arr[i].type === 13) {	//if token is number,constant,or n(which is also a special constant in our case)
  			if (arr[i].type === 1)
  				arr[i].value = Number(arr[i].value);
  			post.push(arr[i]);
  		}
  		else if (arr[i].type === 4) {
  			stack.push(arr[i]);
  		}
  		else if (arr[i].type === 5) {
  			while ((popped = stack.pop()).type !== 4) {
  				post.push(popped);
  			}
  		}
  		else if (arr[i].type === 11) {
  			while ((popped = stack.pop()).type !== 4) {
  				post.push(popped);
  			}
  			stack.push(popped);
  		}
  		else {
  			elem = arr[i];
  			pre = elem.pre;
  			ele = stack[stack.length - 1];
  			prep = ele.pre;
  			var flag = ele.value == 'Math.pow' && elem.value == 'Math.pow';
  			if (pre > prep) stack.push(elem);
  			else {
  				while (prep >= pre && !flag || flag && pre < prep) {
  					popped = stack.pop();
  					ele = stack[stack.length - 1];
  					post.push(popped);
  					prep = ele.pre;
  					flag = elem.value == 'Math.pow' && ele.value == 'Math.pow';
  				}
  				stack.push(elem);
  			}
  		}
  	}
  	return new lexer(post);
  };
  var postfix = lexer;

  postfix.prototype.postfixEval = function (UserDefined) {
  	UserDefined=UserDefined||{};
  	UserDefined.PI=Math.PI;
  	UserDefined.E=Math.E;
  	var stack=[],pop1,pop2,pop3;
  	var arr=this.value;
  	var bool=(typeof UserDefined.n!=="undefined");
  	for(var i=0;i<arr.length;i++){
  		if(arr[i].type===1){
  			stack.push({value:arr[i].value,type:1});
  		}
  		else if(arr[i].type===3){
  			stack.push({value:UserDefined[arr[i].value],type:1});
  		}
  		else if(arr[i].type===0){
  			if(typeof stack[stack.length-1].type==="undefined"){
  				stack[stack.length-1].value.push(arr[i]);
  			}
  			else stack[stack.length-1].value=arr[i].value(stack[stack.length-1].value);
  		}
  		else if(arr[i].type===7){
  			if(typeof stack[stack.length-1].type==="undefined"){
  				stack[stack.length-1].value.push(arr[i]);
  			}
  			else stack[stack.length-1].value=arr[i].value(stack[stack.length-1].value);
  		}
  		else if(arr[i].type===8){
  			pop1=stack.pop();
  			pop2=stack.pop();
  			stack.push({type:1,value:arr[i].value(pop2.value,pop1.value)});
  		}
  		else if(arr[i].type===10){
  			pop1=stack.pop();
  			pop2=stack.pop();
  			if(typeof pop2.type==="undefined"){
  				pop2.value=pop2.concat(pop1);
  				pop2.value.push(arr[i]);
  				stack.push(pop2);
  			}
  			else if (typeof pop1.type==="undefined") {
  				pop1.unshift(pop2);
  				pop1.push(arr[i]);
  				stack.push(pop1);
  			}
  			else {
  				stack.push({type:1,value:arr[i].value(pop2.value,pop1.value)});
              }
  		}
  		else if(arr[i].type===2||arr[i].type===9){
  			pop1=stack.pop();
  			pop2=stack.pop();
  			if(typeof pop2.type==="undefined"){
  				pop2=pop2.concat(pop1);
  				pop2.push(arr[i]);
  				stack.push(pop2);
  			}
  			else if (typeof pop1.type==="undefined") {
  				pop1.unshift(pop2);
  				pop1.push(arr[i]);
  				stack.push(pop1);
  			}
  			else {
  				stack.push({type:1,value:arr[i].value(pop2.value,pop1.value)});
  			}
  		}
  		else if(arr[i].type===12){
  			pop1=stack.pop();
  			if (typeof pop1.type!=="undefined") {
  				pop1=[pop1];
  			}
  			pop2=stack.pop();
  			pop3=stack.pop();
  			stack.push({type:1,value:arr[i].value(pop3.value,pop2.value,new postfix(pop1))});
  		}
  		else if(arr[i].type===13){
  			if(bool){
  				stack.push({value:UserDefined[arr[i].value],type:3});
  			}
  			else stack.push([arr[i]]);
  		}
  	}
  	if (stack.length>1) {
  		throw(new postfix.Exception("Uncaught Syntax error"));
  	}
  	return stack[0].value>1000000000000000?"Infinity":parseFloat(stack[0].value.toFixed(15));
  };
  postfix.eval=function(str,tokens,obj){
  	if (typeof tokens==="undefined") {
  		return this.lex(str).toPostfix().postfixEval();
  	}
  	else if (typeof obj==="undefined") {
  		if (typeof tokens.length!=="undefined") 
  			return this.lex(str,tokens).toPostfix().postfixEval();
  		else
  			return this.lex(str).toPostfix().postfixEval(tokens);
  	}
  	else
  		return this.lex(str,tokens).toPostfix().postfixEval(obj);
  };
  var postfix_evaluator=postfix;

  postfix_evaluator.prototype.formulaEval = function () {
  	var pop1,pop2,pop3;
  	var disp=[];
  	var arr=this.value;
  	for(var i=0;i<arr.length;i++){
  		if(arr[i].type===1||arr[i].type===3){
  			disp.push({value:arr[i].type===3?arr[i].show:arr[i].value,type:1});
  		}
  		else if(arr[i].type===13){
  			disp.push({value:arr[i].show,type:1});
  		}
  		else if(arr[i].type===0){
  			disp[disp.length-1]={value:arr[i].show+(arr[i].show!="-"?"(":"")+disp[disp.length-1].value+(arr[i].show!="-"?")":""),type:0};
  		}
  		else if(arr[i].type===7){
  			disp[disp.length-1]={value:(disp[disp.length-1].type!=1?"(":"")+disp[disp.length-1].value+(disp[disp.length-1].type!=1?")":"")+arr[i].show,type:7};
  		}
  		else if(arr[i].type===10){
  			pop1=disp.pop();
  			pop2=disp.pop();
  			if(arr[i].show==='P'||arr[i].show==='C')disp.push({value:"<sup>"+pop2.value+"</sup>"+arr[i].show+"<sub>"+pop1.value+"</sub>",type:10});
  			else disp.push({value:(pop2.type!=1?"(":"")+pop2.value+(pop2.type!=1?")":"")+"<sup>"+pop1.value+"</sup>",type:1});
  		}
  		else if(arr[i].type===2||arr[i].type===9){
  			pop1=disp.pop();
  			pop2=disp.pop();
  			disp.push({value:(pop2.type!=1?"(":"")+pop2.value+(pop2.type!=1?")":"")+arr[i].show+(pop1.type!=1?"(":"")+pop1.value+(pop1.type!=1?")":""),type:arr[i].type});
  		}
  		else if(arr[i].type===12){
  			pop1=disp.pop();
  			pop2=disp.pop();
  			pop3=disp.pop();
  			disp.push({value:arr[i].show+"("+pop3.value+","+pop2.value+","+pop1.value+")",type:12});
  		}
  	}
  	return disp[0].value;
  };
  var formula_evaluator=postfix_evaluator;

  /**
   * Module dependencies
   */




  /**
   * Constantes
   */
  var MAX_STACK = 100; // should be enough for a single calc()...
  var NESTED_CALC_RE = /(\+|\-|\*|\\|[^a-z]|)(\s*)(\()/g;

  /**
   * Global variables
   */
  var stack;

  /**
   * Expose reduceCSSCalc plugin
   *
   * @type {Function}
   */
  var reduceCssCalc = reduceCSSCalc;

  /**
   * Reduce CSS calc() in a string, whenever it's possible
   *
   * @param {String} value css input
   */
  function reduceCSSCalc(value, decimalPrecision) {
    stack = 0;
    decimalPrecision = Math.pow(10, decimalPrecision === undefined ? 5 : decimalPrecision);

    // Allow calc() on multiple lines
    value = value.replace(/\n+/g, " ");

    /**
     * Evaluates an expression
     *
     * @param {String} expression
     * @returns {String}
     */
    function evaluateExpression (expression, functionIdentifier, call) {
      if (stack++ > MAX_STACK) {
        stack = 0;
        throw new Error("Call stack overflow for " + call)
      }

      if (expression === "") {
        throw new Error(functionIdentifier + "(): '" + call + "' must contain a non-whitespace string")
      }

      expression = evaluateNestedExpression(expression, call);

      var units = getUnitsInExpression(expression);

      // If the expression contains multiple units or CSS variables,
      // then let the expression be (i.e. browser calc())
      if (units.length > 1 || expression.indexOf("var(") > -1) {
        return functionIdentifier + "(" + expression + ")"
      }

      var unit = units[0] || "";

      if (unit === "%") {
        // Convert percentages to numbers, to handle expressions like: 50% * 50% (will become: 25%):
        // console.log(expression)
        expression = expression.replace(/\b[0-9\.]+%/g, function(percent) {
          return parseFloat(percent.slice(0, -1)) * 0.01
        });
      }

      // Remove units in expression:
      var toEvaluate = expression.replace(new RegExp(unit, "gi"), "");
      var result;

      try {
        result = formula_evaluator.eval(toEvaluate);
      }
      catch (e) {
        return functionIdentifier + "(" + expression + ")"
      }

      // Transform back to a percentage result:
      if (unit === "%") {
        result *= 100;
      }

      // adjust rounding shit
      // (0.1 * 0.2 === 0.020000000000000004)
      if (functionIdentifier.length || unit === "%") {
        result = Math.round(result * decimalPrecision) / decimalPrecision;
      }

      // Add unit
      result += unit;

      return result
    }

    /**
     * Evaluates nested expressions
     *
     * @param {String} expression
     * @returns {String}
     */
    function evaluateNestedExpression(expression, call) {
      // Remove the calc part from nested expressions to ensure
      // better browser compatibility
      expression = expression.replace(/((?:\-[a-z]+\-)?calc)/g, "");
      var evaluatedPart = "";
      var nonEvaluatedPart = expression;
      var matches;
      while ((matches = NESTED_CALC_RE.exec(nonEvaluatedPart))) {
        if (matches[0].index > 0) {
          evaluatedPart += nonEvaluatedPart.substring(0, matches[0].index);
        }

        var balancedExpr = balancedMatch$1("(", ")", nonEvaluatedPart.substring([0].index));
        if (balancedExpr.body === "") {
          throw new Error("'" + expression + "' must contain a non-whitespace string")
        }

        var evaluated = evaluateExpression(balancedExpr.body, "", call);

        evaluatedPart += balancedExpr.pre + evaluated;
        nonEvaluatedPart = balancedExpr.post;
      }

      return evaluatedPart + nonEvaluatedPart
    }

    return reduceFunctionCall_1(value, /((?:\-[a-z]+\-)?calc)\(/, evaluateExpression)
  }

  /**
   * Checks what units are used in an expression
   *
   * @param {String} expression
   * @returns {Array}
   */

  function getUnitsInExpression(expression) {
    var uniqueUnits = [];
    var uniqueLowerCaseUnits = [];
    var unitRegEx = /[\.0-9]([%a-z]+)/gi;
    var matches = unitRegEx.exec(expression);

    while (matches) {
      if (!matches || !matches[1]) {
        continue
      }

      if (uniqueLowerCaseUnits.indexOf(matches[1].toLowerCase()) === -1) {
        uniqueUnits.push(matches[1]);
        uniqueLowerCaseUnits.push(matches[1].toLowerCase());
      }

      matches = unitRegEx.exec(expression);
    }

    return uniqueUnits
  }

  function ownKeys$j(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$j(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$j(source, true).forEach(function (key) { _defineProperty$l(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$j(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$l(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _toConsumableArray$4(arr) { return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _nonIterableSpread$4(); }

  function _nonIterableSpread$4() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray$4(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles$4(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }
  var stringCache = {
    widthCache: {},
    cacheCount: 0
  };
  var MAX_CACHE_NUM = 2000;
  var SPAN_STYLE = {
    position: 'absolute',
    top: '-20000px',
    left: 0,
    padding: 0,
    margin: 0,
    border: 'none',
    whiteSpace: 'pre'
  };
  var STYLE_LIST = ['minWidth', 'maxWidth', 'width', 'minHeight', 'maxHeight', 'height', 'top', 'left', 'fontSize', 'lineHeight', 'padding', 'margin', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom'];
  var MEASUREMENT_SPAN_ID = 'recharts_measurement_span';

  function autoCompleteStyle(name, value) {
    if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
      return "".concat(value, "px");
    }

    return value;
  }

  function camelToMiddleLine(text) {
    var strs = text.split('');
    var formatStrs = strs.reduce(function (result, entry) {
      if (entry === entry.toUpperCase()) {
        return [].concat(_toConsumableArray$4(result), ['-', entry.toLowerCase()]);
      }

      return [].concat(_toConsumableArray$4(result), [entry]);
    }, []);
    return formatStrs.join('');
  }

  var getStyleString = function getStyleString(style) {
    return Object.keys(style).reduce(function (result, s) {
      return "".concat(result).concat(camelToMiddleLine(s), ":").concat(autoCompleteStyle(s, style[s]), ";");
    }, '');
  };
  var getStringSize = function getStringSize(text) {
    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (text === undefined || text === null || isSsr()) {
      return {
        width: 0,
        height: 0
      };
    }

    var str = "".concat(text);
    var styleString = getStyleString(style);
    var cacheKey = "".concat(str, "-").concat(styleString);

    if (stringCache.widthCache[cacheKey]) {
      return stringCache.widthCache[cacheKey];
    }

    try {
      var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);

      if (!measurementSpan) {
        measurementSpan = document.createElement('span');
        measurementSpan.setAttribute('id', MEASUREMENT_SPAN_ID);
        document.body.appendChild(measurementSpan);
      } // Need to use CSS Object Model (CSSOM) to be able to comply with Content Security Policy (CSP)
      // https://en.wikipedia.org/wiki/Content_Security_Policy


      var measurementSpanStyle = _objectSpread$j({}, SPAN_STYLE, {}, style);

      Object.keys(measurementSpanStyle).map(function (styleKey) {
        measurementSpan.style[styleKey] = measurementSpanStyle[styleKey];
        return styleKey;
      });
      measurementSpan.textContent = str;
      var rect = measurementSpan.getBoundingClientRect();
      var result = {
        width: rect.width,
        height: rect.height
      };
      stringCache.widthCache[cacheKey] = result;

      if (++stringCache.cacheCount > MAX_CACHE_NUM) {
        stringCache.cacheCount = 0;
        stringCache.widthCache = {};
      }

      return result;
    } catch (e) {
      return {
        width: 0,
        height: 0
      };
    }
  };
  var getOffset = function getOffset(el) {
    var html = el.ownerDocument.documentElement;
    var box = {
      top: 0,
      left: 0
    }; // If we don't have gBCR, just use 0,0 rather than error
    // BlackBerry 5, iOS 3 (original iPhone)

    if (typeof el.getBoundingClientRect !== 'undefined') {
      box = el.getBoundingClientRect();
    }

    return {
      top: box.top + window.pageYOffset - html.clientTop,
      left: box.left + window.pageXOffset - html.clientLeft
    };
  };
  /**
   * Calculate coordinate of cursor in chart
   * @param  {Object} event  Event object
   * @param  {Object} offset The offset of main part in the svg element
   * @return {Object}        {chartX, chartY}
   */

  var calculateChartCoordinate = function calculateChartCoordinate(event, offset) {
    return {
      chartX: Math.round(event.pageX - offset.left),
      chartY: Math.round(event.pageY - offset.top)
    };
  };

  function ownKeys$i(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$i(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$i(source, true).forEach(function (key) { _defineProperty$k(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$i(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$k(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof$g(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$g = function _typeof(obj) { return typeof obj; }; } else { _typeof$g = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$g(obj); }

  function _extends$k() { _extends$k = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$k.apply(this, arguments); }

  function _objectWithoutProperties$5(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$6(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$6(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _classCallCheck$h(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$h(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$h(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$h(Constructor.prototype, protoProps); if (staticProps) _defineProperties$h(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$g(self, call) { if (call && (_typeof$g(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$h(self); }

  function _assertThisInitialized$h(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$g(o) { _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$g(o); }

  function _inherits$g(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$g(subClass, superClass); }

  function _setPrototypeOf$g(o, p) { _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$g(o, p); }
  var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;

  var calculateWordWidths = function calculateWordWidths(props) {
    try {
      var words = !isNil_1(props.children) ? props.children.toString().split(BREAKING_SPACES) : [];
      var wordsWithComputedWidth = words.map(function (word) {
        return {
          word: word,
          width: getStringSize(word, props.style).width
        };
      });
      var spaceWidth = getStringSize("\xA0", props.style).width;
      return {
        wordsWithComputedWidth: wordsWithComputedWidth,
        spaceWidth: spaceWidth
      };
    } catch (e) {
      return null;
    }
  };

  var Text =
  /*#__PURE__*/
  function (_Component) {
    _inherits$g(Text, _Component);

    function Text(_props) {
      var _this;

      _classCallCheck$h(this, Text);

      _this = _possibleConstructorReturn$g(this, _getPrototypeOf$g(Text).call(this, _props));

      _this.getWordsWithoutCalculate = function (props) {
        var words = !isNil_1(props.children) ? props.children.toString().split(BREAKING_SPACES) : [];
        return [{
          words: words
        }];
      };

      _this.state = {
        wordsByLines: _this.getWordsByLines(_props, true)
      };
      return _this;
    }

    _createClass$h(Text, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateWordsByLines(this.props, true);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (prevProps.width !== this.props.width || prevProps.scaleToFit !== this.props.scaleToFit || prevProps.children !== this.props.children || prevProps.style !== this.props.style) {
          var needCalculate = this.props.children !== prevProps.children || this.props.style !== prevProps.style;
          this.updateWordsByLines(this.props, needCalculate);
        }
      }
    }, {
      key: "updateWordsByLines",
      value: function updateWordsByLines(props, needCalculate) {
        this.setState({
          wordsByLines: this.getWordsByLines(props, needCalculate)
        });
      }
    }, {
      key: "getWordsByLines",
      value: function getWordsByLines(props, needCalculate) {
        // Only perform calculations if using features that require them (multiline, scaleToFit)
        if ((props.width || props.scaleToFit) && !isSsr()) {
          if (needCalculate) {
            var wordWidths = calculateWordWidths(props);

            if (wordWidths) {
              var wordsWithComputedWidth = wordWidths.wordsWithComputedWidth,
                  spaceWidth = wordWidths.spaceWidth;
              this.wordsWithComputedWidth = wordsWithComputedWidth;
              this.spaceWidth = spaceWidth;
            } else {
              return this.getWordsWithoutCalculate(props);
            }
          }

          return this.calculateWordsByLines(this.wordsWithComputedWidth, this.spaceWidth, props.width);
        }

        return this.getWordsWithoutCalculate(props);
      }
    }, {
      key: "calculateWordsByLines",
      value: function calculateWordsByLines(wordsWithComputedWidth, spaceWidth, lineWidth) {
        var scaleToFit = this.props.scaleToFit;
        return (wordsWithComputedWidth || []).reduce(function (result, _ref) {
          var word = _ref.word,
              width = _ref.width;
          var currentLine = result[result.length - 1];

          if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < lineWidth)) {
            // Word can be added to an existing line
            currentLine.words.push(word);
            currentLine.width += width + spaceWidth;
          } else {
            // Add first word to line or word is too long to scaleToFit on existing line
            var newLine = {
              words: [word],
              width: width
            };
            result.push(newLine);
          }

          return result;
        }, []);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            dx = _this$props.dx,
            dy = _this$props.dy,
            textAnchor = _this$props.textAnchor,
            verticalAnchor = _this$props.verticalAnchor,
            scaleToFit = _this$props.scaleToFit,
            angle = _this$props.angle,
            lineHeight = _this$props.lineHeight,
            capHeight = _this$props.capHeight,
            className = _this$props.className,
            textProps = _objectWithoutProperties$5(_this$props, ["dx", "dy", "textAnchor", "verticalAnchor", "scaleToFit", "angle", "lineHeight", "capHeight", "className"]);

        var wordsByLines = this.state.wordsByLines;

        if (!isNumOrStr(textProps.x) || !isNumOrStr(textProps.y)) {
          return null;
        }

        var x = textProps.x + (isNumber(dx) ? dx : 0);
        var y = textProps.y + (isNumber(dy) ? dy : 0);
        var startDy;

        switch (verticalAnchor) {
          case 'start':
            startDy = reduceCssCalc("calc(".concat(capHeight, ")"));
            break;

          case 'middle':
            startDy = reduceCssCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
            break;

          default:
            startDy = reduceCssCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
            break;
        }

        var transforms = [];

        if (scaleToFit) {
          var lineWidth = wordsByLines[0].width;
          transforms.push("scale(".concat(this.props.width / lineWidth, ")"));
        }

        if (angle) {
          transforms.push("rotate(".concat(angle, ", ").concat(x, ", ").concat(y, ")"));
        }

        if (transforms.length) {
          textProps.transform = transforms.join(' ');
        }

        return React__default['default'].createElement("text", _extends$k({}, getPresentationAttributes(textProps), filterEventAttributes(textProps), {
          x: x,
          y: y,
          className: classnames('recharts-text', className),
          textAnchor: textAnchor
        }), wordsByLines.map(function (line, index) {
          return (// eslint-disable-next-line react/no-array-index-key
            React__default['default'].createElement("tspan", {
              x: x,
              dy: index === 0 ? startDy : lineHeight,
              key: index
            }, line.words.join(' '))
          );
        }));
      }
    }]);

    return Text;
  }(React.Component);

  Text.propTypes = _objectSpread$i({}, PRESENTATION_ATTRIBUTES, {
    scaleToFit: propTypes$5.bool,
    angle: propTypes$5.number,
    textAnchor: propTypes$5.oneOf(['start', 'middle', 'end', 'inherit']),
    verticalAnchor: propTypes$5.oneOf(['start', 'middle', 'end']),
    style: propTypes$5.object
  });
  Text.defaultProps = {
    x: 0,
    y: 0,
    lineHeight: '1em',
    capHeight: '0.71em',
    // Magic number from d3
    scaleToFit: false,
    textAnchor: 'start',
    verticalAnchor: 'end' // Maintain compat with existing charts / default SVG behavior

  };

  /**
   * The base implementation of methods like `_.max` and `_.min` which accepts a
   * `comparator` to determine the extremum value.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The iteratee invoked per iteration.
   * @param {Function} comparator The comparator used to compare values.
   * @returns {*} Returns the extremum value.
   */
  function baseExtremum(array, iteratee, comparator) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      var value = array[index],
          current = iteratee(value);

      if (current != null && (computed === undefined
            ? (current === current && !isSymbol_1(current))
            : comparator(current, computed)
          )) {
        var computed = current,
            result = value;
      }
    }
    return result;
  }

  var _baseExtremum = baseExtremum;

  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */
  function baseGt(value, other) {
    return value > other;
  }

  var _baseGt = baseGt;

  /**
   * Computes the maximum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * _.max([4, 2, 8, 6]);
   * // => 8
   *
   * _.max([]);
   * // => undefined
   */
  function max(array) {
    return (array && array.length)
      ? _baseExtremum(array, identity_1, _baseGt)
      : undefined;
  }

  var max_1 = max;

  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */
  function baseLt(value, other) {
    return value < other;
  }

  var _baseLt = baseLt;

  /**
   * Computes the minimum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // => 2
   *
   * _.min([]);
   * // => undefined
   */
  function min(array) {
    return (array && array.length)
      ? _baseExtremum(array, identity_1, _baseLt)
      : undefined;
  }

  var min_1 = min;

  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map$3(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayMap : _baseMap;
    return func(collection, _baseIteratee(iteratee));
  }

  var map_1 = map$3;

  /**
   * Creates a flattened array of values by running each element in `collection`
   * thru `iteratee` and flattening the mapped results. The iteratee is invoked
   * with three arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * function duplicate(n) {
   *   return [n, n];
   * }
   *
   * _.flatMap([1, 2], duplicate);
   * // => [1, 1, 2, 2]
   */
  function flatMap(collection, iteratee) {
    return _baseFlatten(map_1(collection, iteratee), 1);
  }

  var flatMap_1 = flatMap;

  /*
   *  decimal.js-light v2.5.1
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js-light
   *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Expat Licence
   */


  // ------------------------------------  EDITABLE DEFAULTS  ------------------------------------- //


  // The limit on the value of `precision`, and on the value of the first argument to
  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
  var MAX_DIGITS = 1e9,                        // 0 to 1e9


    // The initial configuration properties of the Decimal constructor.
    defaults = {

      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed during run-time using `Decimal.config`.

      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,                         // 1 to MAX_DIGITS

      // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
      // `toFixed`, `toPrecision` and `toSignificantDigits`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,                           // 0 to 8

      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,                          // 0 to -MAX_E

      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos:  21,                         // 0 to MAX_E

      // The natural logarithm of 10.
      // 115 digits
      LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286'
    },


  // ------------------------------------ END OF EDITABLE DEFAULTS -------------------------------- //


    Decimal,
    external = true,

    decimalError = '[DecimalError] ',
    invalidArgument = decimalError + 'Invalid argument: ',
    exponentOutOfRange = decimalError + 'Exponent out of range: ',

    mathfloor = Math.floor,
    mathpow = Math.pow,

    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

    ONE,
    BASE = 1e7,
    LOG_BASE = 7,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE),    // 1286742750677284

    // Decimal.prototype object
    P = {};


  // Decimal prototype methods


  /*
   *  absoluteValue                       abs
   *  comparedTo                          cmp
   *  decimalPlaces                       dp
   *  dividedBy                           div
   *  dividedToIntegerBy                  idiv
   *  equals                              eq
   *  exponent
   *  greaterThan                         gt
   *  greaterThanOrEqualTo                gte
   *  isInteger                           isint
   *  isNegative                          isneg
   *  isPositive                          ispos
   *  isZero
   *  lessThan                            lt
   *  lessThanOrEqualTo                   lte
   *  logarithm                           log
   *  minus                               sub
   *  modulo                              mod
   *  naturalExponential                  exp
   *  naturalLogarithm                    ln
   *  negated                             neg
   *  plus                                add
   *  precision                           sd
   *  squareRoot                          sqrt
   *  times                               mul
   *  toDecimalPlaces                     todp
   *  toExponential
   *  toFixed
   *  toInteger                           toint
   *  toNumber
   *  toPower                             pow
   *  toPrecision
   *  toSignificantDigits                 tosd
   *  toString
   *  valueOf                             val
   */


  /*
   * Return a new Decimal whose value is the absolute value of this Decimal.
   *
   */
  P.absoluteValue = P.abs = function () {
    var x = new this.constructor(this);
    if (x.s) x.s = 1;
    return x;
  };


  /*
   * Return
   *   1    if the value of this Decimal is greater than the value of `y`,
   *  -1    if the value of this Decimal is less than the value of `y`,
   *   0    if they have the same value
   *
   */
  P.comparedTo = P.cmp = function (y) {
    var i, j, xdL, ydL,
      x = this;

    y = new x.constructor(y);

    // Signs differ?
    if (x.s !== y.s) return x.s || -y.s;

    // Compare exponents.
    if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;

    xdL = x.d.length;
    ydL = y.d.length;

    // Compare digit by digit.
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (x.d[i] !== y.d[i]) return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
    }

    // Compare lengths.
    return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
  };


  /*
   * Return the number of decimal places of the value of this Decimal.
   *
   */
  P.decimalPlaces = P.dp = function () {
    var x = this,
      w = x.d.length - 1,
      dp = (w - x.e) * LOG_BASE;

    // Subtract the number of trailing zeros of the last word.
    w = x.d[w];
    if (w) for (; w % 10 == 0; w /= 10) dp--;

    return dp < 0 ? 0 : dp;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, truncated to
   * `precision` significant digits.
   *
   */
  P.dividedBy = P.div = function (y) {
    return divide(this, new this.constructor(y));
  };


  /*
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
   * by the value of `y`, truncated to `precision` significant digits.
   *
   */
  P.dividedToIntegerBy = P.idiv = function (y) {
    var x = this,
      Ctor = x.constructor;
    return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);
  };


  /*
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
   *
   */
  P.equals = P.eq = function (y) {
    return !this.cmp(y);
  };


  /*
   * Return the (base 10) exponent value of this Decimal (this.e is the base 10000000 exponent).
   *
   */
  P.exponent = function () {
    return getBase10Exponent(this);
  };


  /*
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
   * false.
   *
   */
  P.greaterThan = P.gt = function (y) {
    return this.cmp(y) > 0;
  };


  /*
   * Return true if the value of this Decimal is greater than or equal to the value of `y`,
   * otherwise return false.
   *
   */
  P.greaterThanOrEqualTo = P.gte = function (y) {
    return this.cmp(y) >= 0;
  };


  /*
   * Return true if the value of this Decimal is an integer, otherwise return false.
   *
   */
  P.isInteger = P.isint = function () {
    return this.e > this.d.length - 2;
  };


  /*
   * Return true if the value of this Decimal is negative, otherwise return false.
   *
   */
  P.isNegative = P.isneg = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this Decimal is positive, otherwise return false.
   *
   */
  P.isPositive = P.ispos = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this Decimal is 0, otherwise return false.
   *
   */
  P.isZero = function () {
    return this.s === 0;
  };


  /*
   * Return true if the value of this Decimal is less than `y`, otherwise return false.
   *
   */
  P.lessThan = P.lt = function (y) {
    return this.cmp(y) < 0;
  };


  /*
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
   *
   */
  P.lessThanOrEqualTo = P.lte = function (y) {
    return this.cmp(y) < 1;
  };


  /*
   * Return the logarithm of the value of this Decimal to the specified base, truncated to
   * `precision` significant digits.
   *
   * If no base is specified, return log[10](x).
   *
   * log[base](x) = ln(x) / ln(base)
   *
   * The maximum error of the result is 1 ulp (unit in the last place).
   *
   * [base] {number|string|Decimal} The base of the logarithm.
   *
   */
  P.logarithm = P.log = function (base) {
    var r,
      x = this,
      Ctor = x.constructor,
      pr = Ctor.precision,
      wpr = pr + 5;

    // Default base is 10.
    if (base === void 0) {
      base = new Ctor(10);
    } else {
      base = new Ctor(base);

      // log[-b](x) = NaN
      // log[0](x)  = NaN
      // log[1](x)  = NaN
      if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + 'NaN');
    }

    // log[b](-x) = NaN
    // log[b](0) = -Infinity
    if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));

    // log[b](1) = 0
    if (x.eq(ONE)) return new Ctor(0);

    external = false;
    r = divide(ln(x, wpr), ln(base, wpr), wpr);
    external = true;

    return round(r, pr);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal minus `y`, truncated to
   * `precision` significant digits.
   *
   */
  P.minus = P.sub = function (y) {
    var x = this;
    y = new x.constructor(y);
    return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, truncated to
   * `precision` significant digits.
   *
   */
  P.modulo = P.mod = function (y) {
    var q,
      x = this,
      Ctor = x.constructor,
      pr = Ctor.precision;

    y = new Ctor(y);

    // x % 0 = NaN
    if (!y.s) throw Error(decimalError + 'NaN');

    // Return x if x is 0.
    if (!x.s) return round(new Ctor(x), pr);

    // Prevent rounding of intermediate calculations.
    external = false;
    q = divide(x, y, 0, 1).times(y);
    external = true;

    return x.minus(q);
  };


  /*
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
   * i.e. the base e raised to the power the value of this Decimal, truncated to `precision`
   * significant digits.
   *
   */
  P.naturalExponential = P.exp = function () {
    return exp(this);
  };


  /*
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
   * truncated to `precision` significant digits.
   *
   */
  P.naturalLogarithm = P.ln = function () {
    return ln(this);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
   * -1.
   *
   */
  P.negated = P.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s || 0;
    return x;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal plus `y`, truncated to
   * `precision` significant digits.
   *
   */
  P.plus = P.add = function (y) {
    var x = this;
    y = new x.constructor(y);
    return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
  };


  /*
   * Return the number of significant digits of the value of this Decimal.
   *
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
   *
   */
  P.precision = P.sd = function (z) {
    var e, sd, w,
      x = this;

    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

    e = getBase10Exponent(x) + 1;
    w = x.d.length - 1;
    sd = w * LOG_BASE + 1;
    w = x.d[w];

    // If non-zero...
    if (w) {

      // Subtract the number of trailing zeros of the last word.
      for (; w % 10 == 0; w /= 10) sd--;

      // Add the number of digits of the first word.
      for (w = x.d[0]; w >= 10; w /= 10) sd++;
    }

    return z && e > sd ? e : sd;
  };


  /*
   * Return a new Decimal whose value is the square root of this Decimal, truncated to `precision`
   * significant digits.
   *
   */
  P.squareRoot = P.sqrt = function () {
    var e, n, pr, r, s, t, wpr,
      x = this,
      Ctor = x.constructor;

    // Negative or zero?
    if (x.s < 1) {
      if (!x.s) return new Ctor(0);

      // sqrt(-x) = NaN
      throw Error(decimalError + 'NaN');
    }

    e = getBase10Exponent(x);
    external = false;

    // Initial estimate.
    s = Math.sqrt(+x);

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(x.d);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }

    pr = Ctor.precision;
    s = wpr = pr + 3;

    // Newton-Raphson iteration.
    for (;;) {
      t = r;
      r = t.plus(divide(x, t, wpr + 2)).times(0.5);

      if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
        n = n.slice(wpr - 3, wpr + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
        // 4999, i.e. approaching a rounding boundary, continue the iteration.
        if (s == wpr && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          round(t, pr + 1, 0);

          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        } else if (n != '9999') {
          break;
        }

        wpr += 4;
      }
    }

    external = true;

    return round(r, pr);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal times `y`, truncated to
   * `precision` significant digits.
   *
   */
  P.times = P.mul = function (y) {
    var carry, e, i, k, r, rL, t, xdL, ydL,
      x = this,
      Ctor = x.constructor,
      xd = x.d,
      yd = (y = new Ctor(y)).d;

    // Return 0 if either is 0.
    if (!x.s || !y.s) return new Ctor(0);

    y.s *= x.s;
    e = x.e + y.e;
    xdL = xd.length;
    ydL = yd.length;

    // Ensure xd points to the longer array.
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }

    // Initialise the result array with zeros.
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--;) r.push(0);

    // Multiply!
    for (i = ydL; --i >= 0;) {
      carry = 0;
      for (k = xdL + i; k > i;) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }

      r[k] = (r[k] + carry) % BASE | 0;
    }

    // Remove trailing zeros.
    for (; !r[--rL];) r.pop();

    if (carry) ++e;
    else r.shift();

    y.d = r;
    y.e = e;

    return external ? round(y, Ctor.precision) : y;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
   *
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toDecimalPlaces = P.todp = function (dp, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);
    if (dp === void 0) return x;

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    return round(x, dp + getBase10Exponent(x) + 1, rm);
  };


  /*
   * Return a string representing the value of this Decimal in exponential notation rounded to
   * `dp` fixed decimal places using rounding mode `rounding`.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toExponential = function (dp, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = toString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = round(new Ctor(x), dp + 1, rm);
      str = toString(x, true, dp + 1);
    }

    return str;
  };


  /*
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
   * omitted.
   *
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   * (-0).toFixed(3) is '0.000'.
   * (-0.5).toFixed(0) is '-0'.
   *
   */
  P.toFixed = function (dp, rm) {
    var str, y,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) return toString(x);

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    y = round(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);
    str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);

    // To determine whether to add the minus sign look at the value before it was rounded,
    // i.e. look at `x` rather than `y`.
    return x.isneg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
   * rounding mode `rounding`.
   *
   */
  P.toInteger = P.toint = function () {
    var x = this,
      Ctor = x.constructor;
    return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
  };


  /*
   * Return the value of this Decimal converted to a number primitive.
   *
   */
  P.toNumber = function () {
    return +this;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`,
   * truncated to `precision` significant digits.
   *
   * For non-integer or very large exponents pow(x, y) is calculated using
   *
   *   x^y = exp(y*ln(x))
   *
   * The maximum error is 1 ulp (unit in last place).
   *
   * y {number|string|Decimal} The power to which to raise this Decimal.
   *
   */
  P.toPower = P.pow = function (y) {
    var e, k, pr, r, sign, yIsInt,
      x = this,
      Ctor = x.constructor,
      guard = 12,
      yn = +(y = new Ctor(y));

    // pow(x, 0) = 1
    if (!y.s) return new Ctor(ONE);

    x = new Ctor(x);

    // pow(0, y > 0) = 0
    // pow(0, y < 0) = Infinity
    if (!x.s) {
      if (y.s < 1) throw Error(decimalError + 'Infinity');
      return x;
    }

    // pow(1, y) = 1
    if (x.eq(ONE)) return x;

    pr = Ctor.precision;

    // pow(x, 1) = x
    if (y.eq(ONE)) return round(x, pr);

    e = y.e;
    k = y.d.length - 1;
    yIsInt = e >= k;
    sign = x.s;

    if (!yIsInt) {

      // pow(x < 0, y non-integer) = NaN
      if (sign < 0) throw Error(decimalError + 'NaN');

    // If y is a small integer use the 'exponentiation by squaring' algorithm.
    } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = new Ctor(ONE);

      // Max k of 9007199254740991 takes 53 loop iterations.
      // Maximum digits array length; leaves [28, 34] guard digits.
      e = Math.ceil(pr / LOG_BASE + 4);

      external = false;

      for (;;) {
        if (k % 2) {
          r = r.times(x);
          truncate(r.d, e);
        }

        k = mathfloor(k / 2);
        if (k === 0) break;

        x = x.times(x);
        truncate(x.d, e);
      }

      external = true;

      return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr);
    }

    // Result is negative if x is negative and the last digit of integer y is odd.
    sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;

    x.s = 1;
    external = false;
    r = y.times(ln(x, pr + guard));
    external = true;
    r = exp(r);
    r.s = sign;

    return r;
  };


  /*
   * Return a string representing the value of this Decimal rounded to `sd` significant digits
   * using rounding mode `rounding`.
   *
   * Return exponential notation if `sd` is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toPrecision = function (sd, rm) {
    var e, str,
      x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      e = getBase10Exponent(x);
      str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = round(new Ctor(x), sd, rm);
      e = getBase10Exponent(x);
      str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
    }

    return str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
   * omitted.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toSignificantDigits = P.tosd = function (sd, rm) {
    var x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    }

    return round(new Ctor(x), sd, rm);
  };


  /*
   * Return a string representing the value of this Decimal.
   *
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
   *
   */
  P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for('nodejs.util.inspect.custom')] = function () {
    var x = this,
      e = getBase10Exponent(x),
      Ctor = x.constructor;

    return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  };


  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


  /*
   *  add                 P.minus, P.plus
   *  checkInt32          P.todp, P.toExponential, P.toFixed, P.toPrecision, P.tosd
   *  digitsToString      P.log, P.sqrt, P.pow, toString, exp, ln
   *  divide              P.div, P.idiv, P.log, P.mod, P.sqrt, exp, ln
   *  exp                 P.exp, P.pow
   *  getBase10Exponent   P.exponent, P.sd, P.toint, P.sqrt, P.todp, P.toFixed, P.toPrecision,
   *                      P.toString, divide, round, toString, exp, ln
   *  getLn10             P.log, ln
   *  getZeroString       digitsToString, toString
   *  ln                  P.log, P.ln, P.pow, exp
   *  parseDecimal        Decimal
   *  round               P.abs, P.idiv, P.log, P.minus, P.mod, P.neg, P.plus, P.toint, P.sqrt,
   *                      P.times, P.todp, P.toExponential, P.toFixed, P.pow, P.toPrecision, P.tosd,
   *                      divide, getLn10, exp, ln
   *  subtract            P.minus, P.plus
   *  toString            P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf
   *  truncate            P.pow
   *
   *  Throws:             P.log, P.mod, P.sd, P.sqrt, P.pow,  checkInt32, divide, round,
   *                      getLn10, exp, ln, parseDecimal, Decimal, config
   */


  function add(x, y) {
    var carry, d, e, i, k, len, xd, yd,
      Ctor = x.constructor,
      pr = Ctor.precision;

    // If either is zero...
    if (!x.s || !y.s) {

      // Return x if y is zero.
      // Return y if y is non-zero.
      if (!y.s) y = new Ctor(x);
      return external ? round(y, pr) : y;
    }

    xd = x.d;
    yd = y.d;

    // x and y are finite, non-zero numbers with the same sign.

    k = x.e;
    e = y.e;
    xd = xd.slice();
    i = k - e;

    // If base 1e7 exponents differ...
    if (i) {
      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }

      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;

      if (i > len) {
        i = len;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
      d.reverse();
      for (; i--;) d.push(0);
      d.reverse();
    }

    len = xd.length;
    i = yd.length;

    // If yd is longer than xd, swap xd and yd so xd points to the longer array.
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }

    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
    for (carry = 0; i;) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }

    if (carry) {
      xd.unshift(carry);
      ++e;
    }

    // Remove trailing zeros.
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    for (len = xd.length; xd[--len] == 0;) xd.pop();

    y.d = xd;
    y.e = e;

    return external ? round(y, pr) : y;
  }


  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }


  function digitsToString(d) {
    var i, k, ws,
      indexOfLastWord = d.length - 1,
      str = '',
      w = d[0];

    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
        str += ws;
      }

      w = d[i];
      ws = w + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return '0';
    }

    // Remove trailing zeros of last w.
    for (; w % 10 === 0;) w /= 10;

    return str + w;
  }


  var divide = (function () {

    // Assumes non-zero x and k, and hence non-zero result.
    function multiplyInteger(x, k) {
      var temp,
        carry = 0,
        i = x.length;

      for (x = x.slice(); i--;) {
        temp = x[i] * k + carry;
        x[i] = temp % BASE | 0;
        carry = temp / BASE | 0;
      }

      if (carry) x.unshift(carry);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, r;

      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return r;
    }

    function subtract(a, b, aL) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * BASE + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1;) a.shift();
    }

    return function (x, y, pr, dp) {
      var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz,
        Ctor = x.constructor,
        sign = x.s == y.s ? 1 : -1,
        xd = x.d,
        yd = y.d;

      // Either 0?
      if (!x.s) return new Ctor(x);
      if (!y.s) throw Error(decimalError + 'Division by zero');

      e = x.e - y.e;
      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign);
      qd = q.d = [];

      // Result exponent may be one less than e.
      for (i = 0; yd[i] == (xd[i] || 0); ) ++i;
      if (yd[i] > (xd[i] || 0)) --e;

      if (pr == null) {
        sd = pr = Ctor.precision;
      } else if (dp) {
        sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
      } else {
        sd = pr;
      }

      if (sd < 0) return new Ctor(0);

      // Convert precision in number of base 10 digits to base 1e7 digits.
      sd = sd / LOG_BASE + 2 | 0;
      i = 0;

      // divisor < 1e7
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;

        // k is the carry.
        for (; (i < xL || k) && sd--; i++) {
          t = k * BASE + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }

      // divisor >= 1e7
      } else {

        // Normalise xd and yd so highest order digit of yd is >= BASE/2
        k = BASE / (yd[0] + 1) | 0;

        if (k > 1) {
          yd = multiplyInteger(yd, k);
          xd = multiplyInteger(xd, k);
          yL = yd.length;
          xL = xd.length;
        }

        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;

        // Add zeros to make remainder as long as divisor.
        for (; remL < yL;) rem[remL++] = 0;

        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];

        if (yd[1] >= BASE / 2) ++yd0;

        do {
          k = 0;

          // Compare divisor and remainder.
          cmp = compare(yd, rem, yL, remL);

          // If divisor < remainder.
          if (cmp < 0) {

            // Calculate trial digit, k.
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);

            // k will be how many times the divisor goes into the current remainder.
            k = rem0 / yd0 | 0;

            //  Algorithm:
            //  1. product = divisor * trial digit (k)
            //  2. if product > remainder: product -= divisor, k--
            //  3. remainder -= product
            //  4. if product was < remainder at 2:
            //    5. compare new remainder and divisor
            //    6. If remainder > divisor: remainder -= divisor, k++

            if (k > 1) {
              if (k >= BASE) k = BASE - 1;

              // product = divisor * trial digit.
              prod = multiplyInteger(yd, k);
              prodL = prod.length;
              remL = rem.length;

              // Compare product and remainder.
              cmp = compare(prod, rem, prodL, remL);

              // product > remainder.
              if (cmp == 1) {
                k--;

                // Subtract divisor from product.
                subtract(prod, yL < prodL ? yz : yd, prodL);
              }
            } else {

              // cmp is -1.
              // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
              // to avoid it. If k is 1 there is a need to compare yd and rem again below.
              if (k == 0) cmp = k = 1;
              prod = yd.slice();
            }

            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);

            // Subtract product from remainder.
            subtract(rem, prod, remL);

            // If product was < previous remainder.
            if (cmp == -1) {
              remL = rem.length;

              // Compare divisor and new remainder.
              cmp = compare(yd, rem, yL, remL);

              // If divisor < new remainder, subtract divisor from remainder.
              if (cmp < 1) {
                k++;

                // Subtract divisor from remainder.
                subtract(rem, yL < remL ? yz : yd, remL);
              }
            }

            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }    // if cmp === 1, k will be 0

          // Add the next digit, k, to the result array.
          qd[i++] = k;

          // Update the remainder.
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }

        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
      }

      // Leading zero?
      if (!qd[0]) qd.shift();

      q.e = e;

      return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
    };
  })();


  /*
   * Return a new Decimal whose value is the natural exponential of `x` truncated to `sd`
   * significant digits.
   *
   * Taylor/Maclaurin series.
   *
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
   *
   * Argument reduction:
   *   Repeat x = x / 32, k += 5, until |x| < 0.1
   *   exp(x) = exp(x / 2^k)^(2^k)
   *
   * Previously, the argument was initially reduced by
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
   * found to be slower than just dividing repeatedly by 32 as above.
   *
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
   *
   *  exp(x) is non-terminating for any finite, non-zero x.
   *
   */
  function exp(x, sd) {
    var denominator, guard, pow, sum, t, wpr,
      i = 0,
      k = 0,
      Ctor = x.constructor,
      pr = Ctor.precision;

    if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));

    // exp(0) = 1
    if (!x.s) return new Ctor(ONE);

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    t = new Ctor(0.03125);

    while (x.abs().gte(0.1)) {
      x = x.times(t);    // x = x / 2^5
      k += 5;
    }

    // Estimate the precision increase necessary to ensure the first 4 rounding digits are correct.
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(ONE);
    Ctor.precision = wpr;

    for (;;) {
      pow = round(pow.times(x), wpr);
      denominator = denominator.times(++i);
      t = sum.plus(divide(pow, denominator, wpr));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        while (k--) sum = round(sum.times(sum), wpr);
        Ctor.precision = pr;
        return sd == null ? (external = true, round(sum, pr)) : sum;
      }

      sum = t;
    }
  }


  // Calculate the base 10 exponent from the base 1e7 exponent.
  function getBase10Exponent(x) {
    var e = x.e * LOG_BASE,
      w = x.d[0];

    // Add the number of digits of the first word of the digits array.
    for (; w >= 10; w /= 10) e++;
    return e;
  }


  function getLn10(Ctor, sd, pr) {

    if (sd > Ctor.LN10.sd()) {


      // Reset global state in case the exception is caught.
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(decimalError + 'LN10 precision limit exceeded');
    }

    return round(new Ctor(Ctor.LN10), sd);
  }


  function getZeroString(k) {
    var zs = '';
    for (; k--;) zs += '0';
    return zs;
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x` truncated to `sd` significant
   * digits.
   *
   *  ln(n) is non-terminating (n != 1)
   *
   */
  function ln(y, sd) {
    var c, c0, denominator, e, numerator, sum, t, wpr, x2,
      n = 1,
      guard = 10,
      x = y,
      xd = x.d,
      Ctor = x.constructor,
      pr = Ctor.precision;

    // ln(-x) = NaN
    // ln(0) = -Infinity
    if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));

    // ln(1) = 0
    if (x.eq(ONE)) return new Ctor(0);

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    if (x.eq(10)) {
      if (sd == null) external = true;
      return getLn10(Ctor, wpr);
    }

    wpr += guard;
    Ctor.precision = wpr;
    c = digitsToString(xd);
    c0 = c.charAt(0);
    e = getBase10Exponent(x);

    if (Math.abs(e) < 1.5e15) {

      // Argument reduction.
      // The series converges faster the closer the argument is to 1, so using
      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
      // later be divided by this number, then separate out the power of 10 using
      // ln(a*10^b) = ln(a) + b*ln(10).

      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
      // max n is 6 (gives 0.7 - 1.3)
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }

      e = getBase10Exponent(x);

      if (c0 > 1) {
        x = new Ctor('0.' + c);
        e++;
      } else {
        x = new Ctor(c0 + '.' + c.slice(1));
      }
    } else {

      // The argument reduction method above may result in overflow if the argument y is a massive
      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
      // function using ln(x*10^e) = ln(x) + e*ln(10).
      t = getLn10(Ctor, wpr + 2, pr).times(e + '');
      x = ln(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);

      Ctor.precision = pr;
      return sd == null ? (external = true, round(x, pr)) : x;
    }

    // x is reduced to a value near 1.

    // Taylor series.
    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
    // where x = (y - 1)/(y + 1)    (|x| < 1)
    sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
    x2 = round(x.times(x), wpr);
    denominator = 3;

    for (;;) {
      numerator = round(numerator.times(x2), wpr);
      t = sum.plus(divide(numerator, new Ctor(denominator), wpr));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2);

        // Reverse the argument reduction.
        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
        sum = divide(sum, new Ctor(n), wpr);

        Ctor.precision = pr;
        return sd == null ? (external = true, round(sum, pr)) : sum;
      }

      sum = t;
      denominator += 2;
    }
  }


  /*
   * Parse the value of a new Decimal `x` from string `str`.
   */
  function parseDecimal(x, str) {
    var e, i, len;

    // Decimal point?
    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

    // Exponential form?
    if ((i = str.search(/e/i)) > 0) {

      // Determine exponent.
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {

      // Integer.
      e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48;) ++i;

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;
    str = str.slice(i, len);

    if (str) {
      len -= i;
      e = e - i - 1;
      x.e = mathfloor(e / LOG_BASE);
      x.d = [];

      // Transform base

      // e is the base 10 exponent.
      // i is where to slice str to get the first word of the digits array.
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;

      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }

      for (; i--;) str += '0';
      x.d.push(+str);

      if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e);
    } else {

      // Zero.
      x.s = 0;
      x.e = 0;
      x.d = [0];
    }

    return x;
  }


  /*
   * Round `x` to `sd` significant digits, using rounding mode `rm` if present (truncate otherwise).
   */
   function round(x, sd, rm) {
    var i, j, k, n, rd, doRound, w, xdi,
      xd = x.d;

    // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
    // w: the word of xd which contains the rounding digit, a base 1e7 number.
    // xdi: the index of w within xd.
    // n: the number of digits of w.
    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
    // they had leading zeros)
    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

    // Get the length of the first word of the digits array xd.
    for (n = 1, k = xd[0]; k >= 10; k /= 10) n++;
    i = sd - n;

    // Is the rounding digit in the first word of xd?
    if (i < 0) {
      i += LOG_BASE;
      j = sd;
      w = xd[xdi = 0];
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd.length;
      if (xdi >= k) return x;
      w = k = xd[xdi];

      // Get the number of digits of w.
      for (n = 1; k >= 10; k /= 10) n++;

      // Get the index of rd within w.
      i %= LOG_BASE;

      // Get the index of rd within w, adjusted for leading zeros.
      // The number of leading zeros of w is given by LOG_BASE - n.
      j = i - LOG_BASE + n;
    }

    if (rm !== void 0) {
      k = mathpow(10, n - j - 1);

      // Get the rounding digit at index j of w.
      rd = w / k % 10 | 0;

      // Are there any non-zero digits after the rounding digit?
      doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;

      // The expression `w % mathpow(10, n - j - 1)` returns all the digits of w to the right of the
      // digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression will give
      // 714.

      doRound = rm < 4
        ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
        : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
            rm == (x.s < 0 ? 8 : 7));
    }

    if (sd < 1 || !xd[0]) {
      if (doRound) {
        k = getBase10Exponent(x);
        xd.length = 1;

        // Convert sd to decimal places.
        sd = sd - k - 1;

        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x.e = mathfloor(-sd / LOG_BASE) || 0;
      } else {
        xd.length = 1;

        // Zero.
        xd[0] = x.e = x.s = 0;
      }

      return x;
    }

    // Remove excess digits.
    if (i == 0) {
      xd.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);

      // E.g. 56700 becomes 56000 if 7 is the rounding digit.
      // j > 0 means i > number of leading zeros of w.
      xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
    }

    if (doRound) {
      for (;;) {

        // Is the digit to be rounded up in the first word of xd?
        if (xdi == 0) {
          if ((xd[0] += k) == BASE) {
            xd[0] = 1;
            ++x.e;
          }

          break;
        } else {
          xd[xdi] += k;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k = 1;
        }
      }
    }

    // Remove trailing zeros.
    for (i = xd.length; xd[--i] === 0;) xd.pop();

    if (external && (x.e > MAX_E || x.e < -MAX_E)) {
      throw Error(exponentOutOfRange + getBase10Exponent(x));
    }

    return x;
  }


  function subtract(x, y) {
    var d, e, i, j, k, len, xd, xe, xLTy, yd,
      Ctor = x.constructor,
      pr = Ctor.precision;

    // Return y negated if x is zero.
    // Return x if y is zero and x is non-zero.
    if (!x.s || !y.s) {
      if (y.s) y.s = -y.s;
      else y = new Ctor(x);
      return external ? round(y, pr) : y;
    }

    xd = x.d;
    yd = y.d;

    // x and y are non-zero numbers with the same sign.

    e = y.e;
    xe = x.e;
    xd = xd.slice();
    k = xe - e;

    // If exponents differ...
    if (k) {
      xLTy = k < 0;

      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }

      // Numbers with massively different exponents would result in a very high number of zeros
      // needing to be prepended, but this can be avoided while still ensuring correct rounding by
      // limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

      if (k > i) {
        k = i;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents.
      d.reverse();
      for (i = k; i--;) d.push(0);
      d.reverse();

    // Base 1e7 exponents equal.
    } else {

      // Check digits to determine which is the bigger number.

      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;

      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }

      k = 0;
    }

    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }

    len = xd.length;

    // Append zeros to xd if shorter.
    // Don't add zeros to yd if shorter as subtraction only needs to start at yd length.
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

    // Subtract yd from xd.
    for (i = yd.length; i > k;) {
      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }

      xd[i] -= yd[i];
    }

    // Remove trailing zeros.
    for (; xd[--len] === 0;) xd.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xd[0] === 0; xd.shift()) --e;

    // Zero?
    if (!xd[0]) return new Ctor(0);

    y.d = xd;
    y.e = e;

    //return external && xd.length >= pr / LOG_BASE ? round(y, pr) : y;
    return external ? round(y, pr) : y;
  }


  function toString(x, isExp, sd) {
    var k,
      e = getBase10Exponent(x),
      str = digitsToString(x.d),
      len = str.length;

    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + '.' + str.slice(1);
      }

      str = str + (e < 0 ? 'e' : 'e+') + e;
    } else if (e < 0) {
      str = '0.' + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len) str += '.';
        str += getZeroString(k);
      }
    }

    return x.s < 0 ? '-' + str : str;
  }


  // Does not strip trailing zeros.
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }


  // Decimal methods


  /*
   *  clone
   *  config/set
   */


  /*
   * Create and return a Decimal constructor with the same configuration properties as this Decimal
   * constructor.
   *
   */
  function clone(obj) {
    var i, p, ps;

    /*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * value {number|string|Decimal} A numeric value.
     *
     */
    function Decimal(value) {
      var x = this;

      // Decimal called without new.
      if (!(x instanceof Decimal)) return new Decimal(value);

      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
      // which points to Object.
      x.constructor = Decimal;

      // Duplicate.
      if (value instanceof Decimal) {
        x.s = value.s;
        x.e = value.e;
        x.d = (value = value.d) ? value.slice() : value;
        return;
      }

      if (typeof value === 'number') {

        // Reject Infinity/NaN.
        if (value * 0 !== 0) {
          throw Error(invalidArgument + value);
        }

        if (value > 0) {
          x.s = 1;
        } else if (value < 0) {
          value = -value;
          x.s = -1;
        } else {
          x.s = 0;
          x.e = 0;
          x.d = [0];
          return;
        }

        // Fast path for small integers.
        if (value === ~~value && value < 1e7) {
          x.e = 0;
          x.d = [value];
          return;
        }

        return parseDecimal(x, value.toString());
      } else if (typeof value !== 'string') {
        throw Error(invalidArgument + value);
      }

      // Minus sign?
      if (value.charCodeAt(0) === 45) {
        value = value.slice(1);
        x.s = -1;
      } else {
        x.s = 1;
      }

      if (isDecimal.test(value)) parseDecimal(x, value);
      else throw Error(invalidArgument + value);
    }

    Decimal.prototype = P;

    Decimal.ROUND_UP = 0;
    Decimal.ROUND_DOWN = 1;
    Decimal.ROUND_CEIL = 2;
    Decimal.ROUND_FLOOR = 3;
    Decimal.ROUND_HALF_UP = 4;
    Decimal.ROUND_HALF_DOWN = 5;
    Decimal.ROUND_HALF_EVEN = 6;
    Decimal.ROUND_HALF_CEIL = 7;
    Decimal.ROUND_HALF_FLOOR = 8;

    Decimal.clone = clone;
    Decimal.config = Decimal.set = config;

    if (obj === void 0) obj = {};
    if (obj) {
      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'LN10'];
      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }

    Decimal.config(obj);

    return Decimal;
  }


  /*
   * Configure global settings for a Decimal constructor.
   *
   * `obj` is an object with one or more of the following properties,
   *
   *   precision  {number}
   *   rounding   {number}
   *   toExpNeg   {number}
   *   toExpPos   {number}
   *
   * E.g. Decimal.config({ precision: 20, rounding: 4 })
   *
   */
  function config(obj) {
    if (!obj || typeof obj !== 'object') {
      throw Error(decimalError + 'Object expected');
    }
    var i, p, v,
      ps = [
        'precision', 1, MAX_DIGITS,
        'rounding', 0, 8,
        'toExpNeg', -1 / 0, 0,
        'toExpPos', 0, 1 / 0
      ];

    for (i = 0; i < ps.length; i += 3) {
      if ((v = obj[p = ps[i]]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ': ' + v);
      }
    }

    if ((v = obj[p = 'LN10']) !== void 0) {
        if (v == Math.LN10) this[p] = new this(v);
        else throw Error(invalidArgument + p + ': ' + v);
    }

    return this;
  }


  // Create and configure initial Decimal constructor.
  var Decimal = clone(defaults);

  // Internal constant.
  ONE = new Decimal(1);

  var Decimal$1 = Decimal;

  var decimal = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get Decimal () { return Decimal; },
    'default': Decimal$1
  });

  var utils = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.memoize = exports.reverse = exports.compose = exports.map = exports.range = exports.curry = exports.PLACE_HOLDER = void 0;

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  var identity = function identity(i) {
    return i;
  };

  var PLACE_HOLDER = {
    '@@functional/placeholder': true
  };
  exports.PLACE_HOLDER = PLACE_HOLDER;

  var isPlaceHolder = function isPlaceHolder(val) {
    return val === PLACE_HOLDER;
  };

  var curry0 = function curry0(fn) {
    return function _curried() {
      if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? undefined : arguments[0])) {
        return _curried;
      }

      return fn.apply(void 0, arguments);
    };
  };

  var curryN = function curryN(n, fn) {
    if (n === 1) {
      return fn;
    }

    return curry0(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var argsLength = args.filter(function (arg) {
        return arg !== PLACE_HOLDER;
      }).length;

      if (argsLength >= n) {
        return fn.apply(void 0, args);
      }

      return curryN(n - argsLength, curry0(function () {
        for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          restArgs[_key2] = arguments[_key2];
        }

        var newArgs = args.map(function (arg) {
          return isPlaceHolder(arg) ? restArgs.shift() : arg;
        });
        return fn.apply(void 0, _toConsumableArray(newArgs).concat(restArgs));
      }));
    });
  };

  var curry = function curry(fn) {
    return curryN(fn.length, fn);
  };

  exports.curry = curry;

  var range = function range(begin, end) {
    var arr = [];

    for (var i = begin; i < end; ++i) {
      arr[i - begin] = i;
    }

    return arr;
  };

  exports.range = range;
  var map = curry(function (fn, arr) {
    if (Array.isArray(arr)) {
      return arr.map(fn);
    }

    return Object.keys(arr).map(function (key) {
      return arr[key];
    }).map(fn);
  });
  exports.map = map;

  var compose = function compose() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    if (!args.length) {
      return identity;
    }

    var fns = args.reverse(); // first function can receive multiply arguments

    var firstFn = fns[0];
    var tailsFn = fns.slice(1);
    return function () {
      return tailsFn.reduce(function (res, fn) {
        return fn(res);
      }, firstFn.apply(void 0, arguments));
    };
  };

  exports.compose = compose;

  var reverse = function reverse(arr) {
    if (Array.isArray(arr)) {
      return arr.reverse();
    } // can be string


    return arr.split('').reverse.join('');
  };

  exports.reverse = reverse;

  var memoize = function memoize(fn) {
    var lastArgs = null;
    var lastResult = null;
    return function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      if (lastArgs && args.every(function (val, i) {
        return val === lastArgs[i];
      })) {
        return lastResult;
      }

      lastArgs = args;
      lastResult = fn.apply(void 0, args);
      return lastResult;
    };
  };

  exports.memoize = memoize;
  });

  unwrapExports(utils);
  utils.memoize;
  utils.reverse;
  utils.compose;
  utils.map;
  utils.range;
  utils.curry;
  utils.PLACE_HOLDER;

  var require$$0 = getCjsExportFromNamespace(decimal);

  var arithmetic = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _decimal = _interopRequireDefault(require$$0);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * @fileOverview 
   * @author xile611
   * @date 2015-09-17
   */

  /**
   * 
   * [0.1, 1) 0
   * [0.01, 0.1) -1
   * [0.001, 0.01) -2
   *
   * @param  {Number} value 
   * @return {Integer} 
   */
  function getDigitCount(value) {
    var result;

    if (value === 0) {
      result = 1;
    } else {
      result = Math.floor(new _decimal.default(value).abs().log(10).toNumber()) + 1;
    }

    return result;
  }
  /**
   * [start, end)
   * js
   *
   * @param  {Decimal} start 
   * @param  {Decimal} end   
   * @param  {Decimal} step  
   * @return {Array}         
   */


  function rangeStep(start, end, step) {
    var num = new _decimal.default(start);
    var i = 0;
    var result = []; // magic number to prevent infinite loop

    while (num.lt(end) && i < 100000) {
      result.push(num.toNumber());
      num = num.add(step);
      i++;
    }

    return result;
  }
  /**
   * 
   *
   * @param  {Number} a  
   * @param  {Number} b  
   * @param  {Number} t  [0, 1]
   * @return {Number}    
   */


  var interpolateNumber = (0, utils.curry)(function (a, b, t) {
    var newA = +a;
    var newB = +b;
    return newA + t * (newB - newA);
  });
  /**
   * 
   *
   * @param  {Number} a 
   * @param  {Number} b 
   * @param  {Number} x 
   * @return {Number}   x a ~ b[0, 1]
   */

  var uninterpolateNumber = (0, utils.curry)(function (a, b, x) {
    var diff = b - +a;
    diff = diff || Infinity;
    return (x - a) / diff;
  });
  /**
   * 
   *
   * @param  {Number} a 
   * @param  {Number} b 
   * @param  {Number} x 
   * @return {Number}   x a ~ b[0, 1]
   * x a ~ b a ~ b 
   */

  var uninterpolateTruncation = (0, utils.curry)(function (a, b, x) {
    var diff = b - +a;
    diff = diff || Infinity;
    return Math.max(0, Math.min(1, (x - a) / diff));
  });
  var _default = {
    rangeStep: rangeStep,
    getDigitCount: getDigitCount,
    interpolateNumber: interpolateNumber,
    uninterpolateNumber: uninterpolateNumber,
    uninterpolateTruncation: uninterpolateTruncation
  };
  exports.default = _default;
  });

  unwrapExports(arithmetic);

  var getNiceTickValues_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getTickValuesFixedDomain = exports.getTickValues = exports.getNiceTickValues = void 0;

  var _decimal = _interopRequireDefault(require$$0);



  var _arithmetic = _interopRequireDefault(arithmetic);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  /**
   * Calculate a interval of a minimum value and a maximum value
   *
   * @param  {Number} min       The minimum value
   * @param  {Number} max       The maximum value
   * @return {Array} An interval
   */
  function getValidInterval(_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        min = _ref2[0],
        max = _ref2[1];

    var validMin = min,
        validMax = max; // exchange

    if (min > max) {
      validMin = max;
      validMax = min;
    }

    return [validMin, validMax];
  }
  /**
   * Calculate the step which is easy to understand between ticks, like 10, 20, 25
   *
   * @param  {Decimal} roughStep        The rough step calculated by deviding the
   * difference by the tickCount
   * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not
   * @param  {Integer} correctionFactor A correction factor
   * @return {Decimal} The step which is easy to understand between two ticks
   */


  function getFormatStep(roughStep, allowDecimals, correctionFactor) {
    if (roughStep.lte(0)) {
      return new _decimal.default(0);
    }

    var digitCount = _arithmetic.default.getDigitCount(roughStep.toNumber()); // The ratio between the rough step and the smallest number which has a bigger
    // order of magnitudes than the rough step


    var digitCountValue = new _decimal.default(10).pow(digitCount);
    var stepRatio = roughStep.div(digitCountValue); // When an integer and a float multiplied, the accuracy of result may be wrong

    var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
    var amendStepRatio = new _decimal.default(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
    var formatStep = amendStepRatio.mul(digitCountValue);
    return allowDecimals ? formatStep : new _decimal.default(Math.ceil(formatStep));
  }
  /**
   * calculate the ticks when the minimum value equals to the maximum value
   *
   * @param  {Number}  value         The minimum valuue which is also the maximum value
   * @param  {Integer} tickCount     The count of ticks
   * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not
   * @return {Array}                 ticks
   */


  function getTickOfSingleValue(value, tickCount, allowDecimals) {
    var step = 1; // calculate the middle value of ticks

    var middle = new _decimal.default(value);

    if (!middle.isint() && allowDecimals) {
      var absVal = Math.abs(value);

      if (absVal < 1) {
        // The step should be a float number when the difference is smaller than 1
        step = new _decimal.default(10).pow(_arithmetic.default.getDigitCount(value) - 1);
        middle = new _decimal.default(Math.floor(middle.div(step).toNumber())).mul(step);
      } else if (absVal > 1) {
        // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1
        middle = new _decimal.default(Math.floor(value));
      }
    } else if (value === 0) {
      middle = new _decimal.default(Math.floor((tickCount - 1) / 2));
    } else if (!allowDecimals) {
      middle = new _decimal.default(Math.floor(value));
    }

    var middleIndex = Math.floor((tickCount - 1) / 2);
    var fn = (0, utils.compose)((0, utils.map)(function (n) {
      return middle.add(new _decimal.default(n - middleIndex).mul(step)).toNumber();
    }), utils.range);
    return fn(0, tickCount);
  }
  /**
   * Calculate the step
   *
   * @param  {Number}  min              The minimum value of an interval
   * @param  {Number}  max              The maximum value of an interval
   * @param  {Integer} tickCount        The count of ticks
   * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not
   * @param  {Number}  correctionFactor A correction factor
   * @return {Object}  The step, minimum value of ticks, maximum value of ticks
   */


  function calculateStep(min, max, tickCount, allowDecimals) {
    var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    // dirty hack (for recharts' test)
    if (!Number.isFinite((max - min) / (tickCount - 1))) {
      return {
        step: new _decimal.default(0),
        tickMin: new _decimal.default(0),
        tickMax: new _decimal.default(0)
      };
    } // The step which is easy to understand between two ticks


    var step = getFormatStep(new _decimal.default(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor); // A medial value of ticks

    var middle; // When 0 is inside the interval, 0 should be a tick

    if (min <= 0 && max >= 0) {
      middle = new _decimal.default(0);
    } else {
      // calculate the middle value
      middle = new _decimal.default(min).add(max).div(2); // minus modulo value

      middle = middle.sub(new _decimal.default(middle).mod(step));
    }

    var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());
    var upCount = Math.ceil(new _decimal.default(max).sub(middle).div(step).toNumber());
    var scaleCount = belowCount + upCount + 1;

    if (scaleCount > tickCount) {
      // When more ticks need to cover the interval, step should be bigger.
      return calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);
    }

    if (scaleCount < tickCount) {
      // When less ticks can cover the interval, we should add some additional ticks
      upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;
      belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);
    }

    return {
      step: step,
      tickMin: middle.sub(new _decimal.default(belowCount).mul(step)),
      tickMax: middle.add(new _decimal.default(upCount).mul(step))
    };
  }
  /**
   * Calculate the ticks of an interval, the count of ticks will be guraranteed
   *
   * @param  {Number}  min, max      min: The minimum value, max: The maximum value
   * @param  {Integer} tickCount     The count of ticks
   * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not
   * @return {Array}   ticks
   */


  function getNiceTickValuesFn(_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        min = _ref4[0],
        max = _ref4[1];

    var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
    var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    // More than two ticks should be return
    var count = Math.max(tickCount, 2);

    var _getValidInterval = getValidInterval([min, max]),
        _getValidInterval2 = _slicedToArray(_getValidInterval, 2),
        cormin = _getValidInterval2[0],
        cormax = _getValidInterval2[1];

    if (cormin === -Infinity || cormax === Infinity) {
      var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray((0, utils.range)(0, tickCount - 1).map(function () {
        return Infinity;
      }))) : _toConsumableArray((0, utils.range)(0, tickCount - 1).map(function () {
        return -Infinity;
      })).concat([cormax]);

      return min > max ? (0, utils.reverse)(_values) : _values;
    }

    if (cormin === cormax) {
      return getTickOfSingleValue(cormin, tickCount, allowDecimals);
    } // Get the step between two ticks


    var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals),
        step = _calculateStep.step,
        tickMin = _calculateStep.tickMin,
        tickMax = _calculateStep.tickMax;

    var values = _arithmetic.default.rangeStep(tickMin, tickMax.add(new _decimal.default(0.1).mul(step)), step);

    return min > max ? (0, utils.reverse)(values) : values;
  }
  /**
   * Calculate the ticks of an interval, the count of ticks won't be guraranteed
   *
   * @param  {Number}  min, max      min: The minimum value, max: The maximum value
   * @param  {Integer} tickCount     The count of ticks
   * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not
   * @return {Array}   ticks
   */


  function getTickValuesFn(_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        min = _ref6[0],
        max = _ref6[1];

    var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
    var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    // More than two ticks should be return
    var count = Math.max(tickCount, 2);

    var _getValidInterval3 = getValidInterval([min, max]),
        _getValidInterval4 = _slicedToArray(_getValidInterval3, 2),
        cormin = _getValidInterval4[0],
        cormax = _getValidInterval4[1];

    if (cormin === -Infinity || cormax === Infinity) {
      return [min, max];
    }

    if (cormin === cormax) {
      return getTickOfSingleValue(cormin, tickCount, allowDecimals);
    }

    var step = getFormatStep(new _decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
    var fn = (0, utils.compose)((0, utils.map)(function (n) {
      return new _decimal.default(cormin).add(new _decimal.default(n).mul(step)).toNumber();
    }), utils.range);
    var values = fn(0, count).filter(function (entry) {
      return entry >= cormin && entry <= cormax;
    });
    return min > max ? (0, utils.reverse)(values) : values;
  }
  /**
   * Calculate the ticks of an interval, the count of ticks won't be guraranteed,
   * but the domain will be guaranteed
   *
   * @param  {Number}  min, max      min: The minimum value, max: The maximum value
   * @param  {Integer} tickCount     The count of ticks
   * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not
   * @return {Array}   ticks
   */


  function getTickValuesFixedDomainFn(_ref7, tickCount) {
    var _ref8 = _slicedToArray(_ref7, 2),
        min = _ref8[0],
        max = _ref8[1];

    var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    // More than two ticks should be return
    var _getValidInterval5 = getValidInterval([min, max]),
        _getValidInterval6 = _slicedToArray(_getValidInterval5, 2),
        cormin = _getValidInterval6[0],
        cormax = _getValidInterval6[1];

    if (cormin === -Infinity || cormax === Infinity) {
      return [min, max];
    }

    if (cormin === cormax) {
      return [cormin];
    }

    var count = Math.max(tickCount, 2);
    var step = getFormatStep(new _decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);

    var values = _toConsumableArray(_arithmetic.default.rangeStep(new _decimal.default(cormin), new _decimal.default(cormax).sub(new _decimal.default(0.99).mul(step)), step)).concat([cormax]);

    return min > max ? (0, utils.reverse)(values) : values;
  }

  var getNiceTickValues = (0, utils.memoize)(getNiceTickValuesFn);
  exports.getNiceTickValues = getNiceTickValues;
  var getTickValues = (0, utils.memoize)(getTickValuesFn);
  exports.getTickValues = getTickValues;
  var getTickValuesFixedDomain = (0, utils.memoize)(getTickValuesFixedDomainFn);
  exports.getTickValuesFixedDomain = getTickValuesFixedDomain;
  });

  unwrapExports(getNiceTickValues_1);
  getNiceTickValues_1.getTickValuesFixedDomain;
  getNiceTickValues_1.getTickValues;
  getNiceTickValues_1.getNiceTickValues;

  var lib$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "getTickValues", {
    enumerable: true,
    get: function get() {
      return getNiceTickValues_1.getTickValues;
    }
  });
  Object.defineProperty(exports, "getNiceTickValues", {
    enumerable: true,
    get: function get() {
      return getNiceTickValues_1.getNiceTickValues;
    }
  });
  Object.defineProperty(exports, "getTickValuesFixedDomain", {
    enumerable: true,
    get: function get() {
      return getNiceTickValues_1.getTickValuesFixedDomain;
    }
  });
  });

  unwrapExports(lib$1);
  lib$1.getTickValues;
  var lib_2 = lib$1.getNiceTickValues;
  var lib_3 = lib$1.getTickValuesFixedDomain;

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;

  function number$2(x) {
    return x === null ? NaN : +x;
  }

  function sequence(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  var e10 = Math.sqrt(50),
      e5 = Math.sqrt(10),
      e2 = Math.sqrt(2);

  function ticks(start, stop, count) {
    var reverse,
        i = -1,
        n,
        ticks,
        step;

    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [start];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

    if (step > 0) {
      start = Math.ceil(start / step);
      stop = Math.floor(stop / step);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      while (++i < n) ticks[i] = (start + i) * step;
    } else {
      start = Math.floor(start * step);
      stop = Math.ceil(stop * step);
      ticks = new Array(n = Math.ceil(start - stop + 1));
      while (++i < n) ticks[i] = (start - i) / step;
    }

    if (reverse) ticks.reverse();

    return ticks;
  }

  function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log(step) / Math.LN10),
        error = step / Math.pow(10, power);
    return power >= 0
        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function threshold$1(values, p, valueof) {
    if (valueof == null) valueof = number$2;
    if (!(n = values.length)) return;
    if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n,
        i = (n - 1) * p,
        i0 = Math.floor(i),
        value0 = +valueof(values[i0], i0, values),
        value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  }

  function initRange(domain, range) {
    switch (arguments.length) {
      case 0: break;
      case 1: this.range(domain); break;
      default: this.range(range).domain(domain); break;
    }
    return this;
  }

  function initInterpolator(domain, interpolator) {
    switch (arguments.length) {
      case 0: break;
      case 1: this.interpolator(domain); break;
      default: this.interpolator(interpolator).domain(domain); break;
    }
    return this;
  }

  var prefix = "$";

  function Map$1() {}

  Map$1.prototype = map$2.prototype = {
    constructor: Map$1,
    has: function(key) {
      return (prefix + key) in this;
    },
    get: function(key) {
      return this[prefix + key];
    },
    set: function(key, value) {
      this[prefix + key] = value;
      return this;
    },
    remove: function(key) {
      var property = prefix + key;
      return property in this && delete this[property];
    },
    clear: function() {
      for (var property in this) if (property[0] === prefix) delete this[property];
    },
    keys: function() {
      var keys = [];
      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
      return keys;
    },
    values: function() {
      var values = [];
      for (var property in this) if (property[0] === prefix) values.push(this[property]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
      return entries;
    },
    size: function() {
      var size = 0;
      for (var property in this) if (property[0] === prefix) ++size;
      return size;
    },
    empty: function() {
      for (var property in this) if (property[0] === prefix) return false;
      return true;
    },
    each: function(f) {
      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  };

  function map$2(object, f) {
    var map = new Map$1;

    // Copy constructor.
    if (object instanceof Map$1) object.each(function(value, key) { map.set(key, value); });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;

      if (f == null) while (++i < n) map.set(i, object[i]);
      else while (++i < n) map.set(f(o = object[i], i, object), o);
    }

    // Convert object to map.
    else if (object) for (var key in object) map.set(key, object[key]);

    return map;
  }

  function Set$1() {}

  var proto = map$2.prototype;

  Set$1.prototype = {
    constructor: Set$1,
    has: proto.has,
    add: function(value) {
      value += "";
      this[prefix + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };

  var array = Array.prototype;

  var map$1 = array.map;
  var slice$2 = array.slice;

  var implicit = {name: "implicit"};

  function ordinal() {
    var index = map$2(),
        domain = [],
        range = [],
        unknown = implicit;

    function scale(d) {
      var key = d + "", i = index.get(key);
      if (!i) {
        if (unknown !== implicit) return unknown;
        index.set(key, i = domain.push(d));
      }
      return range[(i - 1) % range.length];
    }

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [], index = map$2();
      var i = -1, n = _.length, d, key;
      while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
      return scale;
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice$2.call(_), scale) : range.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return ordinal(domain, range).unknown(unknown);
    };

    initRange.apply(scale, arguments);

    return scale;
  }

  function band() {
    var scale = ordinal().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range,
        range = [0, 1],
        step,
        bandwidth,
        round = false,
        paddingInner = 0,
        paddingOuter = 0,
        align = 0.5;

    delete scale.unknown;

    function rescale() {
      var n = domain().length,
          reverse = range[1] < range[0],
          start = range[reverse - 0],
          stop = range[1 - reverse];
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round) step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = sequence(n).map(function(i) { return start + step * i; });
      return ordinalRange(reverse ? values.reverse() : values);
    }

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.range = function(_) {
      return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = [+_[0], +_[1]], round = true, rescale();
    };

    scale.bandwidth = function() {
      return bandwidth;
    };

    scale.step = function() {
      return step;
    };

    scale.round = function(_) {
      return arguments.length ? (round = !!_, rescale()) : round;
    };

    scale.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };

    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };

    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };

    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };

    scale.copy = function() {
      return band(domain(), range)
          .round(round)
          .paddingInner(paddingInner)
          .paddingOuter(paddingOuter)
          .align(align);
    };

    return initRange.apply(rescale(), arguments);
  }

  function pointish(scale) {
    var copy = scale.copy;

    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;

    scale.copy = function() {
      return pointish(copy());
    };

    return scale;
  }

  function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }

  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex = /^#([0-9a-f]{3,8})$/,
      reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
      reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
      reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
      reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
      reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
      reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    copy: function(channels) {
      return Object.assign(new this.constructor, this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex, // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });

  function color_formatHex() {
    return this.rgb().formatHex();
  }

  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }

  function color_formatRgb() {
    return this.rgb().formatRgb();
  }

  function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
        : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
        : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
        : null) // invalid hex
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb$1(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb$1, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex, // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));

  function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  }

  function rgb_formatRgb() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }

  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(")
          + (this.h || 0) + ", "
          + (this.s || 0) * 100 + "%, "
          + (this.l || 0) * 100 + "%"
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  function constant$1(x) {
    return function() {
      return x;
    };
  }

  function linear$1(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
    };
  }

  function nogamma(a, b) {
    var d = b - a;
    return d ? linear$1(a, d) : constant$1(isNaN(a) ? b : a);
  }

  var rgb = (function rgbGamma(y) {
    var color = gamma(y);

    function rgb(start, end) {
      var r = color((start = rgb$1(start)).r, (end = rgb$1(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb.gamma = rgbGamma;

    return rgb;
  })(1);

  function numberArray(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0,
        c = b.slice(),
        i;
    return function(t) {
      for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }

  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  function genericArray(a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function date$1(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  function interpolateNumber(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  function object(a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = interpolateValue(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB = new RegExp(reA.source, "g");

  function zero(b) {
    return function() {
      return b;
    };
  }

  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function string(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: interpolateNumber(am, bm)});
      }
      bi = reB.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one(q[0].x)
        : zero(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          });
  }

  function interpolateValue(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant$1(b)
        : (t === "number" ? interpolateNumber
        : t === "string" ? ((c = color(b)) ? (b = c, rgb) : string)
        : b instanceof color ? rgb
        : b instanceof Date ? date$1
        : isNumberArray(b) ? numberArray
        : Array.isArray(b) ? genericArray
        : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
        : interpolateNumber)(a, b);
  }

  function interpolateRound(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  function constant(x) {
    return function() {
      return x;
    };
  }

  function number$1(x) {
    return +x;
  }

  var unit = [0, 1];

  function identity$2(x) {
    return x;
  }

  function normalize(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constant(isNaN(b) ? NaN : 0.5);
  }

  function clamper(domain) {
    var a = domain[0], b = domain[domain.length - 1], t;
    if (a > b) t = a, a = b, b = t;
    return function(x) { return Math.max(a, Math.min(b, x)); };
  }

  // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
  function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = normalize(domain[i], domain[i + 1]);
      r[i] = interpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = bisectRight(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy$1(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp())
        .unknown(source.unknown());
  }

  function transformer$2() {
    var domain = unit,
        range = unit,
        interpolate = interpolateValue,
        transform,
        untransform,
        unknown,
        clamp = identity$2,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }

    scale.invert = function(y) {
      return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = map$1.call(_, number$1), clamp === identity$2 || (clamp = clamper(domain)), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice$2.call(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = slice$2.call(_), interpolate = interpolateRound, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = _ ? clamper(domain) : identity$2, scale) : clamp !== identity$2;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }

  function continuous(transform, untransform) {
    return transformer$2()(transform, untransform);
  }

  function formatDecimal(x) {
    return Math.abs(x = Math.round(x)) >= 1e21
        ? x.toLocaleString("en").replace(/,/g, "")
        : x.toString(10);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimalParts(1.23) returns ["123", 0].
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width === undefined ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": formatDecimal,
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  function identity$1(x) {
    return x;
  }

  var map = Array.prototype.map,
      prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

  function formatLocale$1(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
        currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
        currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
        decimal = locale.decimal === undefined ? "." : locale.decimal + "",
        numerals = locale.numerals === undefined ? identity$1 : formatNumerals(map.call(locale.numerals, String)),
        percent = locale.percent === undefined ? "%" : locale.percent + "",
        minus = locale.minus === undefined ? "-" : locale.minus + "",
        nan = locale.nan === undefined ? "NaN" : locale.nan + "";

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision === undefined ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Determine the sign. -0 is not less than 0, but 1 / -0 is!
          var valueNegative = value < 0 || 1 / value < 0;

          // Perform the initial formatting.
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim(value);

          // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer value part that can be
          // grouped, and fractional or exponential suffix part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": value = valuePrefix + value + valueSuffix + padding; break;
          case "=": value = valuePrefix + padding + value + valueSuffix; break;
          case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale$1;
  var format;
  var formatPrefix;

  defaultLocale$1({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""],
    minus: "-"
  });

  function defaultLocale$1(definition) {
    locale$1 = formatLocale$1(definition);
    format = locale$1.format;
    formatPrefix = locale$1.formatPrefix;
    return locale$1;
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
  }

  function tickFormat(start, stop, count, specifier) {
    var step = tickStep(start, stop, count),
        precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };

    scale.nice = function(count) {
      if (count == null) count = 10;

      var d = domain(),
          i0 = 0,
          i1 = d.length - 1,
          start = d[i0],
          stop = d[i1],
          step;

      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }

      step = tickIncrement(start, stop, count);

      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement(start, stop, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement(start, stop, count);
      }

      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear() {
    var scale = continuous(identity$2, identity$2);

    scale.copy = function() {
      return copy$1(scale, linear());
    };

    initRange.apply(scale, arguments);

    return linearish(scale);
  }

  function identity(domain) {
    var unknown;

    function scale(x) {
      return isNaN(x = +x) ? unknown : x;
    }

    scale.invert = scale;

    scale.domain = scale.range = function(_) {
      return arguments.length ? (domain = map$1.call(_, number$1), scale) : domain.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return identity(domain).unknown(unknown);
    };

    domain = arguments.length ? map$1.call(domain, number$1) : [0, 1];

    return linearish(scale);
  }

  function nice(domain, interval) {
    domain = domain.slice();

    var i0 = 0,
        i1 = domain.length - 1,
        x0 = domain[i0],
        x1 = domain[i1],
        t;

    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }

    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  function transformLog(x) {
    return Math.log(x);
  }

  function transformExp(x) {
    return Math.exp(x);
  }

  function transformLogn(x) {
    return -Math.log(-x);
  }

  function transformExpn(x) {
    return -Math.exp(-x);
  }

  function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }

  function powp(base) {
    return base === 10 ? pow10
        : base === Math.E ? Math.exp
        : function(x) { return Math.pow(base, x); };
  }

  function logp(base) {
    return base === Math.E ? Math.log
        : base === 10 && Math.log10
        || base === 2 && Math.log2
        || (base = Math.log(base), function(x) { return Math.log(x) / base; });
  }

  function reflect(f) {
    return function(x) {
      return -f(-x);
    };
  }

  function loggish(transform) {
    var scale = transform(transformLog, transformExp),
        domain = scale.domain,
        base = 10,
        logs,
        pows;

    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform(transformLogn, transformExpn);
      } else {
        transform(transformLog, transformExp);
      }
      return scale;
    }

    scale.base = function(_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.ticks = function(count) {
      var d = domain(),
          u = d[0],
          v = d[d.length - 1],
          r;

      if (r = v < u) i = u, u = v, v = i;

      var i = logs(u),
          j = logs(v),
          p,
          k,
          t,
          n = count == null ? 10 : +count,
          z = [];

      if (!(base % 1) && j - i < n) {
        i = Math.round(i) - 1, j = Math.round(j) + 1;
        if (u > 0) for (; i < j; ++i) {
          for (k = 1, p = pows(i); k < base; ++k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        } else for (; i < j; ++i) {
          for (k = base - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
      } else {
        z = ticks(i, j, Math.min(j - i, n)).map(pows);
      }

      return r ? z.reverse() : z;
    };

    scale.tickFormat = function(count, specifier) {
      if (specifier == null) specifier = base === 10 ? ".0e" : ",";
      if (typeof specifier !== "function") specifier = format(specifier);
      if (count === Infinity) return specifier;
      if (count == null) count = 10;
      var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
      return function(d) {
        var i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k ? specifier(d) : "";
      };
    };

    scale.nice = function() {
      return domain(nice(domain(), {
        floor: function(x) { return pows(Math.floor(logs(x))); },
        ceil: function(x) { return pows(Math.ceil(logs(x))); }
      }));
    };

    return scale;
  }

  function log() {
    var scale = loggish(transformer$2()).domain([1, 10]);

    scale.copy = function() {
      return copy$1(scale, log()).base(scale.base());
    };

    initRange.apply(scale, arguments);

    return scale;
  }

  function transformSymlog(c) {
    return function(x) {
      return Math.sign(x) * Math.log1p(Math.abs(x / c));
    };
  }

  function transformSymexp(c) {
    return function(x) {
      return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
    };
  }

  function symlogish(transform) {
    var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

    scale.constant = function(_) {
      return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
    };

    return linearish(scale);
  }

  function symlog() {
    var scale = symlogish(transformer$2());

    scale.copy = function() {
      return copy$1(scale, symlog()).constant(scale.constant());
    };

    return initRange.apply(scale, arguments);
  }

  function transformPow(exponent) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    };
  }

  function transformSqrt(x) {
    return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
  }

  function transformSquare(x) {
    return x < 0 ? -x * x : x * x;
  }

  function powish(transform) {
    var scale = transform(identity$2, identity$2),
        exponent = 1;

    function rescale() {
      return exponent === 1 ? transform(identity$2, identity$2)
          : exponent === 0.5 ? transform(transformSqrt, transformSquare)
          : transform(transformPow(exponent), transformPow(1 / exponent));
    }

    scale.exponent = function(_) {
      return arguments.length ? (exponent = +_, rescale()) : exponent;
    };

    return linearish(scale);
  }

  function pow() {
    var scale = powish(transformer$2());

    scale.copy = function() {
      return copy$1(scale, pow()).exponent(scale.exponent());
    };

    initRange.apply(scale, arguments);

    return scale;
  }

  function sqrt() {
    return pow.apply(null, arguments).exponent(0.5);
  }

  function quantile() {
    var domain = [],
        range = [],
        thresholds = [],
        unknown;

    function rescale() {
      var i = 0, n = Math.max(1, range.length);
      thresholds = new Array(n - 1);
      while (++i < n) thresholds[i - 1] = threshold$1(domain, i / n);
      return scale;
    }

    function scale(x) {
      return isNaN(x = +x) ? unknown : range[bisectRight(thresholds, x)];
    }

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return rescale();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice$2.call(_), rescale()) : range.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.quantiles = function() {
      return thresholds.slice();
    };

    scale.copy = function() {
      return quantile()
          .domain(domain)
          .range(range)
          .unknown(unknown);
    };

    return initRange.apply(scale, arguments);
  }

  function quantize() {
    var x0 = 0,
        x1 = 1,
        n = 1,
        domain = [0.5],
        range = [0, 1],
        unknown;

    function scale(x) {
      return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
    }

    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
      return scale;
    }

    scale.domain = function(_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
    };

    scale.range = function(_) {
      return arguments.length ? (n = (range = slice$2.call(_)).length - 1, rescale()) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN]
          : i < 1 ? [x0, domain[0]]
          : i >= n ? [domain[n - 1], x1]
          : [domain[i - 1], domain[i]];
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : scale;
    };

    scale.thresholds = function() {
      return domain.slice();
    };

    scale.copy = function() {
      return quantize()
          .domain([x0, x1])
          .range(range)
          .unknown(unknown);
    };

    return initRange.apply(linearish(scale), arguments);
  }

  function threshold() {
    var domain = [0.5],
        range = [0, 1],
        unknown,
        n = 1;

    function scale(x) {
      return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
    }

    scale.domain = function(_) {
      return arguments.length ? (domain = slice$2.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice$2.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return [domain[i - 1], domain[i]];
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return threshold()
          .domain(domain)
          .range(range)
          .unknown(unknown);
    };

    return initRange.apply(scale, arguments);
  }

  var t0 = new Date,
      t1 = new Date;

  function newInterval(floori, offseti, count, field) {

    function interval(date) {
      return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
    }

    interval.floor = function(date) {
      return floori(date = new Date(+date)), date;
    };

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };

    interval.round = function(date) {
      var d0 = interval(date),
          d1 = interval.ceil(date);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [], previous;
      start = interval.ceil(start);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
      while (previous < start && start < stop);
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
      }, function(date, step) {
        if (date >= date) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
          } else while (--step >= 0) {
            while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
          }
        }
      });
    };

    if (count) {
      interval.count = function(start, end) {
        t0.setTime(+start), t1.setTime(+end);
        floori(t0), floori(t1);
        return Math.floor(count(t0, t1));
      };

      interval.every = function(step) {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null
            : !(step > 1) ? interval
            : interval.filter(field
                ? function(d) { return field(d) % step === 0; }
                : function(d) { return interval.count(0, d) % step === 0; });
      };
    }

    return interval;
  }

  var millisecond = newInterval(function() {
    // noop
  }, function(date, step) {
    date.setTime(+date + step);
  }, function(start, end) {
    return end - start;
  });

  // An optimized implementation for this simple case.
  millisecond.every = function(k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) return null;
    if (!(k > 1)) return millisecond;
    return newInterval(function(date) {
      date.setTime(Math.floor(date / k) * k);
    }, function(date, step) {
      date.setTime(+date + step * k);
    }, function(start, end) {
      return (end - start) / k;
    });
  };

  var durationSecond$1 = 1e3;
  var durationMinute$1 = 6e4;
  var durationHour$1 = 36e5;
  var durationDay$1 = 864e5;
  var durationWeek$1 = 6048e5;

  var second = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds());
  }, function(date, step) {
    date.setTime(+date + step * durationSecond$1);
  }, function(start, end) {
    return (end - start) / durationSecond$1;
  }, function(date) {
    return date.getUTCSeconds();
  });

  var minute = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1);
  }, function(date, step) {
    date.setTime(+date + step * durationMinute$1);
  }, function(start, end) {
    return (end - start) / durationMinute$1;
  }, function(date) {
    return date.getMinutes();
  });

  var hour = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1 - date.getMinutes() * durationMinute$1);
  }, function(date, step) {
    date.setTime(+date + step * durationHour$1);
  }, function(start, end) {
    return (end - start) / durationHour$1;
  }, function(date) {
    return date.getHours();
  });

  var day = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
  }, function(date) {
    return date.getDate() - 1;
  });

  function weekday(i) {
    return newInterval(function(date) {
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
    });
  }

  var sunday = weekday(0);
  var monday = weekday(1);
  weekday(2);
  weekday(3);
  var thursday = weekday(4);
  weekday(5);
  weekday(6);

  var month = newInterval(function(date) {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setMonth(date.getMonth() + step);
  }, function(start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, function(date) {
    return date.getMonth();
  });

  var year = newInterval(function(date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  }, function(date) {
    return date.getFullYear();
  });

  // An optimized implementation for this simple case.
  year.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step * k);
    });
  };

  var utcMinute = newInterval(function(date) {
    date.setUTCSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * durationMinute$1);
  }, function(start, end) {
    return (end - start) / durationMinute$1;
  }, function(date) {
    return date.getUTCMinutes();
  });

  var utcHour = newInterval(function(date) {
    date.setUTCMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * durationHour$1);
  }, function(start, end) {
    return (end - start) / durationHour$1;
  }, function(date) {
    return date.getUTCHours();
  });

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / durationDay$1;
  }, function(date) {
    return date.getUTCDate() - 1;
  });

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / durationWeek$1;
    });
  }

  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  utcWeekday(2);
  utcWeekday(3);
  var utcThursday = utcWeekday(4);
  utcWeekday(5);
  utcWeekday(6);

  var utcMonth = newInterval(function(date) {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function(start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, function(date) {
    return date.getUTCMonth();
  });

  var utcYear = newInterval(function(date) {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, function(date) {
    return date.getUTCFullYear();
  });

  // An optimized implementation for this simple case.
  utcYear.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
  };

  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }

  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }

  function newDate(y, m, d) {
    return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
  }

  function formatLocale(locale) {
    var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;

    var periodRe = formatRe(locale_periods),
        periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);

    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };

    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };

    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);

    function newFormat(specifier, formats) {
      return function(date) {
        var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;

        if (!(date instanceof Date)) date = new Date(+date);

        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
            else pad = c === "e" ? " " : "0";
            if (format = formats[c]) c = format(date, pad);
            string.push(c);
            j = i + 1;
          }
        }

        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }

    function newParse(specifier, Z) {
      return function(string) {
        var d = newDate(1900, undefined, 1),
            i = parseSpecifier(d, specifier, string += "", 0),
            week, day$1;
        if (i != string.length) return null;

        // If a UNIX timestamp is specified, return it.
        if ("Q" in d) return new Date(d.Q);
        if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

        // If this is utcParse, never use the local timezone.
        if (Z && !("Z" in d)) d.Z = 0;

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) d.H = d.H % 12 + d.p * 12;

        // If the month was not specified, inherit from the quarter.
        if (d.m === undefined) d.m = "q" in d ? d.q : 0;

        // Convert day-of-week and week-of-year to day-of-year.
        if ("V" in d) {
          if (d.V < 1 || d.V > 53) return null;
          if (!("w" in d)) d.w = 1;
          if ("Z" in d) {
            week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
            week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
            week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
            week = day.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
        }

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }

        // Otherwise, all fields are in local time.
        return localDate(d);
      };
    }

    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;

      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }

      return j;
    }

    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }

    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }

    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }

    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }

    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }

    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }

    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }

    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }

    function formatQuarter(d) {
      return 1 + ~~(d.getMonth() / 3);
    }

    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }

    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }

    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }

    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }

    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }

    function formatUTCQuarter(d) {
      return 1 + ~~(d.getUTCMonth() / 3);
    }

    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() { return specifier; };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", false);
        p.toString = function() { return specifier; };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() { return specifier; };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier += "", true);
        p.toString = function() { return specifier; };
        return p;
      }
    };
  }

  var pads = {"-": "", "_": " ", "0": "0"},
      numberRe = /^\s*\d+/, // note: ignores next directive
      percentRe = /^%/,
      requoteRe = /[\\^$*+?|[\]().{}]/g;

  function pad(value, fill, width) {
    var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }

  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }

  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }

  function formatLookup(names) {
    var map = {}, i = -1, n = names.length;
    while (++i < n) map[names[i].toLowerCase()] = i;
    return map;
  }

  function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }

  function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }

  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }

  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }

  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }

  function parseQuarter(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
  }

  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }

  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }

  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }

  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }

  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }

  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }

  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }

  function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
  }

  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }

  function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }

  function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.s = +n[0], i + n[0].length) : -1;
  }

  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }

  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }

  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }

  function formatDayOfYear(d, p) {
    return pad(1 + day.count(year(d), d), p, 3);
  }

  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }

  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }

  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }

  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }

  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }

  function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }

  function formatWeekNumberSunday(d, p) {
    return pad(sunday.count(year(d) - 1, d), p, 2);
  }

  function dISO(d) {
    var day = d.getDay();
    return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  }

  function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
  }

  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }

  function formatWeekNumberMonday(d, p) {
    return pad(monday.count(year(d) - 1, d), p, 2);
  }

  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }

  function formatYearISO(d, p) {
    d = dISO(d);
    return pad(d.getFullYear() % 100, p, 2);
  }

  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 10000, p, 4);
  }

  function formatFullYearISO(d, p) {
    var day = d.getDay();
    d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    return pad(d.getFullYear() % 10000, p, 4);
  }

  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+"))
        + pad(z / 60 | 0, "0", 2)
        + pad(z % 60, "0", 2);
  }

  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }

  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }

  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }

  function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay.count(utcYear(d), d), p, 3);
  }

  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }

  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }

  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }

  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }

  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }

  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }

  function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
  }

  function UTCdISO(d) {
    var day = d.getUTCDay();
    return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  }

  function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
  }

  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }

  function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
  }

  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCFullYearISO(d, p) {
    var day = d.getUTCDay();
    d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    return pad(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCZone() {
    return "+0000";
  }

  function formatLiteralPercent() {
    return "%";
  }

  function formatUnixTimestamp(d) {
    return +d;
  }

  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1000);
  }

  var locale;
  var timeFormat;
  var utcFormat;

  defaultLocale({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    timeFormat = locale.format;
    locale.parse;
    utcFormat = locale.utcFormat;
    locale.utcParse;
    return locale;
  }

  var durationSecond = 1000,
      durationMinute = durationSecond * 60,
      durationHour = durationMinute * 60,
      durationDay = durationHour * 24,
      durationWeek = durationDay * 7,
      durationMonth = durationDay * 30,
      durationYear = durationDay * 365;

  function date(t) {
    return new Date(t);
  }

  function number(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }

  function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
    var scale = continuous(identity$2, identity$2),
        invert = scale.invert,
        domain = scale.domain;

    var formatMillisecond = format(".%L"),
        formatSecond = format(":%S"),
        formatMinute = format("%I:%M"),
        formatHour = format("%I %p"),
        formatDay = format("%a %d"),
        formatWeek = format("%b %d"),
        formatMonth = format("%B"),
        formatYear = format("%Y");

    var tickIntervals = [
      [second,  1,      durationSecond],
      [second,  5,  5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute,  1,      durationMinute],
      [minute,  5,  5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [  hour,  1,      durationHour  ],
      [  hour,  3,  3 * durationHour  ],
      [  hour,  6,  6 * durationHour  ],
      [  hour, 12, 12 * durationHour  ],
      [   day,  1,      durationDay   ],
      [   day,  2,  2 * durationDay   ],
      [  week,  1,      durationWeek  ],
      [ month,  1,      durationMonth ],
      [ month,  3,  3 * durationMonth ],
      [  year,  1,      durationYear  ]
    ];

    function tickFormat(date) {
      return (second(date) < date ? formatMillisecond
          : minute(date) < date ? formatSecond
          : hour(date) < date ? formatMinute
          : day(date) < date ? formatHour
          : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
          : year(date) < date ? formatMonth
          : formatYear)(date);
    }

    function tickInterval(interval, start, stop, step) {
      if (interval == null) interval = 10;

      // If a desired tick count is specified, pick a reasonable tick interval
      // based on the extent of the domain and a rough estimate of tick size.
      // Otherwise, assume interval is already a time interval and use it.
      if (typeof interval === "number") {
        var target = Math.abs(stop - start) / interval,
            i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
        if (i === tickIntervals.length) {
          step = tickStep(start / durationYear, stop / durationYear, interval);
          interval = year;
        } else if (i) {
          i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
          step = i[1];
          interval = i[0];
        } else {
          step = Math.max(tickStep(start, stop, interval), 1);
          interval = millisecond;
        }
      }

      return step == null ? interval : interval.every(step);
    }

    scale.invert = function(y) {
      return new Date(invert(y));
    };

    scale.domain = function(_) {
      return arguments.length ? domain(map$1.call(_, number)) : domain().map(date);
    };

    scale.ticks = function(interval, step) {
      var d = domain(),
          t0 = d[0],
          t1 = d[d.length - 1],
          r = t1 < t0,
          t;
      if (r) t = t0, t0 = t1, t1 = t;
      t = tickInterval(interval, t0, t1, step);
      t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
      return r ? t.reverse() : t;
    };

    scale.tickFormat = function(count, specifier) {
      return specifier == null ? tickFormat : format(specifier);
    };

    scale.nice = function(interval, step) {
      var d = domain();
      return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
          ? domain(nice(d, interval))
          : scale;
    };

    scale.copy = function() {
      return copy$1(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
    };

    return scale;
  }

  function time() {
    return initRange.apply(calendar(year, month, sunday, day, hour, minute, second, millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
  }

  function utcTime() {
    return initRange.apply(calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
  }

  function transformer$1() {
    var x0 = 0,
        x1 = 1,
        t0,
        t1,
        k10,
        transform,
        interpolator = identity$2,
        clamp = false,
        unknown;

    function scale(x) {
      return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
    }

    scale.domain = function(_) {
      return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, scale) : clamp;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t) {
      transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
      return scale;
    };
  }

  function copy(source, target) {
    return target
        .domain(source.domain())
        .interpolator(source.interpolator())
        .clamp(source.clamp())
        .unknown(source.unknown());
  }

  function sequential() {
    var scale = linearish(transformer$1()(identity$2));

    scale.copy = function() {
      return copy(scale, sequential());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function sequentialLog() {
    var scale = loggish(transformer$1()).domain([1, 10]);

    scale.copy = function() {
      return copy(scale, sequentialLog()).base(scale.base());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function sequentialSymlog() {
    var scale = symlogish(transformer$1());

    scale.copy = function() {
      return copy(scale, sequentialSymlog()).constant(scale.constant());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function sequentialPow() {
    var scale = powish(transformer$1());

    scale.copy = function() {
      return copy(scale, sequentialPow()).exponent(scale.exponent());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function sequentialSqrt() {
    return sequentialPow.apply(null, arguments).exponent(0.5);
  }

  function sequentialQuantile() {
    var domain = [],
        interpolator = identity$2;

    function scale(x) {
      if (!isNaN(x = +x)) return interpolator((bisectRight(domain, x) - 1) / (domain.length - 1));
    }

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return scale;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    scale.copy = function() {
      return sequentialQuantile(interpolator).domain(domain);
    };

    return initInterpolator.apply(scale, arguments);
  }

  function transformer() {
    var x0 = 0,
        x1 = 0.5,
        x2 = 1,
        t0,
        t1,
        t2,
        k10,
        k21,
        interpolator = identity$2,
        transform,
        clamp = false,
        unknown;

    function scale(x) {
      return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
    }

    scale.domain = function(_) {
      return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, scale) : clamp;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t) {
      transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
      return scale;
    };
  }

  function diverging() {
    var scale = linearish(transformer()(identity$2));

    scale.copy = function() {
      return copy(scale, diverging());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function divergingLog() {
    var scale = loggish(transformer()).domain([0.1, 1, 10]);

    scale.copy = function() {
      return copy(scale, divergingLog()).base(scale.base());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function divergingSymlog() {
    var scale = symlogish(transformer());

    scale.copy = function() {
      return copy(scale, divergingSymlog()).constant(scale.constant());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function divergingPow() {
    var scale = powish(transformer());

    scale.copy = function() {
      return copy(scale, divergingPow()).exponent(scale.exponent());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function divergingSqrt() {
    return divergingPow.apply(null, arguments).exponent(0.5);
  }

  var d3Scales = /*#__PURE__*/Object.freeze({
    __proto__: null,
    scaleBand: band,
    scalePoint: point,
    scaleIdentity: identity,
    scaleLinear: linear,
    scaleLog: log,
    scaleSymlog: symlog,
    scaleOrdinal: ordinal,
    scaleImplicit: implicit,
    scalePow: pow,
    scaleSqrt: sqrt,
    scaleQuantile: quantile,
    scaleQuantize: quantize,
    scaleThreshold: threshold,
    scaleTime: time,
    scaleUtc: utcTime,
    scaleSequential: sequential,
    scaleSequentialLog: sequentialLog,
    scaleSequentialPow: sequentialPow,
    scaleSequentialSqrt: sequentialSqrt,
    scaleSequentialSymlog: sequentialSymlog,
    scaleSequentialQuantile: sequentialQuantile,
    scaleDiverging: diverging,
    scaleDivergingLog: divergingLog,
    scaleDivergingPow: divergingPow,
    scaleDivergingSqrt: divergingSqrt,
    scaleDivergingSymlog: divergingSymlog,
    tickFormat: tickFormat
  });

  function _typeof$f(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$f = function _typeof(obj) { return typeof obj; }; } else { _typeof$f = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$f(obj); }

  function _extends$j() { _extends$j = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$j.apply(this, arguments); }

  function _slicedToArray$2(arr, i) { return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _nonIterableRest$2(); }

  function _nonIterableRest$2() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$2(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$2(arr) { if (Array.isArray(arr)) return arr; }

  function _objectWithoutProperties$4(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$5(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$5(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _classCallCheck$g(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$g(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$g(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$g(Constructor.prototype, protoProps); if (staticProps) _defineProperties$g(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$f(self, call) { if (call && (_typeof$f(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$g(self); }

  function _assertThisInitialized$g(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$f(o) { _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$f(o); }

  function _inherits$f(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$f(subClass, superClass); }

  function _setPrototypeOf$f(o, p) { _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$f(o, p); }

  var ErrorBar =
  /*#__PURE__*/
  function (_Component) {
    _inherits$f(ErrorBar, _Component);

    function ErrorBar() {
      _classCallCheck$g(this, ErrorBar);

      return _possibleConstructorReturn$f(this, _getPrototypeOf$f(ErrorBar).apply(this, arguments));
    }

    _createClass$g(ErrorBar, [{
      key: "renderErrorBars",
      value: function renderErrorBars() {
        var _this$props = this.props,
            offset = _this$props.offset,
            layout = _this$props.layout,
            width = _this$props.width,
            dataKey = _this$props.dataKey,
            data = _this$props.data,
            dataPointFormatter = _this$props.dataPointFormatter,
            xAxis = _this$props.xAxis,
            yAxis = _this$props.yAxis,
            others = _objectWithoutProperties$4(_this$props, ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"]);

        var props = getPresentationAttributes(others);
        return data.map(function (entry, i) {
          var _dataPointFormatter = dataPointFormatter(entry, dataKey),
              x = _dataPointFormatter.x,
              y = _dataPointFormatter.y,
              value = _dataPointFormatter.value,
              errorVal = _dataPointFormatter.errorVal;

          if (!errorVal) {
            return null;
          }

          var xMid, yMid, xMin, yMin, xMax, yMax, scale, coordsTop, coordsMid, coordsBot, lowBound, highBound;

          if (Array.isArray(errorVal)) {
            var _errorVal = _slicedToArray$2(errorVal, 2);

            lowBound = _errorVal[0];
            highBound = _errorVal[1];
          } else {
            lowBound = highBound = errorVal;
          }

          if (layout === 'vertical') {
            scale = xAxis.scale;
            xMid = value;
            yMid = y + offset;
            xMin = scale(xMid - lowBound);
            yMin = yMid + width;
            xMax = scale(xMid + highBound);
            yMax = yMid - width;
            coordsTop = {
              x1: xMax,
              y1: yMin,
              x2: xMax,
              y2: yMax
            };
            coordsMid = {
              x1: xMin,
              y1: yMid,
              x2: xMax,
              y2: yMid
            };
            coordsBot = {
              x1: xMin,
              y1: yMin,
              x2: xMin,
              y2: yMax
            };
          } else if (layout === 'horizontal') {
            scale = yAxis.scale;
            xMid = x + offset;
            yMid = value;
            xMin = xMid - width;
            xMax = xMid + width;
            yMin = scale(yMid - lowBound);
            yMax = scale(yMid + highBound);
            coordsTop = {
              x1: xMin,
              y1: yMax,
              x2: xMax,
              y2: yMax
            };
            coordsMid = {
              x1: xMid,
              y1: yMin,
              x2: xMid,
              y2: yMax
            };
            coordsBot = {
              x1: xMin,
              y1: yMin,
              x2: xMax,
              y2: yMin
            };
          }

          return (// eslint-disable-next-line react/no-array-index-key
            React__default['default'].createElement(Layer, _extends$j({
              className: "recharts-errorBar",
              key: "bar-".concat(i)
            }, props), React__default['default'].createElement("line", coordsTop), React__default['default'].createElement("line", coordsMid), React__default['default'].createElement("line", coordsBot))
          );
        });
      }
    }, {
      key: "render",
      value: function render() {
        return React__default['default'].createElement(Layer, {
          className: "recharts-errorBars"
        }, this.renderErrorBars());
      }
    }]);

    return ErrorBar;
  }(React.Component);

  ErrorBar.propTypes = {
    dataKey: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number, propTypes$5.func]).isRequired,
    data: propTypes$5.array,
    xAxis: propTypes$5.object,
    yAxis: propTypes$5.object,
    layout: propTypes$5.string,
    dataPointFormatter: propTypes$5.func,
    stroke: propTypes$5.string,
    strokeWidth: propTypes$5.number,
    width: propTypes$5.number,
    offset: propTypes$5.number
  };
  ErrorBar.defaultProps = {
    stroke: 'black',
    strokeWidth: 1.5,
    width: 5,
    offset: 0,
    layout: 'horizontal'
  };

  function _toConsumableArray$3(arr) { return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _nonIterableSpread$3(); }

  function _nonIterableSpread$3() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray$3(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles$3(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$h(source, true).forEach(function (key) { _defineProperty$j(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$h(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$j(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var getValueByDataKey = function getValueByDataKey(obj, dataKey, defaultValue) {
    if (isNil_1(obj) || isNil_1(dataKey)) {
      return defaultValue;
    }

    if (isNumOrStr(dataKey)) {
      return get_1(obj, dataKey, defaultValue);
    }

    if (isFunction_1(dataKey)) {
      return dataKey(obj);
    }

    return defaultValue;
  };
  /**
   * Get domain of data by key
   * @param  {Array}   data      The data displayed in the chart
   * @param  {String}  key       The unique key of a group of data
   * @param  {String}  type      The type of axis
   * @param  {Boolean} filterNil Whether or not filter nil values
   * @return {Array} Domain of data
   */

  var getDomainOfDataByKey = function getDomainOfDataByKey(data, key, type, filterNil) {
    var flattenData = flatMap_1(data, function (entry) {
      return getValueByDataKey(entry, key);
    });

    if (type === 'number') {
      var domain = flattenData.filter(function (entry) {
        return isNumber(entry) || parseFloat(entry, 10);
      });
      return domain.length ? [min_1(domain), max_1(domain)] : [Infinity, -Infinity];
    }

    var validateData = filterNil ? flattenData.filter(function (entry) {
      return !isNil_1(entry);
    }) : flattenData;
    return validateData.map(function (entry) {
      return isNumOrStr(entry) ? entry : '';
    });
  };
  var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate, ticks, unsortedTicks, axis) {
    var index = -1;
    var len = ticks.length;

    if (len > 1) {
      if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {
        var range = axis.range; // ticks are distributed in a circle

        for (var i = 0; i < len; i++) {
          var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
          var cur = unsortedTicks[i].coordinate;
          var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
          var sameDirectionCoord = void 0;

          if (mathSign(cur - before) !== mathSign(after - cur)) {
            var diffInterval = [];

            if (mathSign(after - cur) === mathSign(range[1] - range[0])) {
              sameDirectionCoord = after;
              var curInRange = cur + range[1] - range[0];
              diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
              diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
            } else {
              sameDirectionCoord = before;
              var afterInRange = after + range[1] - range[0];
              diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
              diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
            }

            var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];

            if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
              index = unsortedTicks[i].index;
              break;
            }
          } else {
            var min = Math.min(before, after);
            var max = Math.max(before, after);

            if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {
              index = unsortedTicks[i].index;
              break;
            }
          }
        }
      } else {
        // ticks are distributed in a single direction
        for (var _i = 0; _i < len; _i++) {
          if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {
            index = ticks[_i].index;
            break;
          }
        }
      }
    } else {
      index = 0;
    }

    return index;
  };
  /**
   * Get the main color of each graphic item
   * @param  {ReactElement} item A graphic item
   * @return {String}            Color
   */

  var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {
    var displayName = item.type.displayName;
    var _item$props = item.props,
        stroke = _item$props.stroke,
        fill = _item$props.fill;
    var result;

    switch (displayName) {
      case 'Line':
        result = stroke;
        break;

      case 'Area':
      case 'Radar':
        result = stroke && stroke !== 'none' ? stroke : fill;
        break;

      default:
        result = fill;
        break;
    }

    return result;
  };
  var getLegendProps = function getLegendProps(_ref) {
    var children = _ref.children,
        formatedGraphicalItems = _ref.formatedGraphicalItems,
        legendWidth = _ref.legendWidth,
        legendContent = _ref.legendContent;
    var legendItem = findChildByType(children, Legend$1);

    if (!legendItem) {
      return null;
    }

    var legendData;

    if (legendItem.props && legendItem.props.payload) {
      legendData = legendItem.props && legendItem.props.payload;
    } else if (legendContent === 'children') {
      legendData = (formatedGraphicalItems || []).reduce(function (result, _ref2) {
        var item = _ref2.item,
            props = _ref2.props;
        var data = props.sectors || props.data || [];
        return result.concat(data.map(function (entry) {
          return {
            type: legendItem.props.iconType || item.props.legendType,
            value: entry.name,
            color: entry.fill,
            payload: entry
          };
        }));
      }, []);
    } else {
      legendData = (formatedGraphicalItems || []).map(function (_ref3) {
        var item = _ref3.item;
        var _item$props2 = item.props,
            dataKey = _item$props2.dataKey,
            name = _item$props2.name,
            legendType = _item$props2.legendType,
            hide = _item$props2.hide;
        return {
          inactive: hide,
          dataKey: dataKey,
          type: legendItem.props.iconType || legendType || 'square',
          color: getMainColorOfGraphicItem(item),
          value: name || dataKey,
          payload: item.props
        };
      });
    }

    return _objectSpread$h({}, legendItem.props, {}, Legend$1.getWithHeight(legendItem, legendWidth), {
      payload: legendData,
      item: legendItem
    });
  };
  /**
   * Calculate the size of all groups for stacked bar graph
   * @param  {Object} stackGroups The items grouped by axisId and stackId
   * @return {Object} The size of all groups
   */

  var getBarSizeList = function getBarSizeList(_ref4) {
    var globalSize = _ref4.barSize,
        _ref4$stackGroups = _ref4.stackGroups,
        stackGroups = _ref4$stackGroups === void 0 ? {} : _ref4$stackGroups;

    if (!stackGroups) {
      return {};
    }

    var result = {};
    var numericAxisIds = Object.keys(stackGroups);

    for (var i = 0, len = numericAxisIds.length; i < len; i++) {
      var sgs = stackGroups[numericAxisIds[i]].stackGroups;
      var stackIds = Object.keys(sgs);

      for (var j = 0, sLen = stackIds.length; j < sLen; j++) {
        var _sgs$stackIds$j = sgs[stackIds[j]],
            items = _sgs$stackIds$j.items,
            cateAxisId = _sgs$stackIds$j.cateAxisId;
        var barItems = items.filter(function (item) {
          return getDisplayName(item.type).indexOf('Bar') >= 0;
        });

        if (barItems && barItems.length) {
          var selfSize = barItems[0].props.barSize;
          var cateId = barItems[0].props[cateAxisId];

          if (!result[cateId]) {
            result[cateId] = [];
          }

          result[cateId].push({
            item: barItems[0],
            stackList: barItems.slice(1),
            barSize: isNil_1(selfSize) ? globalSize : selfSize
          });
        }
      }
    }

    return result;
  };
  /**
     * Calculate the size of each bar and the gap between two bars
     * @param  {Number} bandSize  The size of each category
     * @param  {sizeList} sizeList  The size of all groups
     * @param  {maxBarSize} maxBarSize The maximum size of bar
     * @return {Number} The size of each bar and the gap between two bars
     */

  var getBarPosition = function getBarPosition(_ref5) {
    var barGap = _ref5.barGap,
        barCategoryGap = _ref5.barCategoryGap,
        bandSize = _ref5.bandSize,
        _ref5$sizeList = _ref5.sizeList,
        sizeList = _ref5$sizeList === void 0 ? [] : _ref5$sizeList,
        maxBarSize = _ref5.maxBarSize;
    var len = sizeList.length;
    if (len < 1) return null;
    var realBarGap = getPercentValue(barGap, bandSize, 0, true);
    var result; // whether or not is barSize setted by user

    if (sizeList[0].barSize === +sizeList[0].barSize) {
      var useFull = false;
      var fullBarSize = bandSize / len;
      var sum = sizeList.reduce(function (res, entry) {
        return res + entry.barSize || 0;
      }, 0);
      sum += (len - 1) * realBarGap;

      if (sum >= bandSize) {
        sum -= (len - 1) * realBarGap;
        realBarGap = 0;
      }

      if (sum >= bandSize && fullBarSize > 0) {
        useFull = true;
        fullBarSize *= 0.9;
        sum = len * fullBarSize;
      }

      var offset = (bandSize - sum) / 2 >> 0;
      var prev = {
        offset: offset - realBarGap,
        size: 0
      };
      result = sizeList.reduce(function (res, entry) {
        var newRes = [].concat(_toConsumableArray$3(res), [{
          item: entry.item,
          position: {
            offset: prev.offset + prev.size + realBarGap,
            size: useFull ? fullBarSize : entry.barSize
          }
        }]);
        prev = newRes[newRes.length - 1].position;

        if (entry.stackList && entry.stackList.length) {
          entry.stackList.forEach(function (item) {
            newRes.push({
              item: item,
              position: prev
            });
          });
        }

        return newRes;
      }, []);
    } else {
      var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);

      if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
        realBarGap = 0;
      }

      var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;

      if (originalSize > 1) {
        originalSize >>= 0;
      }

      var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;
      result = sizeList.reduce(function (res, entry, i) {
        var newRes = [].concat(_toConsumableArray$3(res), [{
          item: entry.item,
          position: {
            offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
            size: size
          }
        }]);

        if (entry.stackList && entry.stackList.length) {
          entry.stackList.forEach(function (item) {
            newRes.push({
              item: item,
              position: newRes[newRes.length - 1].position
            });
          });
        }

        return newRes;
      }, []);
    }

    return result;
  };
  var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {
    var children = props.children,
        width = props.width,
        height = props.height,
        margin = props.margin;
    var legendWidth = width - (margin.left || 0) - (margin.right || 0);
    var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);
    var legendProps = getLegendProps({
      children: children,
      items: items,
      legendWidth: legendWidth,
      legendHeight: legendHeight
    });
    var newOffset = offset;

    if (legendProps) {
      var box = legendBox || {};
      var align = legendProps.align,
          verticalAlign = legendProps.verticalAlign,
          layout = legendProps.layout;

      if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {
        newOffset = _objectSpread$h({}, offset, _defineProperty$j({}, align, newOffset[align] + (box.width || 0)));
      }

      if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {
        newOffset = _objectSpread$h({}, offset, _defineProperty$j({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));
      }
    }

    return newOffset;
  };
  var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, axisType) {
    var children = item.props.children;
    var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {
      var direction = errorBarChild.props.direction;
      return isNil_1(direction) || isNil_1(axisType) ? true : axisType.indexOf(direction) >= 0;
    });

    if (errorBars && errorBars.length) {
      var keys = errorBars.map(function (errorBarChild) {
        return errorBarChild.props.dataKey;
      });
      return data.reduce(function (result, entry) {
        var entryValue = getValueByDataKey(entry, dataKey, 0);
        var mainValue = isArray_1(entryValue) ? [min_1(entryValue), max_1(entryValue)] : [entryValue, entryValue];
        var errorDomain = keys.reduce(function (prevErrorArr, k) {
          var errorValue = getValueByDataKey(entry, k, 0);
          var lowerValue = mainValue[0] - Math.abs(isArray_1(errorValue) ? errorValue[0] : errorValue);
          var upperValue = mainValue[1] + Math.abs(isArray_1(errorValue) ? errorValue[1] : errorValue);
          return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];
        }, [Infinity, -Infinity]);
        return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];
      }, [Infinity, -Infinity]);
    }

    return null;
  };
  var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType) {
    var domains = items.map(function (item) {
      return getDomainOfErrorBars(data, item, dataKey, axisType);
    }).filter(function (entry) {
      return !isNil_1(entry);
    });

    if (domains && domains.length) {
      return domains.reduce(function (result, entry) {
        return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
      }, [Infinity, -Infinity]);
    }

    return null;
  };
  /**
   * Get domain of data by the configuration of item element
   * @param  {Array}   data      The data displayed in the chart
   * @param  {Array}   items     The instances of item
   * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis
   * @param  {Boolean} filterNil Whether or not filter nil values
   * @return {Array}        Domain
   */

  var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {
    var domains = items.map(function (item) {
      var dataKey = item.props.dataKey;

      if (type === 'number' && dataKey) {
        return getDomainOfErrorBars(data, item, dataKey) || getDomainOfDataByKey(data, dataKey, type, filterNil);
      }

      return getDomainOfDataByKey(data, dataKey, type, filterNil);
    });

    if (type === 'number') {
      // Calculate the domain of number axis
      return domains.reduce(function (result, entry) {
        return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
      }, [Infinity, -Infinity]);
    }

    var tag = {}; // Get the union set of category axis

    return domains.reduce(function (result, entry) {
      for (var i = 0, len = entry.length; i < len; i++) {
        if (!tag[entry[i]]) {
          tag[entry[i]] = true;
          result.push(entry[i]);
        }
      }

      return result;
    }, []);
  };
  var isCategorialAxis = function isCategorialAxis(layout, axisType) {
    return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';
  };
  /**
   * Calculate the Coordinates of grid
   * @param  {Array} ticks The ticks in axis
   * @param {Number} min   The minimun value of axis
   * @param {Number} max   The maximun value of axis
   * @return {Array}       Coordinates
   */

  var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {
    var hasMin, hasMax;
    var values = ticks.map(function (entry) {
      if (entry.coordinate === min) {
        hasMin = true;
      }

      if (entry.coordinate === max) {
        hasMax = true;
      }

      return entry.coordinate;
    });

    if (!hasMin) {
      values.push(min);
    }

    if (!hasMax) {
      values.push(max);
    }

    return values;
  };
  /**
   * Get the ticks of an axis
   * @param  {Object}  axis The configuration of an axis
   * @param {Boolean} isGrid Whether or not are the ticks in grid
   * @param {Boolean} isAll Return the ticks of all the points or not
   * @return {Array}  Ticks
   */

  var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {
    if (!axis) return null;
    var scale = axis.scale;
    var duplicateDomain = axis.duplicateDomain,
        type = axis.type,
        range = axis.range;
    var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;
    offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line

    if (isGrid && (axis.ticks || axis.niceTicks)) {
      return (axis.ticks || axis.niceTicks).map(function (entry) {
        var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
        return {
          coordinate: scale(scaleContent) + offset,
          value: entry,
          offset: offset
        };
      });
    }

    if (axis.isCategorial && axis.categoricalDomain) {
      return axis.categoricalDomain.map(function (entry, index) {
        return {
          coordinate: scale(entry),
          value: entry,
          index: index,
          offset: offset
        };
      });
    }

    if (scale.ticks && !isAll) {
      return scale.ticks(axis.tickCount).map(function (entry) {
        return {
          coordinate: scale(entry) + offset,
          value: entry,
          offset: offset
        };
      });
    } // When axis has duplicated text, serial numbers are used to generate scale


    return scale.domain().map(function (entry, index) {
      return {
        coordinate: scale(entry) + offset,
        value: duplicateDomain ? duplicateDomain[entry] : entry,
        index: index,
        offset: offset
      };
    });
  };
  /**
   * combine the handlers
   * @param  {Function} defaultHandler Internal private handler
   * @param  {Function} parentHandler  Handler function specified in parent component
   * @param  {Function} childHandler   Handler function specified in child component
   * @return {Function}                The combined handler
   */

  var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {
    var customizedHandler;

    if (isFunction_1(childHandler)) {
      customizedHandler = childHandler;
    } else if (isFunction_1(parentHandler)) {
      customizedHandler = parentHandler;
    }

    if (isFunction_1(defaultHandler) || customizedHandler) {
      return function (arg1, arg2, arg3, arg4) {
        if (isFunction_1(defaultHandler)) {
          defaultHandler(arg1, arg2, arg3, arg4);
        }

        if (isFunction_1(customizedHandler)) {
          customizedHandler(arg1, arg2, arg3, arg4);
        }
      };
    }

    return null;
  };
  /**
   * Parse the scale function of axis
   * @param  {Object}   axis          The option of axis
   * @param  {String}   chartType     The displayName of chart
   * @return {Function}               The scale funcion
   */

  var parseScale = function parseScale(axis, chartType) {
    var scale = axis.scale,
        type = axis.type,
        layout = axis.layout,
        axisType = axis.axisType;

    if (scale === 'auto') {
      if (layout === 'radial' && axisType === 'radiusAxis') {
        return {
          scale: band(),
          realScaleType: 'band'
        };
      }

      if (layout === 'radial' && axisType === 'angleAxis') {
        return {
          scale: linear(),
          realScaleType: 'linear'
        };
      }

      if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0)) {
        return {
          scale: point(),
          realScaleType: 'point'
        };
      }

      if (type === 'category') {
        return {
          scale: band(),
          realScaleType: 'band'
        };
      }

      return {
        scale: linear(),
        realScaleType: 'linear'
      };
    }

    if (isString_1(scale)) {
      var name = "scale".concat(scale.slice(0, 1).toUpperCase()).concat(scale.slice(1));
      return {
        scale: (d3Scales[name] || point)(),
        realScaleType: d3Scales[name] ? name : 'point'
      };
    }

    return isFunction_1(scale) ? {
      scale: scale
    } : {
      scale: point(),
      realScaleType: 'point'
    };
  };
  var EPS = 1e-4;
  var checkDomainOfScale = function checkDomainOfScale(scale) {
    var domain = scale.domain();

    if (!domain || domain.length <= 2) {
      return;
    }

    var len = domain.length;
    var range = scale.range();
    var min = Math.min(range[0], range[1]) - EPS;
    var max = Math.max(range[0], range[1]) + EPS;
    var first = scale(domain[0]);
    var last = scale(domain[len - 1]);

    if (first < min || first > max || last < min || last > max) {
      scale.domain([domain[0], domain[len - 1]]);
    }
  };
  /* eslint no-param-reassign: 0 */

  var offsetSign = function offsetSign(series) {
    var n = series.length;

    if (n <= 0) {
      return;
    }

    for (var j = 0, m = series[0].length; j < m; ++j) {
      var positive = 0;
      var negative = 0;

      for (var i = 0; i < n; ++i) {
        var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
        /* eslint-disable prefer-destructuring */

        if (value >= 0) {
          series[i][j][0] = positive;
          series[i][j][1] = positive + value;
          positive = series[i][j][1];
        } else {
          series[i][j][0] = negative;
          series[i][j][1] = negative + value;
          negative = series[i][j][1];
        }
        /* eslint-enable prefer-destructuring */

      }
    }
  };
  var STACK_OFFSET_MAP = {
    sign: offsetSign,
    expand: stackOffsetExpand,
    none: stackOffsetNone,
    silhouette: stackOffsetSilhouette,
    wiggle: stackOffsetWiggle
  };
  var getStackedData = function getStackedData(data, stackItems, offsetType) {
    var dataKeys = stackItems.map(function (item) {
      return item.props.dataKey;
    });
    var stack = shapeStack().keys(dataKeys).value(function (d, key) {
      return +getValueByDataKey(d, key, 0);
    }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);
    return stack(data);
  };
  var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {
    if (!data) {
      return null;
    } // reversing items to affect render order (for layering)


    var items = reverseStackOrder ? _items.reverse() : _items;
    var stackGroups = items.reduce(function (result, item) {
      var _item$props3 = item.props,
          stackId = _item$props3.stackId,
          hide = _item$props3.hide;

      if (hide) {
        return result;
      }

      var axisId = item.props[numericAxisId];
      var parentGroup = result[axisId] || {
        hasStack: false,
        stackGroups: {}
      };

      if (isNumOrStr(stackId)) {
        var childGroup = parentGroup.stackGroups[stackId] || {
          numericAxisId: numericAxisId,
          cateAxisId: cateAxisId,
          items: []
        };
        childGroup.items.push(item);
        parentGroup.hasStack = true;
        parentGroup.stackGroups[stackId] = childGroup;
      } else {
        parentGroup.stackGroups[uniqueId('_stackId_')] = {
          numericAxisId: numericAxisId,
          cateAxisId: cateAxisId,
          items: [item]
        };
      }

      return _objectSpread$h({}, result, _defineProperty$j({}, axisId, parentGroup));
    }, {});
    return Object.keys(stackGroups).reduce(function (result, axisId) {
      var group = stackGroups[axisId];

      if (group.hasStack) {
        group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {
          var g = group.stackGroups[stackId];
          return _objectSpread$h({}, res, _defineProperty$j({}, stackId, {
            numericAxisId: numericAxisId,
            cateAxisId: cateAxisId,
            items: g.items,
            stackedData: getStackedData(data, g.items, offsetType)
          }));
        }, {});
      }

      return _objectSpread$h({}, result, _defineProperty$j({}, axisId, group));
    }, {});
  };
  /**
   * get domain of ticks
   * @param  {Array} ticks Ticks of axis
   * @param  {String} type  The type of axis
   * @return {Array} domain
   */

  var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {
    if (type === 'number') {
      return [min_1(ticks), max_1(ticks)];
    }

    return ticks;
  };
  /**
   * Configure the scale function of axis
   * @param {Object} scale The scale function
   * @param {Object} opts  The configuration of axis
   * @return {Object}      null
   */

  var getTicksOfScale = function getTicksOfScale(scale, opts) {
    var realScaleType = opts.realScaleType,
        type = opts.type,
        tickCount = opts.tickCount,
        originalDomain = opts.originalDomain,
        allowDecimals = opts.allowDecimals;
    var scaleType = realScaleType || opts.scale;

    if (scaleType !== 'auto' && scaleType !== 'linear') {
      return null;
    }

    if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {
      // Calculate the ticks by the number of grid when the axis is a number axis
      var domain = scale.domain();
      var tickValues = lib_2(domain, tickCount, allowDecimals);
      scale.domain(calculateDomainOfTicks(tickValues, type));
      return {
        niceTicks: tickValues
      };
    }

    if (tickCount && type === 'number') {
      var _domain = scale.domain();

      var _tickValues = lib_3(_domain, tickCount, allowDecimals);

      return {
        niceTicks: _tickValues
      };
    }

    return null;
  };
  var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {
    var stackId = item.props.stackId;

    if (isNumOrStr(stackId)) {
      var group = stackGroups[stackId];

      if (group && group.items.length) {
        var itemIndex = -1;

        for (var i = 0, len = group.items.length; i < len; i++) {
          if (group.items[i] === item) {
            itemIndex = i;
            break;
          }
        }

        return itemIndex >= 0 ? group.stackedData[itemIndex] : null;
      }
    }

    return null;
  };

  var getDomainOfSingle = function getDomainOfSingle(data) {
    return data.reduce(function (result, entry) {
      return [min_1(entry.concat([result[0]]).filter(isNumber)), max_1(entry.concat([result[1]]).filter(isNumber))];
    }, [Infinity, -Infinity]);
  };

  var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {
    return Object.keys(stackGroups).reduce(function (result, stackId) {
      var group = stackGroups[stackId];
      var stackedData = group.stackedData;
      var domain = stackedData.reduce(function (res, entry) {
        var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));
        return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];
      }, [Infinity, -Infinity]);
      return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
    }, [Infinity, -Infinity]).map(function (result) {
      return result === Infinity || result === -Infinity ? 0 : result;
    });
  };
  var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
  var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
  var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {
    if (!isArray_1(specifiedDomain)) {
      return dataDomain;
    }

    var domain = [];
    /* eslint-disable prefer-destructuring */

    if (isNumber(specifiedDomain[0])) {
      domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);
    } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {
      var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];
      domain[0] = dataDomain[0] - value;
    } else if (isFunction_1(specifiedDomain[0])) {
      domain[0] = specifiedDomain[0](dataDomain[0]);
    } else {
      domain[0] = dataDomain[0];
    }

    if (isNumber(specifiedDomain[1])) {
      domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);
    } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {
      var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];

      domain[1] = dataDomain[1] + _value;
    } else if (isFunction_1(specifiedDomain[1])) {
      domain[1] = specifiedDomain[1](dataDomain[1]);
    } else {
      domain[1] = dataDomain[1];
    }
    /* eslint-enable prefer-destructuring */


    return domain;
  };
  /**
   * Calculate the size between two category
   * @param  {Object} axis  The options of axis
   * @param  {Array}  ticks The ticks of axis
   * @return {Number} Size
   */

  var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks) {
    if (axis && axis.scale && axis.scale.bandwidth) {
      return axis.scale.bandwidth();
    }

    if (axis && ticks && ticks.length >= 2) {
      var orderedTicks = sortBy_1(ticks, function (o) {
        return o.coordinate;
      });

      var bandSize = Infinity;

      for (var i = 1, len = orderedTicks.length; i < len; i++) {
        var cur = orderedTicks[i];
        var prev = orderedTicks[i - 1];
        bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
      }

      return bandSize === Infinity ? 0 : bandSize;
    }

    return 0;
  };
  /**
   * parse the domain of a category axis when a domain is specified
   * @param   {Array}        specifiedDomain  The domain specified by users
   * @param   {Array}        calculatedDomain The domain calculated by dateKey
   * @param   {ReactElement} axisChild        The axis element
   * @returns {Array}        domains
   */

  var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {
    if (!specifiedDomain || !specifiedDomain.length) {
      return calculatedDomain;
    }

    if (isEqual_1(specifiedDomain, get_1(axisChild, 'type.defaultProps.domain'))) {
      return calculatedDomain;
    }

    return specifiedDomain;
  };

  function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$g(source, true).forEach(function (key) { _defineProperty$i(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$g(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$i(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _slicedToArray$1(arr, i) { return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _nonIterableRest$1(); }

  function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$1(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }
  var RADIAN$1 = Math.PI / 180;
  var radianToDegree = function radianToDegree(angleInRadian) {
    return angleInRadian * 180 / Math.PI;
  };
  var polarToCartesian = function polarToCartesian(cx, cy, radius, angle) {
    return {
      x: cx + Math.cos(-RADIAN$1 * angle) * radius,
      y: cy + Math.sin(-RADIAN$1 * angle) * radius
    };
  };
  var getMaxRadius = function getMaxRadius(width, height) {
    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
    return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;
  };
  /**
   * Calculate the scale function, position, width, height of axes
   * @param  {Object} props     Latest props
   * @param  {Object} axisMap   The configuration of axes
   * @param  {Object} offset    The offset of main part in the svg element
   * @param  {Object} axisType  The type of axes, radius-axis or angle-axis
   * @param  {String} chartName The name of chart
   * @return {Object} Configuration
   */

  var formatAxisMap = function formatAxisMap(props, axisMap, offset, axisType, chartName) {
    var width = props.width,
        height = props.height;
    var startAngle = props.startAngle,
        endAngle = props.endAngle;
    var cx = getPercentValue(props.cx, width, width / 2);
    var cy = getPercentValue(props.cy, height, height / 2);
    var maxRadius = getMaxRadius(width, height, offset);
    var innerRadius = getPercentValue(props.innerRadius, maxRadius, 0);
    var outerRadius = getPercentValue(props.outerRadius, maxRadius, maxRadius * 0.8);
    var ids = Object.keys(axisMap);
    return ids.reduce(function (result, id) {
      var axis = axisMap[id];
      var domain = axis.domain,
          reversed = axis.reversed;
      var range;

      if (isNil_1(axis.range)) {
        if (axisType === 'angleAxis') {
          range = [startAngle, endAngle];
        } else if (axisType === 'radiusAxis') {
          range = [innerRadius, outerRadius];
        }

        if (reversed) {
          range = [range[1], range[0]];
        }
      } else {
        range = axis.range;
        var _range = range;

        var _range2 = _slicedToArray$1(_range, 2);

        startAngle = _range2[0];
        endAngle = _range2[1];
      }

      var _parseScale = parseScale(axis, chartName),
          realScaleType = _parseScale.realScaleType,
          scale = _parseScale.scale;

      scale.domain(domain).range(range);
      checkDomainOfScale(scale);
      var ticks = getTicksOfScale(scale, _objectSpread$g({}, axis, {
        realScaleType: realScaleType
      }));

      var finalAxis = _objectSpread$g({}, axis, {}, ticks, {
        range: range,
        radius: outerRadius,
        realScaleType: realScaleType,
        scale: scale,
        cx: cx,
        cy: cy,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        startAngle: startAngle,
        endAngle: endAngle
      });

      return _objectSpread$g({}, result, _defineProperty$i({}, id, finalAxis));
    }, {});
  };
  var distanceBetweenPoints = function distanceBetweenPoints(point, anotherPoint) {
    var x1 = point.x,
        y1 = point.y;
    var x2 = anotherPoint.x,
        y2 = anotherPoint.y;
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  };
  var getAngleOfPoint = function getAngleOfPoint(_ref, _ref2) {
    var x = _ref.x,
        y = _ref.y;
    var cx = _ref2.cx,
        cy = _ref2.cy;
    var radius = distanceBetweenPoints({
      x: x,
      y: y
    }, {
      x: cx,
      y: cy
    });

    if (radius <= 0) {
      return {
        radius: radius
      };
    }

    var cos = (x - cx) / radius;
    var angleInRadian = Math.acos(cos);

    if (y > cy) {
      angleInRadian = 2 * Math.PI - angleInRadian;
    }

    return {
      radius: radius,
      angle: radianToDegree(angleInRadian),
      angleInRadian: angleInRadian
    };
  };
  var formatAngleOfSector = function formatAngleOfSector(_ref3) {
    var startAngle = _ref3.startAngle,
        endAngle = _ref3.endAngle;
    var startCnt = Math.floor(startAngle / 360);
    var endCnt = Math.floor(endAngle / 360);
    var min = Math.min(startCnt, endCnt);
    return {
      startAngle: startAngle - min * 360,
      endAngle: endAngle - min * 360
    };
  };

  var reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor(angle, _ref4) {
    var startAngle = _ref4.startAngle,
        endAngle = _ref4.endAngle;
    var startCnt = Math.floor(startAngle / 360);
    var endCnt = Math.floor(endAngle / 360);
    var min = Math.min(startCnt, endCnt);
    return angle + min * 360;
  };

  var inRangeOfSector = function inRangeOfSector(_ref5, sector) {
    var x = _ref5.x,
        y = _ref5.y;

    var _getAngleOfPoint = getAngleOfPoint({
      x: x,
      y: y
    }, sector),
        radius = _getAngleOfPoint.radius,
        angle = _getAngleOfPoint.angle;

    var innerRadius = sector.innerRadius,
        outerRadius = sector.outerRadius;

    if (radius < innerRadius || radius > outerRadius) {
      return false;
    }

    if (radius === 0) {
      return true;
    }

    var _formatAngleOfSector = formatAngleOfSector(sector),
        startAngle = _formatAngleOfSector.startAngle,
        endAngle = _formatAngleOfSector.endAngle;

    var formatAngle = angle;
    var inRange;

    if (startAngle <= endAngle) {
      while (formatAngle > endAngle) {
        formatAngle -= 360;
      }

      while (formatAngle < startAngle) {
        formatAngle += 360;
      }

      inRange = formatAngle >= startAngle && formatAngle <= endAngle;
    } else {
      while (formatAngle > startAngle) {
        formatAngle -= 360;
      }

      while (formatAngle < endAngle) {
        formatAngle += 360;
      }

      inRange = formatAngle >= endAngle && formatAngle <= startAngle;
    }

    if (inRange) {
      return _objectSpread$g({}, sector, {
        radius: radius,
        angle: reverseFormatAngleOfSetor(formatAngle, sector)
      });
    }

    return null;
  };

  function _toConsumableArray$2(arr) { return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _nonIterableSpread$2(); }

  function _nonIterableSpread$2() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray$2(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles$2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _extends$i() { _extends$i = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$i.apply(this, arguments); }

  function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$f(source, true).forEach(function (key) { _defineProperty$h(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$h(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var cartesianViewBoxShape = propTypes$5.shape({
    x: propTypes$5.number,
    y: propTypes$5.number,
    width: propTypes$5.number,
    height: propTypes$5.number
  });
  var polarViewBoxShape = propTypes$5.shape({
    cx: propTypes$5.number,
    cy: propTypes$5.number,
    innerRadius: propTypes$5.number,
    outerRadius: propTypes$5.number,
    startAngle: propTypes$5.number,
    endAngle: propTypes$5.number
  });

  var propTypes$1 = _objectSpread$f({}, PRESENTATION_ATTRIBUTES, {
    viewBox: propTypes$5.oneOfType([cartesianViewBoxShape, polarViewBoxShape]),
    formatter: propTypes$5.func,
    value: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    offset: propTypes$5.number,
    position: propTypes$5.oneOf(['top', 'left', 'right', 'bottom', 'inside', 'outside', 'insideLeft', 'insideRight', 'insideTop', 'insideBottom', 'insideTopLeft', 'insideBottomLeft', 'insideTopRight', 'insideBottomRight', 'insideStart', 'insideEnd', 'end', 'center', 'centerTop', 'centerBottom']),
    children: propTypes$5.oneOfType([propTypes$5.arrayOf(propTypes$5.node), propTypes$5.node]),
    className: propTypes$5.string,
    content: propTypes$5.oneOfType([propTypes$5.element, propTypes$5.func])
  });

  var defaultProps$2 = {
    offset: 5
  };

  var getLabel = function getLabel(props) {
    var value = props.value,
        formatter = props.formatter;
    var label = isNil_1(props.children) ? value : props.children;

    if (isFunction_1(formatter)) {
      return formatter(label);
    }

    return label;
  };

  var getDeltaAngle$1 = function getDeltaAngle(startAngle, endAngle) {
    var sign = mathSign(endAngle - startAngle);
    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
    return sign * deltaAngle;
  };

  var renderRadialLabel = function renderRadialLabel(labelProps, label, attrs) {
    var position = labelProps.position,
        viewBox = labelProps.viewBox,
        offset = labelProps.offset,
        className = labelProps.className;
    var cx = viewBox.cx,
        cy = viewBox.cy,
        innerRadius = viewBox.innerRadius,
        outerRadius = viewBox.outerRadius,
        startAngle = viewBox.startAngle,
        endAngle = viewBox.endAngle,
        clockWise = viewBox.clockWise;
    var radius = (innerRadius + outerRadius) / 2;
    var deltaAngle = getDeltaAngle$1(startAngle, endAngle);
    var sign = deltaAngle >= 0 ? 1 : -1;
    var labelAngle, direction;

    if (position === 'insideStart') {
      labelAngle = startAngle + sign * offset;
      direction = clockWise;
    } else if (position === 'insideEnd') {
      labelAngle = endAngle - sign * offset;
      direction = !clockWise;
    } else if (position === 'end') {
      labelAngle = endAngle + sign * offset;
      direction = clockWise;
    }

    direction = deltaAngle <= 0 ? direction : !direction;
    var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
    var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
    var path = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
    var id = isNil_1(labelProps.id) ? uniqueId('recharts-radial-line-') : labelProps.id;
    return React__default['default'].createElement("text", _extends$i({}, attrs, {
      dominantBaseline: "central",
      className: classnames('recharts-radial-bar-label', className)
    }), React__default['default'].createElement("defs", null, React__default['default'].createElement("path", {
      id: id,
      d: path
    })), React__default['default'].createElement("textPath", {
      xlinkHref: "#".concat(id)
    }, label));
  };

  var getAttrsOfPolarLabel = function getAttrsOfPolarLabel(props) {
    var viewBox = props.viewBox,
        offset = props.offset,
        position = props.position;
    var cx = viewBox.cx,
        cy = viewBox.cy,
        innerRadius = viewBox.innerRadius,
        outerRadius = viewBox.outerRadius,
        startAngle = viewBox.startAngle,
        endAngle = viewBox.endAngle;
    var midAngle = (startAngle + endAngle) / 2;

    if (position === 'outside') {
      var _polarToCartesian = polarToCartesian(cx, cy, outerRadius + offset, midAngle),
          _x = _polarToCartesian.x,
          _y = _polarToCartesian.y;

      return {
        x: _x,
        y: _y,
        textAnchor: _x >= cx ? 'start' : 'end',
        verticalAnchor: 'middle'
      };
    }

    if (position === 'center') {
      return {
        x: cx,
        y: cy,
        textAnchor: 'middle',
        verticalAnchor: 'middle'
      };
    }

    if (position === 'centerTop') {
      return {
        x: cx,
        y: cy,
        textAnchor: 'middle',
        verticalAnchor: 'start'
      };
    }

    if (position === 'centerBottom') {
      return {
        x: cx,
        y: cy,
        textAnchor: 'middle',
        verticalAnchor: 'end'
      };
    }

    var r = (innerRadius + outerRadius) / 2;

    var _polarToCartesian2 = polarToCartesian(cx, cy, r, midAngle),
        x = _polarToCartesian2.x,
        y = _polarToCartesian2.y;

    return {
      x: x,
      y: y,
      textAnchor: 'middle',
      verticalAnchor: 'middle'
    };
  };

  var getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel(props) {
    var viewBox = props.viewBox,
        offset = props.offset,
        position = props.position;
    var x = viewBox.x,
        y = viewBox.y,
        width = viewBox.width,
        height = viewBox.height;
    var sign = height >= 0 ? 1 : -1;

    if (position === 'top') {
      return {
        x: x + width / 2,
        y: y - sign * offset,
        textAnchor: 'middle',
        verticalAnchor: sign > 0 ? 'end' : 'start'
      };
    }

    if (position === 'bottom') {
      return {
        x: x + width / 2,
        y: y + height + sign * offset,
        textAnchor: 'middle',
        verticalAnchor: 'start'
      };
    }

    if (position === 'left') {
      return {
        x: x - offset,
        y: y + height / 2,
        textAnchor: 'end',
        verticalAnchor: 'middle'
      };
    }

    if (position === 'right') {
      return {
        x: x + width + offset,
        y: y + height / 2,
        textAnchor: 'start',
        verticalAnchor: 'middle'
      };
    }

    if (position === 'insideLeft') {
      return {
        x: x + offset,
        y: y + height / 2,
        textAnchor: 'start',
        verticalAnchor: 'middle'
      };
    }

    if (position === 'insideRight') {
      return {
        x: x + width - offset,
        y: y + height / 2,
        textAnchor: 'end',
        verticalAnchor: 'middle'
      };
    }

    if (position === 'insideTop') {
      return {
        x: x + width / 2,
        y: y + sign * offset,
        textAnchor: 'middle',
        verticalAnchor: 'start'
      };
    }

    if (position === 'insideBottom') {
      return {
        x: x + width / 2,
        y: y + height - sign * offset,
        textAnchor: 'middle',
        verticalAnchor: 'end'
      };
    }

    if (position === 'insideTopLeft') {
      return {
        x: x + offset,
        y: y + sign * offset,
        textAnchor: 'start',
        verticalAnchor: 'start'
      };
    }

    if (position === 'insideTopRight') {
      return {
        x: x + width - offset,
        y: y + sign * offset,
        textAnchor: 'end',
        verticalAnchor: 'start'
      };
    }

    if (position === 'insideBottomLeft') {
      return {
        x: x + offset,
        y: y + height - sign * offset,
        textAnchor: 'start',
        verticalAnchor: 'end'
      };
    }

    if (position === 'insideBottomRight') {
      return {
        x: x + width - offset,
        y: y + height - sign * offset,
        textAnchor: 'end',
        verticalAnchor: 'end'
      };
    }

    if (isObject_1(position) && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) {
      return {
        x: x + getPercentValue(position.x, width),
        y: y + getPercentValue(position.y, height),
        textAnchor: 'end',
        verticalAnchor: 'end'
      };
    }

    return {
      x: x + width / 2,
      y: y + height / 2,
      textAnchor: 'middle',
      verticalAnchor: 'middle'
    };
  };

  var isPolar = function isPolar(viewBox) {
    return isNumber(viewBox.cx);
  };

  function Label$1(props) {
    var viewBox = props.viewBox,
        position = props.position,
        value = props.value,
        children = props.children,
        content = props.content,
        _props$className = props.className,
        className = _props$className === void 0 ? '' : _props$className;

    if (!viewBox || isNil_1(value) && isNil_1(children) && !React.isValidElement(content) && !isFunction_1(content)) {
      return null;
    }

    if (React.isValidElement(content)) {
      return React.cloneElement(content, props);
    }

    var label;

    if (isFunction_1(content)) {
      label = content(props);

      if (React.isValidElement(label)) {
        return label;
      }
    } else {
      label = getLabel(props);
    }

    var isPolarLabel = isPolar(viewBox);
    var attrs = getPresentationAttributes(props);
    var events = filterEventAttributes(props);

    if (isPolarLabel && (position === 'insideStart' || position === 'insideEnd' || position === 'end')) {
      return renderRadialLabel(props, label, attrs);
    }

    var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);
    return React__default['default'].createElement(Text, _extends$i({
      className: classnames('recharts-label', className)
    }, attrs, positionAttrs, events), label);
  }

  Label$1.displayName = 'Label';
  Label$1.defaultProps = defaultProps$2;
  Label$1.propTypes = propTypes$1;

  var parseViewBox = function parseViewBox(props) {
    var cx = props.cx,
        cy = props.cy,
        angle = props.angle,
        startAngle = props.startAngle,
        endAngle = props.endAngle,
        r = props.r,
        radius = props.radius,
        innerRadius = props.innerRadius,
        outerRadius = props.outerRadius,
        x = props.x,
        y = props.y,
        top = props.top,
        left = props.left,
        width = props.width,
        height = props.height,
        clockWise = props.clockWise;

    if (isNumber(width) && isNumber(height)) {
      if (isNumber(x) && isNumber(y)) {
        return {
          x: x,
          y: y,
          width: width,
          height: height
        };
      }

      if (isNumber(top) && isNumber(left)) {
        return {
          x: top,
          y: left,
          width: width,
          height: height
        };
      }
    }

    if (isNumber(x) && isNumber(y)) {
      return {
        x: x,
        y: y,
        width: 0,
        height: 0
      };
    }

    if (isNumber(cx) && isNumber(cy)) {
      return {
        cx: cx,
        cy: cy,
        startAngle: startAngle || angle || 0,
        endAngle: endAngle || angle || 0,
        innerRadius: innerRadius || 0,
        outerRadius: outerRadius || radius || r || 0,
        clockWise: clockWise
      };
    }

    if (props.viewBox) {
      return props.viewBox;
    }

    return {};
  };

  var parseLabel = function parseLabel(label, viewBox) {
    if (!label) {
      return null;
    }

    if (label === true) {
      return React__default['default'].createElement(Label$1, {
        key: "label-implicit",
        viewBox: viewBox
      });
    }

    if (isNumOrStr(label)) {
      return React__default['default'].createElement(Label$1, {
        key: "label-implicit",
        viewBox: viewBox,
        value: label
      });
    }

    if (React.isValidElement(label)) {
      if (label.type === Label$1) {
        return React.cloneElement(label, {
          key: 'label-implicit',
          viewBox: viewBox
        });
      }

      return React__default['default'].createElement(Label$1, {
        key: "label-implicit",
        content: label,
        viewBox: viewBox
      });
    }

    if (isFunction_1(label)) {
      return React__default['default'].createElement(Label$1, {
        key: "label-implicit",
        content: label,
        viewBox: viewBox
      });
    }

    if (isObject_1(label)) {
      return React__default['default'].createElement(Label$1, _extends$i({
        viewBox: viewBox
      }, label, {
        key: "label-implicit"
      }));
    }

    return null;
  };

  var renderCallByParent$1 = function renderCallByParent(parentProps, viewBox) {
    var ckeckPropsLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (!parentProps || !parentProps.children && ckeckPropsLabel && !parentProps.label) {
      return null;
    }

    var children = parentProps.children;
    var parentViewBox = parseViewBox(parentProps);
    var explicitChilren = findAllByType(children, Label$1).map(function (child, index) {
      return React.cloneElement(child, {
        viewBox: viewBox || parentViewBox,
        key: "label-".concat(index)
      });
    });

    if (!ckeckPropsLabel) {
      return explicitChilren;
    }

    var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox);
    return [implicitLabel].concat(_toConsumableArray$2(explicitChilren));
  };

  Label$1.parseViewBox = parseViewBox;
  Label$1.renderCallByParent = renderCallByParent$1;

  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  var last_1 = last;

  function _toConsumableArray$1(arr) { return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1(); }

  function _nonIterableSpread$1() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray$1(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _extends$h() { _extends$h = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$h.apply(this, arguments); }

  function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(source, true).forEach(function (key) { _defineProperty$g(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$g(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _objectWithoutProperties$3(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$4(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$4(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
  var propTypes = {
    id: propTypes$5.string,
    data: propTypes$5.arrayOf(propTypes$5.object),
    valueAccessor: propTypes$5.func,
    clockWise: propTypes$5.bool,
    dataKey: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number, propTypes$5.func])
  };
  var defaultProps$1 = {
    valueAccessor: function valueAccessor(entry) {
      return isArray_1(entry.value) ? last_1(entry.value) : entry.value;
    }
  };

  function LabelList(props) {
    var data = props.data,
        valueAccessor = props.valueAccessor,
        dataKey = props.dataKey,
        clockWise = props.clockWise,
        id = props.id,
        others = _objectWithoutProperties$3(props, ["data", "valueAccessor", "dataKey", "clockWise", "id"]);

    if (!data || !data.length) {
      return null;
    }

    return React__default['default'].createElement(Layer, {
      className: "recharts-label-list"
    }, data.map(function (entry, index) {
      var value = isNil_1(dataKey) ? valueAccessor(entry, index) : getValueByDataKey(entry && entry.payload, dataKey);
      var idProps = isNil_1(id) ? {} : {
        id: "".concat(id, "-").concat(index)
      };
      return React__default['default'].createElement(Label$1, _extends$h({}, getPresentationAttributes(entry), others, idProps, {
        index: index,
        value: value,
        viewBox: Label$1.parseViewBox(isNil_1(clockWise) ? entry : _objectSpread$e({}, entry, {
          clockWise: clockWise
        })),
        key: "label-".concat(index) // eslint-disable-line react/no-array-index-key

      }));
    }));
  }

  LabelList.propTypes = propTypes;
  LabelList.displayName = 'LabelList';

  var parseLabelList = function parseLabelList(label, data) {
    if (!label) {
      return null;
    }

    if (label === true) {
      return React__default['default'].createElement(LabelList, {
        key: "labelList-implicit",
        data: data
      });
    }

    if (React__default['default'].isValidElement(label) || isFunction_1(label)) {
      return React__default['default'].createElement(LabelList, {
        key: "labelList-implicit",
        data: data,
        content: label
      });
    }

    if (isObject_1(label)) {
      return React__default['default'].createElement(LabelList, _extends$h({
        data: data
      }, label, {
        key: "labelList-implicit"
      }));
    }

    return null;
  };

  var renderCallByParent = function renderCallByParent(parentProps, data) {
    var ckeckPropsLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (!parentProps || !parentProps.children && ckeckPropsLabel && !parentProps.label) {
      return null;
    }

    var children = parentProps.children;
    var explicitChilren = findAllByType(children, LabelList).map(function (child, index) {
      return React.cloneElement(child, {
        data: data,
        key: "labelList-".concat(index)
      });
    });

    if (!ckeckPropsLabel) {
      return explicitChilren;
    }

    var implicitLabelList = parseLabelList(parentProps.label, data);
    return [implicitLabelList].concat(_toConsumableArray$1(explicitChilren));
  };

  LabelList.renderCallByParent = renderCallByParent;
  LabelList.defaultProps = defaultProps$1;

  function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(source, true).forEach(function (key) { _defineProperty$f(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$f(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof$e(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$e = function _typeof(obj) { return typeof obj; }; } else { _typeof$e = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$e(obj); }

  function _extends$g() { _extends$g = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$g.apply(this, arguments); }

  function _classCallCheck$f(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$f(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$f(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$f(Constructor.prototype, protoProps); if (staticProps) _defineProperties$f(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$e(self, call) { if (call && (_typeof$e(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$f(self); }

  function _assertThisInitialized$f(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$e(o) { _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$e(o); }

  function _inherits$e(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$e(subClass, superClass); }

  function _setPrototypeOf$e(o, p) { _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$e(o, p); }

  var getDeltaAngle = function getDeltaAngle(startAngle, endAngle) {
    var sign = mathSign(endAngle - startAngle);
    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
    return sign * deltaAngle;
  };

  var getTangentCircle = function getTangentCircle(_ref) {
    var cx = _ref.cx,
        cy = _ref.cy,
        radius = _ref.radius,
        angle = _ref.angle,
        sign = _ref.sign,
        isExternal = _ref.isExternal,
        cornerRadius = _ref.cornerRadius,
        cornerIsExternal = _ref.cornerIsExternal;
    var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
    var theta = Math.asin(cornerRadius / centerRadius) / RADIAN$1;
    var centerAngle = cornerIsExternal ? angle : angle + sign * theta;
    var center = polarToCartesian(cx, cy, centerRadius, centerAngle); // The coordinate of point which is tangent to the circle

    var circleTangency = polarToCartesian(cx, cy, radius, centerAngle); // The coordinate of point which is tangent to the radius line

    var lineTangencyAngle = cornerIsExternal ? angle - sign * theta : angle;
    var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN$1), lineTangencyAngle);
    return {
      center: center,
      circleTangency: circleTangency,
      lineTangency: lineTangency,
      theta: theta
    };
  };

  var getSectorPath = function getSectorPath(_ref2) {
    var cx = _ref2.cx,
        cy = _ref2.cy,
        innerRadius = _ref2.innerRadius,
        outerRadius = _ref2.outerRadius,
        startAngle = _ref2.startAngle,
        endAngle = _ref2.endAngle;
    var angle = getDeltaAngle(startAngle, endAngle); // When the angle of sector equals to 360, star point and end point coincide

    var tempEndAngle = startAngle + angle;
    var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
    var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
    var path = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");

    if (innerRadius > 0) {
      var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
      var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
      path += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
    } else {
      path += "L ".concat(cx, ",").concat(cy, " Z");
    }

    return path;
  };

  var getSectorWithCorner = function getSectorWithCorner(_ref3) {
    var cx = _ref3.cx,
        cy = _ref3.cy,
        innerRadius = _ref3.innerRadius,
        outerRadius = _ref3.outerRadius,
        cornerRadius = _ref3.cornerRadius,
        forceCornerRadius = _ref3.forceCornerRadius,
        cornerIsExternal = _ref3.cornerIsExternal,
        startAngle = _ref3.startAngle,
        endAngle = _ref3.endAngle;
    var sign = mathSign(endAngle - startAngle);

    var _getTangentCircle = getTangentCircle({
      cx: cx,
      cy: cy,
      radius: outerRadius,
      angle: startAngle,
      sign: sign,
      cornerRadius: cornerRadius,
      cornerIsExternal: cornerIsExternal
    }),
        soct = _getTangentCircle.circleTangency,
        solt = _getTangentCircle.lineTangency,
        sot = _getTangentCircle.theta;

    var _getTangentCircle2 = getTangentCircle({
      cx: cx,
      cy: cy,
      radius: outerRadius,
      angle: endAngle,
      sign: -sign,
      cornerRadius: cornerRadius,
      cornerIsExternal: cornerIsExternal
    }),
        eoct = _getTangentCircle2.circleTangency,
        eolt = _getTangentCircle2.lineTangency,
        eot = _getTangentCircle2.theta;

    var outerArcAngle = Math.abs(startAngle - endAngle) - sot - eot;

    if (outerArcAngle < 0) {
      if (forceCornerRadius) {
        return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
      }

      return getSectorPath({
        cx: cx,
        cy: cy,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        startAngle: startAngle,
        endAngle: endAngle
      });
    }

    var path = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");

    if (innerRadius > 0) {
      var _getTangentCircle3 = getTangentCircle({
        cx: cx,
        cy: cy,
        radius: innerRadius,
        angle: startAngle,
        sign: sign,
        isExternal: true,
        cornerRadius: cornerRadius,
        cornerIsExternal: cornerIsExternal
      }),
          sict = _getTangentCircle3.circleTangency,
          silt = _getTangentCircle3.lineTangency,
          sit = _getTangentCircle3.theta;

      var _getTangentCircle4 = getTangentCircle({
        cx: cx,
        cy: cy,
        radius: innerRadius,
        angle: endAngle,
        sign: -sign,
        isExternal: true,
        cornerRadius: cornerRadius,
        cornerIsExternal: cornerIsExternal
      }),
          eict = _getTangentCircle4.circleTangency,
          eilt = _getTangentCircle4.lineTangency,
          eit = _getTangentCircle4.theta;

      var innerArcAngle = Math.abs(startAngle - endAngle) - sit - eit;

      if (innerArcAngle < 0) {
        return "".concat(path, "L").concat(cx, ",").concat(cy, "Z");
      }

      path += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
    } else {
      path += "L".concat(cx, ",").concat(cy, "Z");
    }

    return path;
  };

  var Sector =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$e(Sector, _PureComponent);

    function Sector() {
      _classCallCheck$f(this, Sector);

      return _possibleConstructorReturn$e(this, _getPrototypeOf$e(Sector).apply(this, arguments));
    }

    _createClass$f(Sector, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            cx = _this$props.cx,
            cy = _this$props.cy,
            innerRadius = _this$props.innerRadius,
            outerRadius = _this$props.outerRadius,
            cornerRadius = _this$props.cornerRadius,
            forceCornerRadius = _this$props.forceCornerRadius,
            cornerIsExternal = _this$props.cornerIsExternal,
            startAngle = _this$props.startAngle,
            endAngle = _this$props.endAngle,
            className = _this$props.className;

        if (outerRadius < innerRadius || startAngle === endAngle) {
          return null;
        }

        var layerClass = classnames('recharts-sector', className);
        var deltaRadius = outerRadius - innerRadius;
        var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
        var path;

        if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
          path = getSectorWithCorner({
            cx: cx,
            cy: cy,
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            cornerRadius: Math.min(cr, deltaRadius / 2),
            forceCornerRadius: forceCornerRadius,
            cornerIsExternal: cornerIsExternal,
            startAngle: startAngle,
            endAngle: endAngle
          });
        } else {
          path = getSectorPath({
            cx: cx,
            cy: cy,
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            startAngle: startAngle,
            endAngle: endAngle
          });
        }

        return React__default['default'].createElement("path", _extends$g({}, getPresentationAttributes(this.props), filterEventAttributes(this.props), {
          className: layerClass,
          d: path
        }));
      }
    }]);

    return Sector;
  }(React.PureComponent);

  Sector.displayName = 'Sector';
  Sector.propTypes = _objectSpread$d({}, PRESENTATION_ATTRIBUTES, {
    className: propTypes$5.string,
    cx: propTypes$5.number,
    cy: propTypes$5.number,
    innerRadius: propTypes$5.number,
    outerRadius: propTypes$5.number,
    startAngle: propTypes$5.number,
    endAngle: propTypes$5.number,
    cornerRadius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    forceCornerRadius: propTypes$5.bool,
    cornerIsExternal: propTypes$5.bool
  });
  Sector.defaultProps = {
    cx: 0,
    cy: 0,
    innerRadius: 0,
    outerRadius: 0,
    startAngle: 0,
    endAngle: 0,
    cornerRadius: 0,
    forceCornerRadius: false,
    cornerIsExternal: false
  };

  function _typeof$d(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$d = function _typeof(obj) { return typeof obj; }; } else { _typeof$d = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$d(obj); }

  function _extends$f() { _extends$f = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$f.apply(this, arguments); }

  function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(source, true).forEach(function (key) { _defineProperty$e(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$e(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$e(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$e(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$e(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$e(Constructor.prototype, protoProps); if (staticProps) _defineProperties$e(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$d(self, call) { if (call && (_typeof$d(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$e(self); }

  function _assertThisInitialized$e(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$d(o) { _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$d(o); }

  function _inherits$d(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$d(subClass, superClass); }

  function _setPrototypeOf$d(o, p) { _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$d(o, p); }
  var CURVE_FACTORIES = {
    curveBasisClosed: curveBasisClosed,
    curveBasisOpen: curveBasisOpen,
    curveBasis: curveBasis,
    curveLinearClosed: curveLinearClosed,
    curveLinear: curveLinear,
    curveMonotoneX: monotoneX,
    curveMonotoneY: monotoneY,
    curveNatural: curveNatural,
    curveStep: curveStep,
    curveStepAfter: stepAfter,
    curveStepBefore: stepBefore
  };

  var defined = function defined(p) {
    return p.x === +p.x && p.y === +p.y;
  };

  var getX = function getX(p) {
    return p.x;
  };

  var getY = function getY(p) {
    return p.y;
  };

  var getCurveFactory = function getCurveFactory(type, layout) {
    if (isFunction_1(type)) {
      return type;
    }

    var name = "curve".concat(type.slice(0, 1).toUpperCase()).concat(type.slice(1));

    if (name === 'curveMonotone' && layout) {
      return CURVE_FACTORIES["".concat(name).concat(layout === 'vertical' ? 'Y' : 'X')];
    }

    return CURVE_FACTORIES[name] || curveLinear;
  };

  var Curve =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$d(Curve, _PureComponent);

    function Curve() {
      _classCallCheck$e(this, Curve);

      return _possibleConstructorReturn$d(this, _getPrototypeOf$d(Curve).apply(this, arguments));
    }

    _createClass$e(Curve, [{
      key: "getPath",

      /**
       * Calculate the path of curve
       * @return {String} path
       */
      value: function getPath() {
        var _this$props = this.props,
            type = _this$props.type,
            points = _this$props.points,
            baseLine = _this$props.baseLine,
            layout = _this$props.layout,
            connectNulls = _this$props.connectNulls;
        var curveFactory = getCurveFactory(type, layout);
        var formatPoints = connectNulls ? points.filter(function (entry) {
          return defined(entry);
        }) : points;
        var lineFunction;

        if (isArray_1(baseLine)) {
          var formatBaseLine = connectNulls ? baseLine.filter(function (base) {
            return defined(base);
          }) : baseLine;
          var areaPoints = formatPoints.map(function (entry, index) {
            return _objectSpread$c({}, entry, {
              base: formatBaseLine[index]
            });
          });

          if (layout === 'vertical') {
            lineFunction = shapeArea().y(getY).x1(getX).x0(function (d) {
              return d.base.x;
            });
          } else {
            lineFunction = shapeArea().x(getX).y1(getY).y0(function (d) {
              return d.base.y;
            });
          }

          lineFunction.defined(defined).curve(curveFactory);
          return lineFunction(areaPoints);
        }

        if (layout === 'vertical' && isNumber(baseLine)) {
          lineFunction = shapeArea().y(getY).x1(getX).x0(baseLine);
        } else if (isNumber(baseLine)) {
          lineFunction = shapeArea().x(getX).y1(getY).y0(baseLine);
        } else {
          lineFunction = shapeLine().x(getX).y(getY);
        }

        lineFunction.defined(defined).curve(curveFactory);
        return lineFunction(formatPoints);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            className = _this$props2.className,
            points = _this$props2.points,
            path = _this$props2.path,
            pathRef = _this$props2.pathRef;

        if ((!points || !points.length) && !path) {
          return null;
        }

        var realPath = points && points.length ? this.getPath() : path;
        return React__default['default'].createElement("path", _extends$f({}, getPresentationAttributes(this.props), filterEventAttributes(this.props, null, true), {
          className: classnames('recharts-curve', className),
          d: realPath,
          ref: pathRef
        }));
      }
    }]);

    return Curve;
  }(React.PureComponent);

  Curve.displayName = 'Curve';
  Curve.propTypes = _objectSpread$c({}, PRESENTATION_ATTRIBUTES, {
    className: propTypes$5.string,
    type: propTypes$5.oneOfType([propTypes$5.oneOf(['basis', 'basisClosed', 'basisOpen', 'linear', 'linearClosed', 'natural', 'monotoneX', 'monotoneY', 'monotone', 'step', 'stepBefore', 'stepAfter']), propTypes$5.func]),
    layout: propTypes$5.oneOf(['horizontal', 'vertical']),
    baseLine: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.array]),
    points: propTypes$5.arrayOf(propTypes$5.object),
    connectNulls: propTypes$5.bool,
    path: propTypes$5.string,
    pathRef: propTypes$5.func
  });
  Curve.defaultProps = {
    type: 'linear',
    points: [],
    connectNulls: false
  };

  function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(source, true).forEach(function (key) { _defineProperty$d(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$d(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof$c(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$c = function _typeof(obj) { return typeof obj; }; } else { _typeof$c = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$c(obj); }

  function _extends$e() { _extends$e = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$e.apply(this, arguments); }

  function _classCallCheck$d(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$d(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$d(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$d(Constructor.prototype, protoProps); if (staticProps) _defineProperties$d(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$c(self, call) { if (call && (_typeof$c(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$d(self); }

  function _assertThisInitialized$d(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$c(o) { _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$c(o); }

  function _inherits$c(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$c(subClass, superClass); }

  function _setPrototypeOf$c(o, p) { _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$c(o, p); }

  var getRectangePath = function getRectangePath(x, y, width, height, radius) {
    var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
    var ySign = height >= 0 ? 1 : -1;
    var xSign = width >= 0 ? 1 : -1;
    var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
    var path;

    if (maxRadius > 0 && radius instanceof Array) {
      var newRadius = [];

      for (var i = 0, len = 4; i < len; i++) {
        newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
      }

      path = "M".concat(x, ",").concat(y + ySign * newRadius[0]);

      if (newRadius[0] > 0) {
        path += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x + xSign * newRadius[0], ",").concat(y);
      }

      path += "L ".concat(x + width - xSign * newRadius[1], ",").concat(y);

      if (newRadius[1] > 0) {
        path += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x + width, ",").concat(y + ySign * newRadius[1]);
      }

      path += "L ".concat(x + width, ",").concat(y + height - ySign * newRadius[2]);

      if (newRadius[2] > 0) {
        path += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x + width - xSign * newRadius[2], ",").concat(y + height);
      }

      path += "L ".concat(x + xSign * newRadius[3], ",").concat(y + height);

      if (newRadius[3] > 0) {
        path += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x, ",").concat(y + height - ySign * newRadius[3]);
      }

      path += 'Z';
    } else if (maxRadius > 0 && radius === +radius && radius > 0) {
      var _newRadius = Math.min(maxRadius, radius);

      path = "M ".concat(x, ",").concat(y + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + xSign * _newRadius, ",").concat(y, "\n            L ").concat(x + width - xSign * _newRadius, ",").concat(y, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + width, ",").concat(y + ySign * _newRadius, "\n            L ").concat(x + width, ",").concat(y + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + width - xSign * _newRadius, ",").concat(y + height, "\n            L ").concat(x + xSign * _newRadius, ",").concat(y + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x, ",").concat(y + height - ySign * _newRadius, " Z");
    } else {
      path = "M ".concat(x, ",").concat(y, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
    }

    return path;
  };

  var Rectangle =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$c(Rectangle, _PureComponent);

    function Rectangle() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck$d(this, Rectangle);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn$c(this, (_getPrototypeOf2 = _getPrototypeOf$c(Rectangle)).call.apply(_getPrototypeOf2, [this].concat(args)));
      _this.state = {
        totalLength: -1
      };
      return _this;
    }

    _createClass$d(Rectangle, [{
      key: "componentDidMount",

      /* eslint-disable  react/no-did-mount-set-state */
      value: function componentDidMount() {
        if (this.node && this.node.getTotalLength) {
          try {
            var totalLength = this.node.getTotalLength();

            if (totalLength) {
              this.setState({
                totalLength: totalLength
              });
            }
          } catch (err) {// calculate total length error
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            x = _this$props.x,
            y = _this$props.y,
            width = _this$props.width,
            height = _this$props.height,
            radius = _this$props.radius,
            className = _this$props.className;
        var totalLength = this.state.totalLength;
        var _this$props2 = this.props,
            animationEasing = _this$props2.animationEasing,
            animationDuration = _this$props2.animationDuration,
            animationBegin = _this$props2.animationBegin,
            isAnimationActive = _this$props2.isAnimationActive,
            isUpdateAnimationActive = _this$props2.isUpdateAnimationActive;

        if (x !== +x || y !== +y || width !== +width || height !== +height || width === 0 || height === 0) {
          return null;
        }

        var layerClass = classnames('recharts-rectangle', className);

        if (!isUpdateAnimationActive) {
          return React__default['default'].createElement("path", _extends$e({}, getPresentationAttributes(this.props), filterEventAttributes(this.props), {
            className: layerClass,
            d: getRectangePath(x, y, width, height, radius)
          }));
        }

        return React__default['default'].createElement(Animate, {
          canBegin: totalLength > 0,
          from: {
            width: width,
            height: height,
            x: x,
            y: y
          },
          to: {
            width: width,
            height: height,
            x: x,
            y: y
          },
          duration: animationDuration,
          animationEasing: animationEasing,
          isActive: isUpdateAnimationActive
        }, function (_ref) {
          var currWidth = _ref.width,
              currHeight = _ref.height,
              currX = _ref.x,
              currY = _ref.y;
          return React__default['default'].createElement(Animate, {
            canBegin: totalLength > 0,
            from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
            to: "".concat(totalLength, "px 0px"),
            attributeName: "strokeDasharray",
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing
          }, React__default['default'].createElement("path", _extends$e({}, getPresentationAttributes(_this2.props), filterEventAttributes(_this2.props), {
            className: layerClass,
            d: getRectangePath(currX, currY, currWidth, currHeight, radius),
            ref: function ref(node) {
              _this2.node = node;
            }
          })));
        });
      }
    }]);

    return Rectangle;
  }(React.PureComponent);

  Rectangle.displayName = 'Rectangle';
  Rectangle.propTypes = _objectSpread$b({}, PRESENTATION_ATTRIBUTES, {}, EVENT_ATTRIBUTES, {
    className: propTypes$5.string,
    x: propTypes$5.number,
    y: propTypes$5.number,
    width: propTypes$5.number,
    height: propTypes$5.number,
    radius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.array]),
    isAnimationActive: propTypes$5.bool,
    isUpdateAnimationActive: propTypes$5.bool,
    animationBegin: propTypes$5.number,
    animationDuration: propTypes$5.number,
    animationEasing: propTypes$5.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear'])
  });
  Rectangle.defaultProps = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    // The radius of border
    // The radius of four corners when radius is a number
    // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
    radius: 0,
    isAnimationActive: false,
    isUpdateAnimationActive: false,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: 'ease'
  };

  function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(source, true).forEach(function (key) { _defineProperty$c(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof$b(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$b = function _typeof(obj) { return typeof obj; }; } else { _typeof$b = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$b(obj); }

  function _extends$d() { _extends$d = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$d.apply(this, arguments); }

  function _classCallCheck$c(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$c(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$c(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$c(Constructor.prototype, protoProps); if (staticProps) _defineProperties$c(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$b(self, call) { if (call && (_typeof$b(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$c(self); }

  function _assertThisInitialized$c(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$b(o) { _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$b(o); }

  function _inherits$b(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$b(subClass, superClass); }

  function _setPrototypeOf$b(o, p) { _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$b(o, p); }

  var getPolygonPoints = function getPolygonPoints(points) {
    return points.reduce(function (result, entry) {
      if (entry.x === +entry.x && entry.y === +entry.y) {
        result.push([entry.x, entry.y]);
      }

      return result;
    }, []).join(' ');
  };

  var Polygon =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$b(Polygon, _PureComponent);

    function Polygon() {
      _classCallCheck$c(this, Polygon);

      return _possibleConstructorReturn$b(this, _getPrototypeOf$b(Polygon).apply(this, arguments));
    }

    _createClass$c(Polygon, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            points = _this$props.points,
            className = _this$props.className;

        if (!points || !points.length) {
          return null;
        }

        var layerClass = classnames('recharts-polygon', className);
        return React__default['default'].createElement("polygon", _extends$d({}, getPresentationAttributes(this.props), filterEventAttributes(this.props), {
          className: layerClass,
          points: getPolygonPoints(points)
        }));
      }
    }]);

    return Polygon;
  }(React.PureComponent);

  Polygon.displayName = 'Polygon';
  Polygon.propTypes = _objectSpread$a({}, PRESENTATION_ATTRIBUTES, {
    className: propTypes$5.string,
    points: propTypes$5.arrayOf(propTypes$5.shape({
      x: propTypes$5.number,
      y: propTypes$5.number
    }))
  });

  function _typeof$a(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$a = function _typeof(obj) { return typeof obj; }; } else { _typeof$a = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$a(obj); }

  function _extends$c() { _extends$c = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$c.apply(this, arguments); }

  function _classCallCheck$b(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$b(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$b(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$b(Constructor.prototype, protoProps); if (staticProps) _defineProperties$b(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$a(self, call) { if (call && (_typeof$a(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$b(self); }

  function _assertThisInitialized$b(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$a(o) { _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$a(o); }

  function _inherits$a(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$a(subClass, superClass); }

  function _setPrototypeOf$a(o, p) { _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$a(o, p); }

  var Dot =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$a(Dot, _PureComponent);

    function Dot() {
      _classCallCheck$b(this, Dot);

      return _possibleConstructorReturn$a(this, _getPrototypeOf$a(Dot).apply(this, arguments));
    }

    _createClass$b(Dot, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            cx = _this$props.cx,
            cy = _this$props.cy,
            r = _this$props.r,
            className = _this$props.className;
        var layerClass = classnames('recharts-dot', className);

        if (cx === +cx && cy === +cy && r === +r) {
          return React__default['default'].createElement("circle", _extends$c({}, getPresentationAttributes(this.props), filterEventAttributes(this.props, null, true), {
            className: layerClass,
            cx: cx,
            cy: cy,
            r: r
          }));
        }

        return null;
      }
    }]);

    return Dot;
  }(React.PureComponent);

  Dot.displayName = 'Dot';
  Dot.propTypes = {
    className: propTypes$5.string,
    cx: propTypes$5.number,
    cy: propTypes$5.number,
    r: propTypes$5.number
  };

  function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(source, true).forEach(function (key) { _defineProperty$b(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof$9(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$9 = function _typeof(obj) { return typeof obj; }; } else { _typeof$9 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$9(obj); }

  function _extends$b() { _extends$b = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$b.apply(this, arguments); }

  function _classCallCheck$a(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$a(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$a(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$a(Constructor.prototype, protoProps); if (staticProps) _defineProperties$a(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$9(self, call) { if (call && (_typeof$9(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$a(self); }

  function _assertThisInitialized$a(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$9(o) { _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$9(o); }

  function _inherits$9(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$9(subClass, superClass); }

  function _setPrototypeOf$9(o, p) { _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$9(o, p); }

  var Cross =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$9(Cross, _PureComponent);

    function Cross() {
      _classCallCheck$a(this, Cross);

      return _possibleConstructorReturn$9(this, _getPrototypeOf$9(Cross).apply(this, arguments));
    }

    _createClass$a(Cross, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            x = _this$props.x,
            y = _this$props.y,
            width = _this$props.width,
            height = _this$props.height,
            top = _this$props.top,
            left = _this$props.left,
            className = _this$props.className;

        if (!isNumber(x) || !isNumber(y) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
          return null;
        }

        return React__default['default'].createElement("path", _extends$b({}, getPresentationAttributes(this.props), {
          className: classnames('recharts-cross', className),
          d: this.constructor.getPath(x, y, width, height, top, left)
        }));
      }
    }], [{
      key: "getPath",
      value: function getPath(x, y, width, height, top, left) {
        return "M".concat(x, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y, "h").concat(width);
      }
    }]);

    return Cross;
  }(React.PureComponent);

  Cross.displayName = 'Cross';
  Cross.propTypes = _objectSpread$9({}, PRESENTATION_ATTRIBUTES, {
    x: propTypes$5.number,
    y: propTypes$5.number,
    width: propTypes$5.number,
    height: propTypes$5.number,
    top: propTypes$5.number,
    left: propTypes$5.number,
    className: propTypes$5.string
  });
  Cross.defaultProps = {
    x: 0,
    y: 0,
    top: 0,
    left: 0,
    width: 0,
    height: 0
  };

  /**
   * This method is like `_.min` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * the value is ranked. The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * var objects = [{ 'n': 1 }, { 'n': 2 }];
   *
   * _.minBy(objects, function(o) { return o.n; });
   * // => { 'n': 1 }
   *
   * // The `_.property` iteratee shorthand.
   * _.minBy(objects, 'n');
   * // => { 'n': 1 }
   */
  function minBy(array, iteratee) {
    return (array && array.length)
      ? _baseExtremum(array, _baseIteratee(iteratee), _baseLt)
      : undefined;
  }

  var minBy_1 = minBy;

  /**
   * This method is like `_.max` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * the value is ranked. The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * var objects = [{ 'n': 1 }, { 'n': 2 }];
   *
   * _.maxBy(objects, function(o) { return o.n; });
   * // => { 'n': 2 }
   *
   * // The `_.property` iteratee shorthand.
   * _.maxBy(objects, 'n');
   * // => { 'n': 2 }
   */
  function maxBy(array, iteratee) {
    return (array && array.length)
      ? _baseExtremum(array, _baseIteratee(iteratee), _baseGt)
      : undefined;
  }

  var maxBy_1 = maxBy;

  function _typeof$8(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$8 = function _typeof(obj) { return typeof obj; }; } else { _typeof$8 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$8(obj); }

  function _extends$a() { _extends$a = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$a.apply(this, arguments); }

  function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(source, true).forEach(function (key) { _defineProperty$a(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _objectWithoutProperties$2(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$3(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$3(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$9(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$9(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$9(Constructor.prototype, protoProps); if (staticProps) _defineProperties$9(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$8(self, call) { if (call && (_typeof$8(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$9(self); }

  function _assertThisInitialized$9(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$8(o) { _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$8(o); }

  function _inherits$8(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$8(subClass, superClass); }

  function _setPrototypeOf$8(o, p) { _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$8(o, p); }

  var PolarRadiusAxis =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$8(PolarRadiusAxis, _PureComponent);

    function PolarRadiusAxis() {
      _classCallCheck$9(this, PolarRadiusAxis);

      return _possibleConstructorReturn$8(this, _getPrototypeOf$8(PolarRadiusAxis).apply(this, arguments));
    }

    _createClass$9(PolarRadiusAxis, [{
      key: "getTickValueCoord",

      /**
       * Calculate the coordinate of tick
       * @param  {Number} coordinate The radius of tick
       * @return {Object} (x, y)
       */
      value: function getTickValueCoord(_ref) {
        var coordinate = _ref.coordinate;
        var _this$props = this.props,
            angle = _this$props.angle,
            cx = _this$props.cx,
            cy = _this$props.cy;
        return polarToCartesian(cx, cy, coordinate, angle);
      }
    }, {
      key: "getTickTextAnchor",
      value: function getTickTextAnchor() {
        var orientation = this.props.orientation;
        var textAnchor;

        switch (orientation) {
          case 'left':
            textAnchor = 'end';
            break;

          case 'right':
            textAnchor = 'start';
            break;

          default:
            textAnchor = 'middle';
            break;
        }

        return textAnchor;
      }
    }, {
      key: "getViewBox",
      value: function getViewBox() {
        var _this$props2 = this.props,
            cx = _this$props2.cx,
            cy = _this$props2.cy,
            angle = _this$props2.angle,
            ticks = _this$props2.ticks;

        var maxRadiusTick = maxBy_1(ticks, function (entry) {
          return entry.coordinate || 0;
        });

        var minRadiusTick = minBy_1(ticks, function (entry) {
          return entry.coordinate || 0;
        });

        return {
          cx: cx,
          cy: cy,
          startAngle: angle,
          endAngle: angle,
          innerRadius: minRadiusTick.coordinate || 0,
          outerRadius: maxRadiusTick.coordinate || 0
        };
      }
    }, {
      key: "renderAxisLine",
      value: function renderAxisLine() {
        var _this$props3 = this.props,
            cx = _this$props3.cx,
            cy = _this$props3.cy,
            angle = _this$props3.angle,
            ticks = _this$props3.ticks,
            axisLine = _this$props3.axisLine,
            others = _objectWithoutProperties$2(_this$props3, ["cx", "cy", "angle", "ticks", "axisLine"]);

        var extent = ticks.reduce(function (result, entry) {
          return [Math.min(result[0], entry.coordinate), Math.max(result[1], entry.coordinate)];
        }, [Infinity, -Infinity]);
        var point0 = polarToCartesian(cx, cy, extent[0], angle);
        var point1 = polarToCartesian(cx, cy, extent[1], angle);

        var props = _objectSpread$8({}, getPresentationAttributes(others), {
          fill: 'none'
        }, getPresentationAttributes(axisLine), {
          x1: point0.x,
          y1: point0.y,
          x2: point1.x,
          y2: point1.y
        });

        return React__default['default'].createElement("line", _extends$a({
          className: "recharts-polar-radius-axis-line"
        }, props));
      }
    }, {
      key: "renderTicks",
      value: function renderTicks() {
        var _this = this;

        var _this$props4 = this.props,
            ticks = _this$props4.ticks,
            tick = _this$props4.tick,
            angle = _this$props4.angle,
            tickFormatter = _this$props4.tickFormatter,
            stroke = _this$props4.stroke,
            others = _objectWithoutProperties$2(_this$props4, ["ticks", "tick", "angle", "tickFormatter", "stroke"]);

        var textAnchor = this.getTickTextAnchor();
        var axisProps = getPresentationAttributes(others);
        var customTickProps = getPresentationAttributes(tick);
        var items = ticks.map(function (entry, i) {
          var coord = _this.getTickValueCoord(entry);

          var tickProps = _objectSpread$8({
            textAnchor: textAnchor,
            transform: "rotate(".concat(90 - angle, ", ").concat(coord.x, ", ").concat(coord.y, ")")
          }, axisProps, {
            stroke: 'none',
            fill: stroke
          }, customTickProps, {
            index: i
          }, coord, {
            payload: entry
          });

          return React__default['default'].createElement(Layer, _extends$a({
            className: "recharts-polar-radius-axis-tick",
            key: "tick-".concat(i) // eslint-disable-line react/no-array-index-key

          }, filterEventsOfChild(_this.props, entry, i)), _this.constructor.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value) : entry.value));
        });
        return React__default['default'].createElement(Layer, {
          className: "recharts-polar-radius-axis-ticks"
        }, items);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props5 = this.props,
            ticks = _this$props5.ticks,
            axisLine = _this$props5.axisLine,
            tick = _this$props5.tick;

        if (!ticks || !ticks.length) {
          return null;
        }

        return React__default['default'].createElement(Layer, {
          className: "recharts-polar-radius-axis"
        }, axisLine && this.renderAxisLine(), tick && this.renderTicks(), Label$1.renderCallByParent(this.props, this.getViewBox()));
      }
    }], [{
      key: "renderTickItem",
      value: function renderTickItem(option, props, value) {
        var tickItem;

        if (React__default['default'].isValidElement(option)) {
          tickItem = React__default['default'].cloneElement(option, props);
        } else if (isFunction_1(option)) {
          tickItem = option(props);
        } else {
          tickItem = React__default['default'].createElement(Text, _extends$a({}, props, {
            className: "recharts-polar-radius-axis-tick-value"
          }), value);
        }

        return tickItem;
      }
    }]);

    return PolarRadiusAxis;
  }(React.PureComponent);

  PolarRadiusAxis.displayName = 'PolarRadiusAxis';
  PolarRadiusAxis.axisType = 'radiusAxis';
  PolarRadiusAxis.propTypes = _objectSpread$8({}, PRESENTATION_ATTRIBUTES, {}, EVENT_ATTRIBUTES, {
    type: propTypes$5.oneOf(['number', 'category']),
    cx: propTypes$5.number,
    cy: propTypes$5.number,
    hide: propTypes$5.bool,
    radiusAxisId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    angle: propTypes$5.number,
    tickCount: propTypes$5.number,
    ticks: propTypes$5.arrayOf(propTypes$5.shape({
      value: propTypes$5.any,
      coordinate: propTypes$5.number
    })),
    orientation: propTypes$5.oneOf(['left', 'right', 'middle']),
    axisLine: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.object]),
    tick: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.object, propTypes$5.element, propTypes$5.func]),
    stroke: propTypes$5.string,
    tickFormatter: propTypes$5.func,
    domain: propTypes$5.arrayOf(propTypes$5.oneOfType([propTypes$5.number, propTypes$5.oneOf(['auto', 'dataMin', 'dataMax'])])),
    scale: propTypes$5.oneOfType([propTypes$5.oneOf(['auto', 'linear', 'pow', 'sqrt', 'log', 'identity', 'time', 'band', 'point', 'ordinal', 'quantile', 'quantize', 'utc', 'sequential', 'threshold']), propTypes$5.func]),
    allowDataOverflow: propTypes$5.bool,
    allowDuplicatedCategory: propTypes$5.bool
  });
  PolarRadiusAxis.defaultProps = {
    type: 'number',
    radiusAxisId: 0,
    cx: 0,
    cy: 0,
    angle: 0,
    orientation: 'right',
    stroke: '#ccc',
    axisLine: true,
    tick: true,
    tickCount: 5,
    domain: [0, 'auto'],
    allowDataOverflow: false,
    scale: 'auto',
    allowDuplicatedCategory: true
  };

  function _typeof$7(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$7 = function _typeof(obj) { return typeof obj; }; } else { _typeof$7 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$7(obj); }

  function _extends$9() { _extends$9 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$9.apply(this, arguments); }

  function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(source, true).forEach(function (key) { _defineProperty$9(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$7(self, call) { if (call && (_typeof$7(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$8(self); }

  function _assertThisInitialized$8(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$7(o) { _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$7(o); }

  function _inherits$7(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$7(subClass, superClass); }

  function _setPrototypeOf$7(o, p) { _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$7(o, p); }
  var RADIAN = Math.PI / 180;
  var eps = 1e-5;

  var PolarAngleAxis =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$7(PolarAngleAxis, _PureComponent);

    function PolarAngleAxis() {
      _classCallCheck$8(this, PolarAngleAxis);

      return _possibleConstructorReturn$7(this, _getPrototypeOf$7(PolarAngleAxis).apply(this, arguments));
    }

    _createClass$8(PolarAngleAxis, [{
      key: "getTickLineCoord",

      /**
       * Calculate the coordinate of line endpoint
       * @param  {Object} data The Data if ticks
       * @return {Object} (x0, y0): The start point of text,
       *                  (x1, y1): The end point close to text,
       *                  (x2, y2): The end point close to axis
       */
      value: function getTickLineCoord(data) {
        var _this$props = this.props,
            cx = _this$props.cx,
            cy = _this$props.cy,
            radius = _this$props.radius,
            orientation = _this$props.orientation,
            tickLine = _this$props.tickLine;
        var tickLineSize = tickLine && tickLine.size || 8;
        var p1 = polarToCartesian(cx, cy, radius, data.coordinate);
        var p2 = polarToCartesian(cx, cy, radius + (orientation === 'inner' ? -1 : 1) * tickLineSize, data.coordinate);
        return {
          x1: p1.x,
          y1: p1.y,
          x2: p2.x,
          y2: p2.y
        };
      }
      /**
       * Get the text-anchor of each tick
       * @param  {Object} data Data of ticks
       * @return {String} text-anchor
       */

    }, {
      key: "getTickTextAnchor",
      value: function getTickTextAnchor(data) {
        var orientation = this.props.orientation;
        var cos = Math.cos(-data.coordinate * RADIAN);
        var textAnchor;

        if (cos > eps) {
          textAnchor = orientation === 'outer' ? 'start' : 'end';
        } else if (cos < -eps) {
          textAnchor = orientation === 'outer' ? 'end' : 'start';
        } else {
          textAnchor = 'middle';
        }

        return textAnchor;
      }
    }, {
      key: "renderAxisLine",
      value: function renderAxisLine() {
        var _this$props2 = this.props,
            cx = _this$props2.cx,
            cy = _this$props2.cy,
            radius = _this$props2.radius,
            axisLine = _this$props2.axisLine,
            axisLineType = _this$props2.axisLineType;

        var props = _objectSpread$7({}, getPresentationAttributes(this.props), {
          fill: 'none'
        }, getPresentationAttributes(axisLine));

        if (axisLineType === 'circle') {
          return React__default['default'].createElement(Dot, _extends$9({
            className: "recharts-polar-angle-axis-line"
          }, props, {
            cx: cx,
            cy: cy,
            r: radius
          }));
        }

        var ticks = this.props.ticks;
        var points = ticks.map(function (entry) {
          return polarToCartesian(cx, cy, radius, entry.coordinate);
        });
        return React__default['default'].createElement(Polygon, _extends$9({
          className: "recharts-polar-angle-axis-line"
        }, props, {
          points: points
        }));
      }
    }, {
      key: "renderTicks",
      value: function renderTicks() {
        var _this = this;

        var _this$props3 = this.props,
            ticks = _this$props3.ticks,
            tick = _this$props3.tick,
            tickLine = _this$props3.tickLine,
            tickFormatter = _this$props3.tickFormatter,
            stroke = _this$props3.stroke;
        var axisProps = getPresentationAttributes(this.props);
        var customTickProps = getPresentationAttributes(tick);

        var tickLineProps = _objectSpread$7({}, axisProps, {
          fill: 'none'
        }, getPresentationAttributes(tickLine));

        var items = ticks.map(function (entry, i) {
          var lineCoord = _this.getTickLineCoord(entry);

          var textAnchor = _this.getTickTextAnchor(entry);

          var tickProps = _objectSpread$7({
            textAnchor: textAnchor
          }, axisProps, {
            stroke: 'none',
            fill: stroke
          }, customTickProps, {
            index: i,
            payload: entry,
            x: lineCoord.x2,
            y: lineCoord.y2
          });

          return React__default['default'].createElement(Layer, _extends$9({
            className: "recharts-polar-angle-axis-tick",
            key: "tick-".concat(i) // eslint-disable-line react/no-array-index-key

          }, filterEventsOfChild(_this.props, entry, i)), tickLine && React__default['default'].createElement("line", _extends$9({
            className: "recharts-polar-angle-axis-tick-line"
          }, tickLineProps, lineCoord)), tick && _this.constructor.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value) : entry.value));
        });
        return React__default['default'].createElement(Layer, {
          className: "recharts-polar-angle-axis-ticks"
        }, items);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props4 = this.props,
            ticks = _this$props4.ticks,
            radius = _this$props4.radius,
            axisLine = _this$props4.axisLine;

        if (radius <= 0 || !ticks || !ticks.length) {
          return null;
        }

        return React__default['default'].createElement(Layer, {
          className: "recharts-polar-angle-axis"
        }, axisLine && this.renderAxisLine(), this.renderTicks());
      }
    }], [{
      key: "renderTickItem",
      value: function renderTickItem(option, props, value) {
        var tickItem;

        if (React__default['default'].isValidElement(option)) {
          tickItem = React__default['default'].cloneElement(option, props);
        } else if (isFunction_1(option)) {
          tickItem = option(props);
        } else {
          tickItem = React__default['default'].createElement(Text, _extends$9({}, props, {
            className: "recharts-polar-angle-axis-tick-value"
          }), value);
        }

        return tickItem;
      }
    }]);

    return PolarAngleAxis;
  }(React.PureComponent);

  PolarAngleAxis.displayName = 'PolarAngleAxis';
  PolarAngleAxis.axisType = 'angleAxis';
  PolarAngleAxis.propTypes = _objectSpread$7({}, PRESENTATION_ATTRIBUTES, {}, EVENT_ATTRIBUTES, {
    type: propTypes$5.oneOf(['number', 'category']),
    angleAxisId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    dataKey: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string, propTypes$5.func]),
    cx: propTypes$5.number,
    cy: propTypes$5.number,
    radius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    hide: propTypes$5.bool,
    scale: propTypes$5.oneOfType([propTypes$5.oneOf(SCALE_TYPES), propTypes$5.func]),
    axisLine: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.object]),
    axisLineType: propTypes$5.oneOf(['polygon', 'circle']),
    tickLine: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.object]),
    tick: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.func, propTypes$5.object, propTypes$5.element]),
    ticks: propTypes$5.arrayOf(propTypes$5.shape({
      value: propTypes$5.any,
      coordinate: propTypes$5.number
    })),
    stroke: propTypes$5.string,
    orientation: propTypes$5.oneOf(['inner', 'outer']),
    tickFormatter: propTypes$5.func,
    allowDuplicatedCategory: propTypes$5.bool
  });
  PolarAngleAxis.defaultProps = {
    type: 'category',
    angleAxisId: 0,
    scale: 'auto',
    cx: 0,
    cy: 0,
    domain: [0, 'auto'],
    orientation: 'outer',
    axisLine: true,
    tickLine: true,
    tick: true,
    hide: false,
    allowDuplicatedCategory: true
  };

  /** Built-in value references. */
  var getPrototype = _overArg(Object.getPrototypeOf, Object);

  var _getPrototype = getPrototype;

  /** `Object#toString` result references. */
  var objectTag = '[object Object]';

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = _getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;

  function _typeof$6(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$6(obj); }

  function _extends$8() { _extends$8 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$8.apply(this, arguments); }

  function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(source, true).forEach(function (key) { _defineProperty$8(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$6(self, call) { if (call && (_typeof$6(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$7(self); }

  function _assertThisInitialized$7(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$6(o) { _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$6(o); }

  function _inherits$6(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$6(subClass, superClass); }

  function _setPrototypeOf$6(o, p) { _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$6(o, p); }

  var Pie =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$6(Pie, _PureComponent);

    function Pie() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck$7(this, Pie);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn$6(this, (_getPrototypeOf2 = _getPrototypeOf$6(Pie)).call.apply(_getPrototypeOf2, [this].concat(args)));
      _this.state = {
        isAnimationFinished: false
      };
      _this.id = uniqueId('recharts-pie-');

      _this.cachePrevData = function (sectors) {
        _this.setState({
          prevSectors: sectors
        });
      };

      _this.handleAnimationEnd = function () {
        var onAnimationEnd = _this.props.onAnimationEnd;

        _this.setState({
          isAnimationFinished: true
        });

        if (isFunction_1(onAnimationEnd)) {
          onAnimationEnd();
        }
      };

      _this.handleAnimationStart = function () {
        var onAnimationStart = _this.props.onAnimationStart;

        _this.setState({
          isAnimationFinished: false
        });

        if (isFunction_1(onAnimationStart)) {
          onAnimationStart();
        }
      };

      return _this;
    }

    _createClass$7(Pie, [{
      key: "componentWillReceiveProps",
      // eslint-disable-next-line camelcase
      value: function componentWillReceiveProps(nextProps) {
        var _this$props = this.props,
            animationId = _this$props.animationId,
            sectors = _this$props.sectors;

        if (nextProps.isAnimationActive !== this.props.isAnimationActive) {
          this.cachePrevData([]);
        } else if (nextProps.animationId !== animationId) {
          this.cachePrevData(sectors);
        }
      }
    }, {
      key: "isActiveIndex",
      value: function isActiveIndex(i) {
        var activeIndex = this.props.activeIndex;

        if (Array.isArray(activeIndex)) {
          return activeIndex.indexOf(i) !== -1;
        }

        return i === activeIndex;
      }
    }, {
      key: "renderLabels",
      value: function renderLabels(sectors) {
        var _this2 = this;

        var isAnimationActive = this.props.isAnimationActive;

        if (isAnimationActive && !this.state.isAnimationFinished) {
          return null;
        }

        var _this$props2 = this.props,
            label = _this$props2.label,
            labelLine = _this$props2.labelLine,
            dataKey = _this$props2.dataKey,
            valueKey = _this$props2.valueKey;
        var pieProps = getPresentationAttributes(this.props);
        var customLabelProps = getPresentationAttributes(label);
        var customLabelLineProps = getPresentationAttributes(labelLine);
        var offsetRadius = label && label.offsetRadius || 20;
        var labels = sectors.map(function (entry, i) {
          var midAngle = (entry.startAngle + entry.endAngle) / 2;
          var endPoint = polarToCartesian(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);

          var labelProps = _objectSpread$6({}, pieProps, {}, entry, {
            stroke: 'none'
          }, customLabelProps, {
            index: i,
            textAnchor: _this2.constructor.getTextAnchor(endPoint.x, entry.cx)
          }, endPoint);

          var lineProps = _objectSpread$6({}, pieProps, {}, entry, {
            fill: 'none',
            stroke: entry.fill
          }, customLabelLineProps, {
            index: i,
            points: [polarToCartesian(entry.cx, entry.cy, entry.outerRadius, midAngle), endPoint],
            key: 'line'
          });

          var realDataKey = dataKey; // TODO: compatible to lower versions

          if (isNil_1(dataKey) && isNil_1(valueKey)) {
            realDataKey = 'value';
          } else if (isNil_1(dataKey)) {
            realDataKey = valueKey;
          }

          return (// eslint-disable-next-line react/no-array-index-key
            React__default['default'].createElement(Layer, {
              key: "label-".concat(i)
            }, labelLine && _this2.constructor.renderLabelLineItem(labelLine, lineProps), _this2.constructor.renderLabelItem(label, labelProps, getValueByDataKey(entry, realDataKey)))
          );
        });
        return React__default['default'].createElement(Layer, {
          className: "recharts-pie-labels"
        }, labels);
      }
    }, {
      key: "renderSectorsStatically",
      value: function renderSectorsStatically(sectors) {
        var _this3 = this;

        var _this$props3 = this.props,
            activeShape = _this$props3.activeShape,
            blendStroke = _this$props3.blendStroke;
        return sectors.map(function (entry, i) {
          var sectorOptions = _this3.isActiveIndex(i) ? activeShape : null;

          var sectorProps = _objectSpread$6({}, entry, {
            stroke: blendStroke ? entry.fill : entry.stroke
          });

          return React__default['default'].createElement(Layer, _extends$8({
            className: "recharts-pie-sector"
          }, filterEventsOfChild(_this3.props, entry, i), {
            key: "sector-".concat(i) // eslint-disable-line react/no-array-index-key

          }), _this3.constructor.renderSectorItem(sectorOptions, sectorProps));
        });
      }
    }, {
      key: "renderSectorsWithAnimation",
      value: function renderSectorsWithAnimation() {
        var _this4 = this;

        var _this$props4 = this.props,
            sectors = _this$props4.sectors,
            isAnimationActive = _this$props4.isAnimationActive,
            animationBegin = _this$props4.animationBegin,
            animationDuration = _this$props4.animationDuration,
            animationEasing = _this$props4.animationEasing,
            animationId = _this$props4.animationId;
        var prevSectors = this.state.prevSectors;
        return React__default['default'].createElement(Animate, {
          begin: animationBegin,
          duration: animationDuration,
          isActive: isAnimationActive,
          easing: animationEasing,
          from: {
            t: 0
          },
          to: {
            t: 1
          },
          key: "pie-".concat(animationId),
          onAnimationStart: this.handleAnimationStart,
          onAnimationEnd: this.handleAnimationEnd
        }, function (_ref) {
          var t = _ref.t;
          var stepData = [];
          var first = sectors && sectors[0];
          var curAngle = first.startAngle;
          sectors.forEach(function (entry, index) {
            var prev = prevSectors && prevSectors[index];
            var paddingAngle = index > 0 ? get_1(entry, 'paddingAngle', 0) : 0;

            if (prev) {
              var angleIp = interpolateNumber$1(prev.endAngle - prev.startAngle, entry.endAngle - entry.startAngle);

              var latest = _objectSpread$6({}, entry, {
                startAngle: curAngle + paddingAngle,
                endAngle: curAngle + angleIp(t) + paddingAngle
              });

              stepData.push(latest);
              curAngle = latest.endAngle;
            } else {
              var endAngle = entry.endAngle,
                  startAngle = entry.startAngle;
              var interpolatorAngle = interpolateNumber$1(0, endAngle - startAngle);
              var deltaAngle = interpolatorAngle(t);

              var _latest = _objectSpread$6({}, entry, {
                startAngle: curAngle + paddingAngle,
                endAngle: curAngle + deltaAngle + paddingAngle
              });

              stepData.push(_latest);
              curAngle = _latest.endAngle;
            }
          });
          return React__default['default'].createElement(Layer, null, _this4.renderSectorsStatically(stepData));
        });
      }
    }, {
      key: "renderSectors",
      value: function renderSectors() {
        var _this$props5 = this.props,
            sectors = _this$props5.sectors,
            isAnimationActive = _this$props5.isAnimationActive;
        var prevSectors = this.state.prevSectors;

        if (isAnimationActive && sectors && sectors.length && (!prevSectors || !isEqual_1(prevSectors, sectors))) {
          return this.renderSectorsWithAnimation();
        }

        return this.renderSectorsStatically(sectors);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props6 = this.props,
            hide = _this$props6.hide,
            sectors = _this$props6.sectors,
            className = _this$props6.className,
            label = _this$props6.label,
            cx = _this$props6.cx,
            cy = _this$props6.cy,
            innerRadius = _this$props6.innerRadius,
            outerRadius = _this$props6.outerRadius,
            isAnimationActive = _this$props6.isAnimationActive,
            prevSectors = _this$props6.prevSectors;

        if (hide || !sectors || !sectors.length || !isNumber(cx) || !isNumber(cy) || !isNumber(innerRadius) || !isNumber(outerRadius)) {
          return null;
        }

        var layerClass = classnames('recharts-pie', className);
        return React__default['default'].createElement(Layer, {
          className: layerClass
        }, this.renderSectors(), label && this.renderLabels(sectors), Label$1.renderCallByParent(this.props, null, false), (!isAnimationActive || prevSectors && isEqual_1(prevSectors, sectors)) && LabelList.renderCallByParent(this.props, sectors, false));
      }
    }], [{
      key: "getTextAnchor",
      value: function getTextAnchor(x, cx) {
        if (x > cx) {
          return 'start';
        }

        if (x < cx) {
          return 'end';
        }

        return 'middle';
      }
    }, {
      key: "renderLabelLineItem",
      value: function renderLabelLineItem(option, props) {
        if (React__default['default'].isValidElement(option)) {
          return React__default['default'].cloneElement(option, props);
        }

        if (isFunction_1(option)) {
          return option(props);
        }

        return React__default['default'].createElement(Curve, _extends$8({}, props, {
          type: "linear",
          className: "recharts-pie-label-line"
        }));
      }
    }, {
      key: "renderLabelItem",
      value: function renderLabelItem(option, props, value) {
        if (React__default['default'].isValidElement(option)) {
          return React__default['default'].cloneElement(option, props);
        }

        var label = value;

        if (isFunction_1(option)) {
          label = option(props);

          if (React__default['default'].isValidElement(label)) {
            return label;
          }
        }

        return React__default['default'].createElement(Text, _extends$8({}, props, {
          alignmentBaseline: "middle",
          className: "recharts-pie-label-text"
        }), label);
      }
    }, {
      key: "renderSectorItem",
      value: function renderSectorItem(option, props) {
        if (React__default['default'].isValidElement(option)) {
          return React__default['default'].cloneElement(option, props);
        }

        if (isFunction_1(option)) {
          return option(props);
        }

        if (isPlainObject_1(option)) {
          return React__default['default'].createElement(Sector, _extends$8({}, props, option));
        }

        return React__default['default'].createElement(Sector, props);
      }
    }]);

    return Pie;
  }(React.PureComponent);

  Pie.displayName = 'Pie';
  Pie.propTypes = _objectSpread$6({}, PRESENTATION_ATTRIBUTES, {}, EVENT_ATTRIBUTES, {
    className: propTypes$5.string,
    animationId: propTypes$5.number,
    cx: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    cy: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    startAngle: propTypes$5.number,
    endAngle: propTypes$5.number,
    paddingAngle: propTypes$5.number,
    innerRadius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    outerRadius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    cornerRadius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    dataKey: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number, propTypes$5.func]).isRequired,
    nameKey: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number, propTypes$5.func]),
    valueKey: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number, propTypes$5.func]),
    data: propTypes$5.arrayOf(propTypes$5.object),
    blendStroke: propTypes$5.bool,
    minAngle: propTypes$5.number,
    legendType: propTypes$5.oneOf(LEGEND_TYPES),
    tooltipType: propTypes$5.oneOf(TOOLTIP_TYPES),
    maxRadius: propTypes$5.number,
    sectors: propTypes$5.arrayOf(propTypes$5.object),
    hide: propTypes$5.bool,
    labelLine: propTypes$5.oneOfType([propTypes$5.object, propTypes$5.func, propTypes$5.element, propTypes$5.bool]),
    label: propTypes$5.oneOfType([propTypes$5.shape({
      offsetRadius: propTypes$5.number
    }), propTypes$5.func, propTypes$5.element, propTypes$5.bool]),
    activeShape: propTypes$5.oneOfType([propTypes$5.object, propTypes$5.func, propTypes$5.element]),
    activeIndex: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.arrayOf(propTypes$5.number)]),
    onAnimationStart: propTypes$5.func,
    onAnimationEnd: propTypes$5.func,
    isAnimationActive: propTypes$5.bool,
    animationBegin: propTypes$5.number,
    animationDuration: propTypes$5.number,
    animationEasing: propTypes$5.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'spring', 'linear']),
    id: propTypes$5.string
  });
  Pie.defaultProps = {
    stroke: '#fff',
    fill: '#808080',
    legendType: 'rect',
    // The abscissa of pole
    cx: '50%',
    // The ordinate of pole
    cy: '50%',
    // The start angle of first sector
    startAngle: 0,
    // The direction of drawing sectors
    endAngle: 360,
    // The inner radius of sectors
    innerRadius: 0,
    // The outer radius of sectors
    outerRadius: '80%',
    paddingAngle: 0,
    labelLine: true,
    hide: false,
    minAngle: 0,
    isAnimationActive: !isSsr(),
    animationBegin: 400,
    animationDuration: 1500,
    animationEasing: 'ease',
    nameKey: 'name',
    // Match each sector's stroke color to it's fill color
    blendStroke: false
  };

  Pie.parseDeltaAngle = function (_ref2) {
    var startAngle = _ref2.startAngle,
        endAngle = _ref2.endAngle;
    var sign = mathSign(endAngle - startAngle);
    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
    return sign * deltaAngle;
  };

  Pie.getRealPieData = function (item) {
    var _item$props = item.props,
        data = _item$props.data,
        children = _item$props.children;
    var presentationProps = getPresentationAttributes(item.props);
    var cells = findAllByType(children, Cell$1);

    if (data && data.length) {
      return data.map(function (entry, index) {
        return _objectSpread$6({
          payload: entry
        }, presentationProps, {}, entry, {}, cells && cells[index] && cells[index].props);
      });
    }

    if (cells && cells.length) {
      return cells.map(function (cell) {
        return _objectSpread$6({}, presentationProps, {}, cell.props);
      });
    }

    return [];
  };

  Pie.parseCoordinateOfPie = function (item, offset) {
    var top = offset.top,
        left = offset.left,
        width = offset.width,
        height = offset.height;
    var maxPieRadius = getMaxRadius(width, height);
    var cx = left + getPercentValue(item.props.cx, width, width / 2);
    var cy = top + getPercentValue(item.props.cy, height, height / 2);
    var innerRadius = getPercentValue(item.props.innerRadius, maxPieRadius, 0);
    var outerRadius = getPercentValue(item.props.outerRadius, maxPieRadius, maxPieRadius * 0.8);
    var maxRadius = item.props.maxRadius || Math.sqrt(width * width + height * height) / 2;
    return {
      cx: cx,
      cy: cy,
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      maxRadius: maxRadius
    };
  };

  Pie.getComposedData = function (_ref3) {
    var item = _ref3.item,
        offset = _ref3.offset,
        onItemMouseLeave = _ref3.onItemMouseLeave,
        onItemMouseEnter = _ref3.onItemMouseEnter;
    var pieData = Pie.getRealPieData(item);

    if (!pieData || !pieData.length) {
      return [];
    }

    var _item$props2 = item.props,
        cornerRadius = _item$props2.cornerRadius,
        startAngle = _item$props2.startAngle,
        endAngle = _item$props2.endAngle,
        paddingAngle = _item$props2.paddingAngle,
        dataKey = _item$props2.dataKey,
        nameKey = _item$props2.nameKey,
        valueKey = _item$props2.valueKey,
        tooltipType = _item$props2.tooltipType;
    var minAngle = Math.abs(item.props.minAngle);
    var coordinate = Pie.parseCoordinateOfPie(item, offset);
    var len = pieData.length;
    var deltaAngle = Pie.parseDeltaAngle({
      startAngle: startAngle,
      endAngle: endAngle
    });
    var absDeltaAngle = Math.abs(deltaAngle);
    var totalPadingAngle = (absDeltaAngle >= 360 ? len : len - 1) * paddingAngle;
    var realTotalAngle = absDeltaAngle - len * minAngle - totalPadingAngle;
    var realDataKey = dataKey;

    if (isNil_1(dataKey) && isNil_1(valueKey)) {
      realDataKey = 'value';
    } else if (isNil_1(dataKey)) {
      realDataKey = valueKey;
    }

    var sum = pieData.reduce(function (result, entry) {
      var val = getValueByDataKey(entry, realDataKey, 0);
      return result + (isNumber(val) ? val : 0);
    }, 0);
    var sectors;

    if (sum > 0) {
      var prev;
      sectors = pieData.map(function (entry, i) {
        var val = getValueByDataKey(entry, realDataKey, 0);
        var name = getValueByDataKey(entry, nameKey, i);
        var percent = (isNumber(val) ? val : 0) / sum;
        var tempStartAngle;

        if (i) {
          tempStartAngle = prev.endAngle + mathSign(deltaAngle) * paddingAngle;
        } else {
          tempStartAngle = startAngle;
        }

        var tempEndAngle = tempStartAngle + mathSign(deltaAngle) * (minAngle + percent * realTotalAngle);
        var midAngle = (tempStartAngle + tempEndAngle) / 2;
        var middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2;
        var tooltipPayload = [{
          name: name,
          value: val,
          payload: entry,
          dataKey: realDataKey,
          type: tooltipType
        }];
        var tooltipPosition = polarToCartesian(coordinate.cx, coordinate.cy, middleRadius, midAngle);
        prev = _objectSpread$6({
          percent: percent,
          cornerRadius: cornerRadius,
          name: name,
          tooltipPayload: tooltipPayload,
          midAngle: midAngle,
          middleRadius: middleRadius,
          tooltipPosition: tooltipPosition
        }, entry, {}, coordinate, {
          value: getValueByDataKey(entry, realDataKey),
          startAngle: tempStartAngle,
          endAngle: tempEndAngle,
          payload: entry,
          paddingAngle: mathSign(deltaAngle) * paddingAngle
        });
        return prev;
      });
    }

    return _objectSpread$6({}, coordinate, {
      sectors: sectors,
      data: pieData,
      onMouseLeave: onItemMouseLeave,
      onMouseEnter: onItemMouseEnter
    });
  };

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeCeil = Math.ceil,
      nativeMax$1 = Math.max;

  /**
   * The base implementation of `_.range` and `_.rangeRight` which doesn't
   * coerce arguments.
   *
   * @private
   * @param {number} start The start of the range.
   * @param {number} end The end of the range.
   * @param {number} step The value to increment or decrement by.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Array} Returns the range of numbers.
   */
  function baseRange(start, end, step, fromRight) {
    var index = -1,
        length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),
        result = Array(length);

    while (length--) {
      result[fromRight ? length : ++index] = start;
      start += step;
    }
    return result;
  }

  var _baseRange = baseRange;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber_1(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;

  /**
   * Creates a `_.range` or `_.rangeRight` function.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new range function.
   */
  function createRange(fromRight) {
    return function(start, end, step) {
      if (step && typeof step != 'number' && _isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      // Ensure the sign of `-0` is preserved.
      start = toFinite_1(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite_1(end);
      }
      step = step === undefined ? (start < end ? 1 : -1) : toFinite_1(step);
      return _baseRange(start, end, step, fromRight);
    };
  }

  var _createRange = createRange;

  /**
   * Creates an array of numbers (positive and/or negative) progressing from
   * `start` up to, but not including, `end`. A step of `-1` is used if a negative
   * `start` is specified without an `end` or `step`. If `end` is not specified,
   * it's set to `start` with `start` then set to `0`.
   *
   * **Note:** JavaScript follows the IEEE-754 standard for resolving
   * floating-point values which can produce unexpected results.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {number} [start=0] The start of the range.
   * @param {number} end The end of the range.
   * @param {number} [step=1] The value to increment or decrement by.
   * @returns {Array} Returns the range of numbers.
   * @see _.inRange, _.rangeRight
   * @example
   *
   * _.range(4);
   * // => [0, 1, 2, 3]
   *
   * _.range(-4);
   * // => [0, -1, -2, -3]
   *
   * _.range(1, 5);
   * // => [1, 2, 3, 4]
   *
   * _.range(0, 20, 5);
   * // => [0, 5, 10, 15]
   *
   * _.range(0, -4, -1);
   * // => [0, -1, -2, -3]
   *
   * _.range(1, 4, 0);
   * // => [1, 1, 1]
   *
   * _.range(0);
   * // => []
   */
  var range = _createRange();

  var range_1 = range;

  function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(source, true).forEach(function (key) { _defineProperty$7(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  var PREFIX_LIST = ['Webkit', 'Moz', 'O', 'ms'];
  var generatePrefixStyle = function generatePrefixStyle(name, value) {
    if (!name) {
      return null;
    }

    var camelName = name.replace(/(\w)/, function (v) {
      return v.toUpperCase();
    });
    var result = PREFIX_LIST.reduce(function (res, entry) {
      return _objectSpread$5({}, res, _defineProperty$7({}, entry + camelName, value));
    }, {});
    result[name] = value;
    return result;
  };

  function _typeof$5(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$5(obj); }

  function _extends$7() { _extends$7 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }

  function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$5(self, call) { if (call && (_typeof$5(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$6(self); }

  function _getPrototypeOf$5(o) { _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$5(o); }

  function _assertThisInitialized$6(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits$5(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$5(subClass, superClass); }

  function _setPrototypeOf$5(o, p) { _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$5(o, p); }

  var Brush =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$5(Brush, _PureComponent);

    function Brush(props) {
      var _this;

      _classCallCheck$6(this, Brush);

      _this = _possibleConstructorReturn$5(this, _getPrototypeOf$5(Brush).call(this, props));

      _this.handleDrag = function (e) {
        if (_this.leaveTimer) {
          clearTimeout(_this.leaveTimer);
          _this.leaveTimer = null;
        }

        if (_this.state.isTravellerMoving) {
          _this.handleTravellerMove(e);
        } else if (_this.state.isSlideMoving) {
          _this.handleSlideDrag(e);
        }
      };

      _this.handleTouchMove = function (e) {
        if (e.changedTouches != null && e.changedTouches.length > 0) {
          _this.handleDrag(e.changedTouches[0]);
        }
      };

      _this.handleDragEnd = function () {
        _this.setState({
          isTravellerMoving: false,
          isSlideMoving: false
        });
      };

      _this.handleLeaveWrapper = function () {
        if (_this.state.isTravellerMoving || _this.state.isSlideMoving) {
          _this.leaveTimer = setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);
        }
      };

      _this.handleEnterSlideOrTraveller = function () {
        _this.setState({
          isTextActive: true
        });
      };

      _this.handleLeaveSlideOrTraveller = function () {
        _this.setState({
          isTextActive: false
        });
      };

      _this.handleSlideDragStart = function (e) {
        var event = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e;

        _this.setState({
          isTravellerMoving: false,
          isSlideMoving: true,
          slideMoveStartX: event.pageX
        });
      };

      _this.travellerDragStartHandlers = {
        startX: _this.handleTravellerDragStart.bind(_assertThisInitialized$6(_this), 'startX'),
        endX: _this.handleTravellerDragStart.bind(_assertThisInitialized$6(_this), 'endX')
      };
      _this.state = props.data && props.data.length ? _this.updateScale(props) : {};
      return _this;
    } // eslint-disable-next-line camelcase


    _createClass$6(Brush, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        var _this2 = this;

        var _this$props = this.props,
            data = _this$props.data,
            width = _this$props.width,
            x = _this$props.x,
            travellerWidth = _this$props.travellerWidth,
            updateId = _this$props.updateId;

        if ((nextProps.data !== data || nextProps.updateId !== updateId) && nextProps.data && nextProps.data.length) {
          this.setState(this.updateScale(nextProps));
        } else if (nextProps.width !== width || nextProps.x !== x || nextProps.travellerWidth !== travellerWidth) {
          this.scale.range([nextProps.x, nextProps.x + nextProps.width - nextProps.travellerWidth]);
          this.scaleValues = this.scale.domain().map(function (entry) {
            return _this2.scale(entry);
          });
          this.setState({
            startX: this.scale(nextProps.startIndex),
            endX: this.scale(nextProps.endIndex)
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.scale = null;
        this.scaleValues = null;

        if (this.leaveTimer) {
          clearTimeout(this.leaveTimer);
          this.leaveTimer = null;
        }
      }
    }, {
      key: "getIndex",
      value: function getIndex(_ref) {
        var startX = _ref.startX,
            endX = _ref.endX;
        var _this$props2 = this.props,
            gap = _this$props2.gap,
            data = _this$props2.data;
        var lastIndex = data.length - 1;
        var min = Math.min(startX, endX);
        var max = Math.max(startX, endX);
        var minIndex = this.constructor.getIndexInRange(this.scaleValues, min);
        var maxIndex = this.constructor.getIndexInRange(this.scaleValues, max);
        return {
          startIndex: minIndex - minIndex % gap,
          endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
        };
      }
    }, {
      key: "getTextOfTick",
      value: function getTextOfTick(index) {
        var _this$props3 = this.props,
            data = _this$props3.data,
            tickFormatter = _this$props3.tickFormatter,
            dataKey = _this$props3.dataKey;
        var text = getValueByDataKey(data[index], dataKey, index);
        return isFunction_1(tickFormatter) ? tickFormatter(text) : text;
      }
    }, {
      key: "handleSlideDrag",
      value: function handleSlideDrag(e) {
        var _this$state = this.state,
            slideMoveStartX = _this$state.slideMoveStartX,
            startX = _this$state.startX,
            endX = _this$state.endX;
        var _this$props4 = this.props,
            x = _this$props4.x,
            width = _this$props4.width,
            travellerWidth = _this$props4.travellerWidth,
            startIndex = _this$props4.startIndex,
            endIndex = _this$props4.endIndex,
            onChange = _this$props4.onChange;
        var delta = e.pageX - slideMoveStartX;

        if (delta > 0) {
          delta = Math.min(delta, x + width - travellerWidth - endX, x + width - travellerWidth - startX);
        } else if (delta < 0) {
          delta = Math.max(delta, x - startX, x - endX);
        }

        var newIndex = this.getIndex({
          startX: startX + delta,
          endX: endX + delta
        });

        if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {
          onChange(newIndex);
        }

        this.setState({
          startX: startX + delta,
          endX: endX + delta,
          slideMoveStartX: e.pageX
        });
      }
    }, {
      key: "handleTravellerDragStart",
      value: function handleTravellerDragStart(id, e) {
        var event = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e;
        this.setState({
          isSlideMoving: false,
          isTravellerMoving: true,
          movingTravellerId: id,
          brushMoveStartX: event.pageX
        });
      }
    }, {
      key: "handleTravellerMove",
      value: function handleTravellerMove(e) {
        var _this$setState;

        var _this$state2 = this.state,
            brushMoveStartX = _this$state2.brushMoveStartX,
            movingTravellerId = _this$state2.movingTravellerId,
            endX = _this$state2.endX,
            startX = _this$state2.startX;
        var prevValue = this.state[movingTravellerId];
        var _this$props5 = this.props,
            x = _this$props5.x,
            width = _this$props5.width,
            travellerWidth = _this$props5.travellerWidth,
            onChange = _this$props5.onChange,
            gap = _this$props5.gap,
            data = _this$props5.data;
        var params = {
          startX: this.state.startX,
          endX: this.state.endX
        };
        var delta = e.pageX - brushMoveStartX;

        if (delta > 0) {
          delta = Math.min(delta, x + width - travellerWidth - prevValue);
        } else if (delta < 0) {
          delta = Math.max(delta, x - prevValue);
        }

        params[movingTravellerId] = prevValue + delta;
        var newIndex = this.getIndex(params);
        var startIndex = newIndex.startIndex,
            endIndex = newIndex.endIndex;

        var isFullGap = function isFullGap() {
          var lastIndex = data.length - 1;

          if (movingTravellerId === 'startX' && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === 'endX' && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {
            return true;
          }

          return false;
        };

        this.setState((_this$setState = {}, _defineProperty$6(_this$setState, movingTravellerId, prevValue + delta), _defineProperty$6(_this$setState, "brushMoveStartX", e.pageX), _this$setState), function () {
          if (onChange) {
            if (isFullGap()) {
              onChange(newIndex);
            }
          }
        });
      }
    }, {
      key: "updateScale",
      value: function updateScale(props) {
        var _this3 = this;

        var data = props.data,
            startIndex = props.startIndex,
            endIndex = props.endIndex,
            x = props.x,
            width = props.width,
            travellerWidth = props.travellerWidth;
        var len = data.length;
        this.scale = point().domain(range_1(0, len)).range([x, x + width - travellerWidth]);
        this.scaleValues = this.scale.domain().map(function (entry) {
          return _this3.scale(entry);
        });
        return {
          isTextActive: false,
          isSlideMoving: false,
          isTravellerMoving: false,
          startX: this.scale(startIndex),
          endX: this.scale(endIndex)
        };
      }
    }, {
      key: "renderBackground",
      value: function renderBackground() {
        var _this$props6 = this.props,
            x = _this$props6.x,
            y = _this$props6.y,
            width = _this$props6.width,
            height = _this$props6.height,
            fill = _this$props6.fill,
            stroke = _this$props6.stroke;
        return React__default['default'].createElement("rect", {
          stroke: stroke,
          fill: fill,
          x: x,
          y: y,
          width: width,
          height: height
        });
      }
    }, {
      key: "renderPanorama",
      value: function renderPanorama() {
        var _this$props7 = this.props,
            x = _this$props7.x,
            y = _this$props7.y,
            width = _this$props7.width,
            height = _this$props7.height,
            data = _this$props7.data,
            children = _this$props7.children,
            padding = _this$props7.padding;
        var chartElement = React.Children.only(children);

        if (!chartElement) {
          return null;
        }

        return React__default['default'].cloneElement(chartElement, {
          x: x,
          y: y,
          width: width,
          height: height,
          margin: padding,
          compact: true,
          data: data
        });
      }
    }, {
      key: "renderTraveller",
      value: function renderTraveller(travellerX, id) {
        var _this$props8 = this.props,
            y = _this$props8.y,
            travellerWidth = _this$props8.travellerWidth,
            height = _this$props8.height,
            stroke = _this$props8.stroke;
        var lineY = Math.floor(y + height / 2) - 1;
        var x = Math.max(travellerX, this.props.x);
        return React__default['default'].createElement(Layer, {
          className: "recharts-brush-traveller",
          onMouseEnter: this.handleEnterSlideOrTraveller,
          onMouseLeave: this.handleLeaveSlideOrTraveller,
          onMouseDown: this.travellerDragStartHandlers[id],
          onTouchStart: this.travellerDragStartHandlers[id],
          style: {
            cursor: 'col-resize'
          }
        }, React__default['default'].createElement("rect", {
          x: x,
          y: y,
          width: travellerWidth,
          height: height,
          fill: stroke,
          stroke: "none"
        }), React__default['default'].createElement("line", {
          x1: x + 1,
          y1: lineY,
          x2: x + travellerWidth - 1,
          y2: lineY,
          fill: "none",
          stroke: "#fff"
        }), React__default['default'].createElement("line", {
          x1: x + 1,
          y1: lineY + 2,
          x2: x + travellerWidth - 1,
          y2: lineY + 2,
          fill: "none",
          stroke: "#fff"
        }));
      }
    }, {
      key: "renderSlide",
      value: function renderSlide(startX, endX) {
        var _this$props9 = this.props,
            y = _this$props9.y,
            height = _this$props9.height,
            stroke = _this$props9.stroke;
        return React__default['default'].createElement("rect", {
          className: "recharts-brush-slide",
          onMouseEnter: this.handleEnterSlideOrTraveller,
          onMouseLeave: this.handleLeaveSlideOrTraveller,
          onMouseDown: this.handleSlideDragStart,
          onTouchStart: this.handleSlideDragStart,
          style: {
            cursor: 'move'
          },
          stroke: "none",
          fill: stroke,
          fillOpacity: 0.2,
          x: Math.min(startX, endX),
          y: y,
          width: Math.abs(endX - startX),
          height: height
        });
      }
    }, {
      key: "renderText",
      value: function renderText() {
        var _this$props10 = this.props,
            startIndex = _this$props10.startIndex,
            endIndex = _this$props10.endIndex,
            y = _this$props10.y,
            height = _this$props10.height,
            travellerWidth = _this$props10.travellerWidth,
            stroke = _this$props10.stroke;
        var _this$state3 = this.state,
            startX = _this$state3.startX,
            endX = _this$state3.endX;
        var offset = 5;
        var attrs = {
          pointerEvents: 'none',
          fill: stroke
        };
        return React__default['default'].createElement(Layer, {
          className: "recharts-brush-texts"
        }, React__default['default'].createElement(Text, _extends$7({
          textAnchor: "end",
          verticalAnchor: "middle",
          x: Math.min(startX, endX) - offset,
          y: y + height / 2
        }, attrs), this.getTextOfTick(startIndex)), React__default['default'].createElement(Text, _extends$7({
          textAnchor: "start",
          verticalAnchor: "middle",
          x: Math.max(startX, endX) + travellerWidth + offset,
          y: y + height / 2
        }, attrs), this.getTextOfTick(endIndex)));
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props11 = this.props,
            data = _this$props11.data,
            className = _this$props11.className,
            children = _this$props11.children,
            x = _this$props11.x,
            y = _this$props11.y,
            width = _this$props11.width,
            height = _this$props11.height,
            alwaysShowText = _this$props11.alwaysShowText;
        var _this$state4 = this.state,
            startX = _this$state4.startX,
            endX = _this$state4.endX,
            isTextActive = _this$state4.isTextActive,
            isSlideMoving = _this$state4.isSlideMoving,
            isTravellerMoving = _this$state4.isTravellerMoving;

        if (!data || !data.length || !isNumber(x) || !isNumber(y) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) {
          return null;
        }

        var layerClass = classnames('recharts-brush', className);
        var isPanoramic = React__default['default'].Children.count(children) === 1;
        var style = generatePrefixStyle('userSelect', 'none');
        return React__default['default'].createElement(Layer, {
          className: layerClass,
          onMouseMove: this.handleDrag,
          onMouseLeave: this.handleLeaveWrapper,
          onMouseUp: this.handleDragEnd,
          onTouchEnd: this.handleDragEnd,
          onTouchMove: this.handleTouchMove,
          style: style
        }, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTraveller(startX, 'startX'), this.renderTraveller(endX, 'endX'), (isTextActive || isSlideMoving || isTravellerMoving || alwaysShowText) && this.renderText());
      }
    }], [{
      key: "getIndexInRange",
      value: function getIndexInRange(range, x) {
        var len = range.length;
        var start = 0;
        var end = len - 1;

        while (end - start > 1) {
          var middle = Math.floor((start + end) / 2);

          if (range[middle] > x) {
            end = middle;
          } else {
            start = middle;
          }
        }

        return x >= range[end] ? end : start;
      }
    }]);

    return Brush;
  }(React.PureComponent);

  Brush.displayName = 'Brush';
  Brush.propTypes = {
    className: propTypes$5.string,
    fill: propTypes$5.string,
    stroke: propTypes$5.string,
    x: propTypes$5.number,
    y: propTypes$5.number,
    width: propTypes$5.number,
    height: propTypes$5.number.isRequired,
    travellerWidth: propTypes$5.number,
    gap: propTypes$5.number,
    padding: propTypes$5.shape({
      top: propTypes$5.number,
      right: propTypes$5.number,
      bottom: propTypes$5.number,
      left: propTypes$5.number
    }),
    dataKey: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number, propTypes$5.func]),
    data: propTypes$5.array,
    startIndex: propTypes$5.number,
    endIndex: propTypes$5.number,
    tickFormatter: propTypes$5.func,
    children: propTypes$5.node,
    onChange: propTypes$5.func,
    updateId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    leaveTimeOut: propTypes$5.number,
    alwaysShowText: propTypes$5.bool
  };
  Brush.defaultProps = {
    height: 40,
    travellerWidth: 5,
    gap: 1,
    fill: '#fff',
    stroke: '#666',
    padding: {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    },
    leaveTimeOut: 1000,
    alwaysShowText: false
  };

  /**
   * The base implementation of `_.some` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function baseSome(collection, predicate) {
    var result;

    _baseEach(collection, function(value, index, collection) {
      result = predicate(value, index, collection);
      return !result;
    });
    return !!result;
  }

  var _baseSome = baseSome;

  /**
   * Checks if `predicate` returns truthy for **any** element of `collection`.
   * Iteration is stopped once `predicate` returns truthy. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var users = [
   *   { 'user': 'barney', 'active': true },
   *   { 'user': 'fred',   'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.some(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.some(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.some(users, 'active');
   * // => true
   */
  function some(collection, predicate, guard) {
    var func = isArray_1(collection) ? _arraySome : _baseSome;
    if (guard && _isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }
    return func(collection, _baseIteratee(predicate));
  }

  var some_1 = some;

  var ifOverflowMatches = function ifOverflowMatches(props, value) {
    var alwaysShow = props.alwaysShow;
    var ifOverflow = props.ifOverflow;

    if (alwaysShow) {
      ifOverflow = 'extendDomain';
    }

    return ifOverflow === value;
  };

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  var _arrayEvery = arrayEvery;

  /**
   * The base implementation of `_.every` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`
   */
  function baseEvery(collection, predicate) {
    var result = true;
    _baseEach(collection, function(value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }

  var _baseEvery = baseEvery;

  /**
   * Checks if `predicate` returns truthy for **all** elements of `collection`.
   * Iteration is stopped once `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * **Note:** This method returns `true` for
   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
   * elements of empty collections.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': false },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.every(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.every(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.every(users, 'active');
   * // => false
   */
  function every(collection, predicate, guard) {
    var func = isArray_1(collection) ? _arrayEvery : _baseEvery;
    if (guard && _isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }
    return func(collection, _baseIteratee(predicate));
  }

  var every_1 = every;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty$s) {
      _defineProperty$s(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;

  /**
   * Creates an object with the same keys as `object` and values generated
   * by running each own enumerable string keyed property of `object` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Object
   * @param {Object} object The object to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Object} Returns the new mapped object.
   * @see _.mapKeys
   * @example
   *
   * var users = {
   *   'fred':    { 'user': 'fred',    'age': 40 },
   *   'pebbles': { 'user': 'pebbles', 'age': 1 }
   * };
   *
   * _.mapValues(users, function(o) { return o.age; });
   * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
   *
   * // The `_.property` iteratee shorthand.
   * _.mapValues(users, 'age');
   * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
   */
  function mapValues(object, iteratee) {
    var result = {};
    iteratee = _baseIteratee(iteratee);

    _baseForOwn(object, function(value, key, object) {
      _baseAssignValue(result, key, iteratee(value, key, object));
    });
    return result;
  }

  var mapValues_1 = mapValues;

  function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }
  var rectWithPoints = function rectWithPoints(_ref, _ref2) {
    var x1 = _ref.x,
        y1 = _ref.y;
    var x2 = _ref2.x,
        y2 = _ref2.y;
    return {
      x: Math.min(x1, x2),
      y: Math.min(y1, y2),
      width: Math.abs(x2 - x1),
      height: Math.abs(y2 - y1)
    };
  };
  /**
   * Compute the x, y, width, and height of a box from two reference points.
   * @param  {Object} coords     x1, x2, y1, and y2
   * @return {Object} object
   */

  var rectWithCoords = function rectWithCoords(_ref3) {
    var x1 = _ref3.x1,
        y1 = _ref3.y1,
        x2 = _ref3.x2,
        y2 = _ref3.y2;
    return rectWithPoints({
      x: x1,
      y: y1
    }, {
      x: x2,
      y: y2
    });
  };
  var ScaleHelper =
  /*#__PURE__*/
  function () {
    _createClass$5(ScaleHelper, null, [{
      key: "create",
      value: function create(obj) {
        return new ScaleHelper(obj);
      }
    }]);

    function ScaleHelper(scale) {
      _classCallCheck$5(this, ScaleHelper);

      this.scale = scale;
    }

    _createClass$5(ScaleHelper, [{
      key: "apply",
      value: function apply(value) {
        var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            bandAware = _ref4.bandAware,
            position = _ref4.position;

        if (value === undefined) {
          return undefined;
        }

        if (position) {
          switch (position) {
            case 'start':
              {
                return this.scale(value);
              }

            case 'middle':
              {
                var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
                return this.scale(value) + offset;
              }

            case 'end':
              {
                var _offset = this.bandwidth ? this.bandwidth() : 0;

                return this.scale(value) + _offset;
              }

            default:
              {
                return this.scale(value);
              }
          }
        }

        if (bandAware) {
          var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;

          return this.scale(value) + _offset2;
        }

        return this.scale(value);
      }
    }, {
      key: "isInRange",
      value: function isInRange(value) {
        var range = this.range();
        var first = range[0];
        var last = range[range.length - 1];
        return first <= last ? value >= first && value <= last : value >= last && value <= first;
      }
    }, {
      key: "domain",
      get: function get() {
        return this.scale.domain;
      }
    }, {
      key: "range",
      get: function get() {
        return this.scale.range;
      }
    }, {
      key: "rangeMin",
      get: function get() {
        return this.range()[0];
      }
    }, {
      key: "rangeMax",
      get: function get() {
        return this.range()[1];
      }
    }, {
      key: "bandwidth",
      get: function get() {
        return this.scale.bandwidth;
      }
    }]);

    return ScaleHelper;
  }();
  ScaleHelper.EPS = 1e-4;
  var LabeledScaleHelper =
  /*#__PURE__*/
  function () {
    _createClass$5(LabeledScaleHelper, null, [{
      key: "create",
      value: function create(obj) {
        return new this(obj);
      }
    }]);

    function LabeledScaleHelper(scales) {
      _classCallCheck$5(this, LabeledScaleHelper);

      this.scales = mapValues_1(scales, ScaleHelper.create);
      Object.assign(this, this.scales);
    }

    _createClass$5(LabeledScaleHelper, [{
      key: "apply",
      value: function apply(coords) {
        var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            bandAware = _ref5.bandAware;

        var scales = this.scales;
        return mapValues_1(coords, function (value, label) {
          return scales[label].apply(value, {
            bandAware: bandAware
          });
        });
      }
    }, {
      key: "isInRange",
      value: function isInRange(coords) {
        var scales = this.scales;
        return every_1(coords, function (value, label) {
          return scales[label].isInRange(value);
        });
      }
    }]);

    return LabeledScaleHelper;
  }();

  function _typeof$4(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }

  function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(source, true).forEach(function (key) { _defineProperty$5(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$4(self, call) { if (call && (_typeof$4(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$5(self); }

  function _assertThisInitialized$5(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$4(o) { _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$4(o); }

  function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$4(subClass, superClass); }

  function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }

  function _extends$6() { _extends$6 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }

  var renderLine = function renderLine(option, props) {
    var line;

    if (React__default['default'].isValidElement(option)) {
      line = React__default['default'].cloneElement(option, props);
    } else if (isFunction_1(option)) {
      line = option(props);
    } else {
      line = React__default['default'].createElement("line", _extends$6({}, props, {
        className: "recharts-reference-line-line"
      }));
    }

    return line;
  };

  var ReferenceLine =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$4(ReferenceLine, _PureComponent);

    function ReferenceLine() {
      _classCallCheck$4(this, ReferenceLine);

      return _possibleConstructorReturn$4(this, _getPrototypeOf$4(ReferenceLine).apply(this, arguments));
    }

    _createClass$4(ReferenceLine, [{
      key: "getEndPoints",
      value: function getEndPoints(scales, isFixedX, isFixedY, isSegment) {
        var _this$props = this.props,
            _this$props$viewBox = _this$props.viewBox,
            x = _this$props$viewBox.x,
            y = _this$props$viewBox.y,
            width = _this$props$viewBox.width,
            height = _this$props$viewBox.height,
            position = _this$props.position;

        if (isFixedY) {
          var _this$props2 = this.props,
              yCoord = _this$props2.y,
              orientation = _this$props2.yAxis.orientation;
          var coord = scales.y.apply(yCoord, {
            position: position
          });

          if (ifOverflowMatches(this.props, 'discard') && !scales.y.isInRange(coord)) {
            return null;
          }

          var points = [{
            x: x + width,
            y: coord
          }, {
            x: x,
            y: coord
          }];
          return orientation === 'left' ? points.reverse() : points;
        }

        if (isFixedX) {
          var _this$props3 = this.props,
              xCoord = _this$props3.x,
              _orientation = _this$props3.xAxis.orientation;

          var _coord = scales.x.apply(xCoord, {
            position: position
          });

          if (ifOverflowMatches(this.props, 'discard') && !scales.x.isInRange(_coord)) {
            return null;
          }

          var _points = [{
            x: _coord,
            y: y + height
          }, {
            x: _coord,
            y: y
          }];
          return _orientation === 'top' ? _points.reverse() : _points;
        }

        if (isSegment) {
          var segment = this.props.segment;

          var _points2 = segment.map(function (p) {
            return scales.apply(p, {
              position: position
            });
          });

          if (ifOverflowMatches(this.props, 'discard') && some_1(_points2, function (p) {
            return !scales.isInRange(p);
          })) {
            return null;
          }

          return _points2;
        }

        return null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props4 = this.props,
            fixedX = _this$props4.x,
            fixedY = _this$props4.y,
            segment = _this$props4.segment,
            xAxis = _this$props4.xAxis,
            yAxis = _this$props4.yAxis,
            shape = _this$props4.shape,
            className = _this$props4.className;
            _this$props4.alwaysShow;
            var clipPathId = _this$props4.clipPathId;
        var scales = LabeledScaleHelper.create({
          x: xAxis.scale,
          y: yAxis.scale
        });
        var isX = isNumOrStr(fixedX);
        var isY = isNumOrStr(fixedY);
        var isSegment = segment && segment.length === 2;
        var endPoints = this.getEndPoints(scales, isX, isY, isSegment);

        if (!endPoints) {
          return null;
        }

        var _endPoints = _slicedToArray(endPoints, 2),
            _endPoints$ = _endPoints[0],
            x1 = _endPoints$.x,
            y1 = _endPoints$.y,
            _endPoints$2 = _endPoints[1],
            x2 = _endPoints$2.x,
            y2 = _endPoints$2.y;

        var clipPath = ifOverflowMatches(this.props, 'hidden') ? "url(#".concat(clipPathId, ")") : undefined;

        var props = _objectSpread$4({
          clipPath: clipPath
        }, getPresentationAttributes(this.props), {}, filterEventAttributes(this.props), {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        });

        return React__default['default'].createElement(Layer, {
          className: classnames('recharts-reference-line', className)
        }, renderLine(shape, props), Label$1.renderCallByParent(this.props, rectWithCoords({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        })));
      }
    }]);

    return ReferenceLine;
  }(React.PureComponent);

  ReferenceLine.displayName = 'ReferenceLine';
  ReferenceLine.propTypes = _objectSpread$4({}, PRESENTATION_ATTRIBUTES, {
    viewBox: propTypes$5.shape({
      x: propTypes$5.number,
      y: propTypes$5.number,
      width: propTypes$5.number,
      height: propTypes$5.number
    }),
    xAxis: propTypes$5.object,
    yAxis: propTypes$5.object,
    isFront: propTypes$5.bool,
    alwaysShow: propTypes$5.bool,
    ifOverflow: propTypes$5.oneOf(['hidden', 'visible', 'discard', 'extendDomain']),
    x: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    y: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    segment: propTypes$5.arrayOf(propTypes$5.shape({
      x: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
      y: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string])
    })),
    position: propTypes$5.oneOf(['middle', 'start', 'end']),
    className: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    yAxisId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    xAxisId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    shape: propTypes$5.func
  });
  ReferenceLine.defaultProps = {
    isFront: false,
    ifOverflow: 'discard',
    xAxisId: 0,
    yAxisId: 0,
    fill: 'none',
    stroke: '#ccc',
    fillOpacity: 1,
    strokeWidth: 1,
    position: 'middle'
  };

  function _typeof$3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }

  function _extends$5() { _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }

  function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(source, true).forEach(function (key) { _defineProperty$4(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$3(self, call) { if (call && (_typeof$3(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$4(self); }

  function _assertThisInitialized$4(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$3(o) { _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$3(o); }

  function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$3(subClass, superClass); }

  function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }

  var ReferenceDot =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$3(ReferenceDot, _PureComponent);

    function ReferenceDot() {
      _classCallCheck$3(this, ReferenceDot);

      return _possibleConstructorReturn$3(this, _getPrototypeOf$3(ReferenceDot).apply(this, arguments));
    }

    _createClass$3(ReferenceDot, [{
      key: "getCoordinate",
      value: function getCoordinate() {
        var _this$props = this.props,
            x = _this$props.x,
            y = _this$props.y,
            xAxis = _this$props.xAxis,
            yAxis = _this$props.yAxis;
        var scales = LabeledScaleHelper.create({
          x: xAxis.scale,
          y: yAxis.scale
        });
        var result = scales.apply({
          x: x,
          y: y
        }, {
          bandAware: true
        });

        if (ifOverflowMatches(this.props, 'discard') && !scales.isInRange(result)) {
          return null;
        }

        return result;
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            x = _this$props2.x,
            y = _this$props2.y,
            r = _this$props2.r;
            _this$props2.alwaysShow;
            var clipPathId = _this$props2.clipPathId;
        var isX = isNumOrStr(x);
        var isY = isNumOrStr(y);

        if (!isX || !isY) {
          return null;
        }

        var coordinate = this.getCoordinate();

        if (!coordinate) {
          return null;
        }

        var cx = coordinate.x,
            cy = coordinate.y;
        var _this$props3 = this.props,
            shape = _this$props3.shape,
            className = _this$props3.className;
        var clipPath = ifOverflowMatches(this.props, 'hidden') ? "url(#".concat(clipPathId, ")") : undefined;

        var dotProps = _objectSpread$3({
          clipPath: clipPath
        }, getPresentationAttributes(this.props), {}, filterEventAttributes(this.props), {
          cx: cx,
          cy: cy
        });

        return React__default['default'].createElement(Layer, {
          className: classnames('recharts-reference-dot', className)
        }, this.constructor.renderDot(shape, dotProps), Label$1.renderCallByParent(this.props, {
          x: cx - r,
          y: cy - r,
          width: 2 * r,
          height: 2 * r
        }));
      }
    }], [{
      key: "renderDot",
      value: function renderDot(option, props) {
        var dot;

        if (React__default['default'].isValidElement(option)) {
          dot = React__default['default'].cloneElement(option, props);
        } else if (isFunction_1(option)) {
          dot = option(props);
        } else {
          dot = React__default['default'].createElement(Dot, _extends$5({}, props, {
            cx: props.cx,
            cy: props.cy,
            className: "recharts-reference-dot-dot"
          }));
        }

        return dot;
      }
    }]);

    return ReferenceDot;
  }(React.PureComponent);

  ReferenceDot.displayName = 'ReferenceDot';
  ReferenceDot.propTypes = _objectSpread$3({}, PRESENTATION_ATTRIBUTES, {}, EVENT_ATTRIBUTES, {
    r: propTypes$5.number,
    xAxis: propTypes$5.shape({
      scale: propTypes$5.func
    }),
    yAxis: propTypes$5.shape({
      scale: propTypes$5.func
    }),
    isFront: propTypes$5.bool,
    alwaysShow: propTypes$5.bool,
    ifOverflow: propTypes$5.oneOf(['hidden', 'visible', 'discard', 'extendDomain']),
    x: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    y: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    className: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    yAxisId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    xAxisId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    shape: propTypes$5.oneOfType([propTypes$5.func, propTypes$5.element]),
    clipPathId: propTypes$5.string
  });
  ReferenceDot.defaultProps = {
    isFront: false,
    ifOverflow: 'discard',
    xAxisId: 0,
    yAxisId: 0,
    r: 10,
    fill: '#fff',
    stroke: '#ccc',
    fillOpacity: 1,
    strokeWidth: 1
  };

  function _typeof$2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

  function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(source, true).forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$2(self, call) { if (call && (_typeof$2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$3(self); }

  function _assertThisInitialized$3(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$2(o) { _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$2(o); }

  function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$2(subClass, superClass); }

  function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }

  var ReferenceArea =
  /*#__PURE__*/
  function (_PureComponent) {
    _inherits$2(ReferenceArea, _PureComponent);

    function ReferenceArea() {
      _classCallCheck$2(this, ReferenceArea);

      return _possibleConstructorReturn$2(this, _getPrototypeOf$2(ReferenceArea).apply(this, arguments));
    }

    _createClass$2(ReferenceArea, [{
      key: "getRect",
      value: function getRect(hasX1, hasX2, hasY1, hasY2) {
        var _this$props = this.props,
            xValue1 = _this$props.x1,
            xValue2 = _this$props.x2,
            yValue1 = _this$props.y1,
            yValue2 = _this$props.y2,
            xAxis = _this$props.xAxis,
            yAxis = _this$props.yAxis;
        var scale = LabeledScaleHelper.create({
          x: xAxis.scale,
          y: yAxis.scale
        });
        var p1 = {
          x: hasX1 ? scale.x.apply(xValue1) : scale.x.rangeMin,
          y: hasY1 ? scale.y.apply(yValue1) : scale.y.rangeMin
        };
        var p2 = {
          x: hasX2 ? scale.x.apply(xValue2) : scale.x.rangeMax,
          y: hasY2 ? scale.y.apply(yValue2) : scale.y.rangeMax
        };

        if (ifOverflowMatches(this.props, 'discard') && (!scale.isInRange(p1) || !scale.isInRange(p2))) {
          return null;
        }

        return rectWithPoints(p1, p2);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            x1 = _this$props2.x1,
            x2 = _this$props2.x2,
            y1 = _this$props2.y1,
            y2 = _this$props2.y2,
            className = _this$props2.className;
            _this$props2.alwaysShow;
            var clipPathId = _this$props2.clipPathId;
        var hasX1 = isNumOrStr(x1);
        var hasX2 = isNumOrStr(x2);
        var hasY1 = isNumOrStr(y1);
        var hasY2 = isNumOrStr(y2);
        var shape = this.props.shape;

        if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {
          return null;
        }

        var rect = this.getRect(hasX1, hasX2, hasY1, hasY2);

        if (!rect && !shape) {
          return null;
        }

        var clipPath = ifOverflowMatches(this.props, 'hidden') ? "url(#".concat(clipPathId, ")") : undefined;
        return React__default['default'].createElement(Layer, {
          className: classnames('recharts-reference-area', className)
        }, this.constructor.renderRect(shape, _objectSpread$2({
          clipPath: clipPath
        }, this.props, {}, rect)), Label$1.renderCallByParent(this.props, rect));
      }
    }], [{
      key: "renderRect",
      value: function renderRect(option, props) {
        var rect;

        if (React__default['default'].isValidElement(option)) {
          rect = React__default['default'].cloneElement(option, props);
        } else if (isFunction_1(option)) {
          rect = option(props);
        } else {
          rect = React__default['default'].createElement(Rectangle, _extends$4({}, props, {
            className: "recharts-reference-area-rect"
          }));
        }

        return rect;
      }
    }]);

    return ReferenceArea;
  }(React.PureComponent);

  ReferenceArea.displayName = 'ReferenceArea';
  ReferenceArea.propTypes = _objectSpread$2({}, PRESENTATION_ATTRIBUTES, {
    viewBox: propTypes$5.shape({
      x: propTypes$5.number,
      y: propTypes$5.number,
      width: propTypes$5.number,
      height: propTypes$5.number
    }),
    xAxis: propTypes$5.object,
    yAxis: propTypes$5.object,
    isFront: propTypes$5.bool,
    alwaysShow: propTypes$5.bool,
    ifOverflow: propTypes$5.oneOf(['hidden', 'visible', 'discard', 'extendDomain']),
    x1: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    x2: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    y1: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    y2: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    className: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
    yAxisId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    xAxisId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
    shape: propTypes$5.oneOfType([propTypes$5.func, propTypes$5.element])
  });
  ReferenceArea.defaultProps = {
    isFront: false,
    ifOverflow: 'discard',
    xAxisId: 0,
    yAxisId: 0,
    r: 10,
    fill: '#ccc',
    fillOpacity: 0.5,
    stroke: 'none',
    strokeWidth: 1
  };

  function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

  function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _objectWithoutProperties$1(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$2(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$2(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn$1(self, call) { if (call && (_typeof$1(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$2(self); }

  function _assertThisInitialized$2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf$1(o) { _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$1(o); }

  function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$1(subClass, superClass); }

  function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }

  var CartesianAxis =
  /*#__PURE__*/
  function (_Component) {
    _inherits$1(CartesianAxis, _Component);

    function CartesianAxis() {
      _classCallCheck$1(this, CartesianAxis);

      return _possibleConstructorReturn$1(this, _getPrototypeOf$1(CartesianAxis).apply(this, arguments));
    }

    _createClass$1(CartesianAxis, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(_ref, state) {
        var viewBox = _ref.viewBox,
            restProps = _objectWithoutProperties$1(_ref, ["viewBox"]);

        // props.viewBox is sometimes generated every time -
        // check that specially as object equality is likely to fail
        var _this$props = this.props,
            viewBoxOld = _this$props.viewBox,
            restPropsOld = _objectWithoutProperties$1(_this$props, ["viewBox"]);

        return !shallowEqual(viewBox, viewBoxOld) || !shallowEqual(restProps, restPropsOld) || !shallowEqual(state, this.state);
      }
      /**
       * Calculate the coordinates of endpoints in ticks
       * @param  {Object} data The data of a simple tick
       * @return {Object} (x1, y1): The coordinate of endpoint close to tick text
       *  (x2, y2): The coordinate of endpoint close to axis
       */

    }, {
      key: "getTickLineCoord",
      value: function getTickLineCoord(data) {
        var _this$props2 = this.props,
            x = _this$props2.x,
            y = _this$props2.y,
            width = _this$props2.width,
            height = _this$props2.height,
            orientation = _this$props2.orientation,
            tickSize = _this$props2.tickSize,
            mirror = _this$props2.mirror,
            tickMargin = _this$props2.tickMargin;
        var x1, x2, y1, y2, tx, ty;
        var sign = mirror ? -1 : 1;
        var finalTickSize = data.tickSize || tickSize;
        var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;

        switch (orientation) {
          case 'top':
            x1 = x2 = data.coordinate;
            y2 = y + !mirror * height;
            y1 = y2 - sign * finalTickSize;
            ty = y1 - sign * tickMargin;
            tx = tickCoord;
            break;

          case 'left':
            y1 = y2 = data.coordinate;
            x2 = x + !mirror * width;
            x1 = x2 - sign * finalTickSize;
            tx = x1 - sign * tickMargin;
            ty = tickCoord;
            break;

          case 'right':
            y1 = y2 = data.coordinate;
            x2 = x + mirror * width;
            x1 = x2 + sign * finalTickSize;
            tx = x1 + sign * tickMargin;
            ty = tickCoord;
            break;

          default:
            x1 = x2 = data.coordinate;
            y2 = y + mirror * height;
            y1 = y2 + sign * finalTickSize;
            ty = y1 + sign * tickMargin;
            tx = tickCoord;
            break;
        }

        return {
          line: {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          },
          tick: {
            x: tx,
            y: ty
          }
        };
      }
    }, {
      key: "getTickTextAnchor",
      value: function getTickTextAnchor() {
        var _this$props3 = this.props,
            orientation = _this$props3.orientation,
            mirror = _this$props3.mirror;
        var textAnchor;

        switch (orientation) {
          case 'left':
            textAnchor = mirror ? 'start' : 'end';
            break;

          case 'right':
            textAnchor = mirror ? 'end' : 'start';
            break;

          default:
            textAnchor = 'middle';
            break;
        }

        return textAnchor;
      }
    }, {
      key: "getTickVerticalAnchor",
      value: function getTickVerticalAnchor() {
        var _this$props4 = this.props,
            orientation = _this$props4.orientation,
            mirror = _this$props4.mirror;
        var verticalAnchor = 'end';

        switch (orientation) {
          case 'left':
          case 'right':
            verticalAnchor = 'middle';
            break;

          case 'top':
            verticalAnchor = mirror ? 'start' : 'end';
            break;

          default:
            verticalAnchor = mirror ? 'end' : 'start';
            break;
        }

        return verticalAnchor;
      }
    }, {
      key: "renderAxisLine",
      value: function renderAxisLine() {
        var _this$props5 = this.props,
            x = _this$props5.x,
            y = _this$props5.y,
            width = _this$props5.width,
            height = _this$props5.height,
            orientation = _this$props5.orientation,
            axisLine = _this$props5.axisLine,
            mirror = _this$props5.mirror;

        var props = _objectSpread$1({}, getPresentationAttributes(this.props), {
          fill: 'none'
        }, getPresentationAttributes(axisLine));

        if (orientation === 'top' || orientation === 'bottom') {
          var needHeight = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;
          props = _objectSpread$1({}, props, {
            x1: x,
            y1: y + needHeight * height,
            x2: x + width,
            y2: y + needHeight * height
          });
        } else {
          var needWidth = orientation === 'left' && !mirror || orientation === 'right' && mirror;
          props = _objectSpread$1({}, props, {
            x1: x + needWidth * width,
            y1: y,
            x2: x + needWidth * width,
            y2: y + height
          });
        }

        return React__default['default'].createElement("line", _extends$3({
          className: "recharts-cartesian-axis-line"
        }, props));
      }
    }, {
      key: "renderTicks",

      /**
       * render the ticks
       * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
       * @return {ReactComponent} renderedTicks
       */
      value: function renderTicks(ticks) {
        var _this = this;

        var _this$props6 = this.props,
            tickLine = _this$props6.tickLine,
            stroke = _this$props6.stroke,
            tick = _this$props6.tick,
            tickFormatter = _this$props6.tickFormatter,
            unit = _this$props6.unit;
        var finalTicks = CartesianAxis.getTicks(_objectSpread$1({}, this.props, {
          ticks: ticks
        }));
        var textAnchor = this.getTickTextAnchor();
        var verticalAnchor = this.getTickVerticalAnchor();
        var axisProps = getPresentationAttributes(this.props);
        var customTickProps = getPresentationAttributes(tick);

        var tickLineProps = _objectSpread$1({}, axisProps, {
          fill: 'none'
        }, getPresentationAttributes(tickLine));

        var items = finalTicks.map(function (entry, i) {
          var _this$getTickLineCoor = _this.getTickLineCoord(entry),
              lineCoord = _this$getTickLineCoor.line,
              tickCoord = _this$getTickLineCoor.tick;

          var tickProps = _objectSpread$1({
            textAnchor: textAnchor,
            verticalAnchor: verticalAnchor
          }, axisProps, {
            stroke: 'none',
            fill: stroke
          }, customTickProps, {}, tickCoord, {
            index: i,
            payload: entry,
            visibleTicksCount: finalTicks.length
          });

          return React__default['default'].createElement(Layer, _extends$3({
            className: "recharts-cartesian-axis-tick",
            key: "tick-".concat(i) // eslint-disable-line react/no-array-index-key

          }, filterEventsOfChild(_this.props, entry, i)), tickLine && React__default['default'].createElement("line", _extends$3({
            className: "recharts-cartesian-axis-tick-line"
          }, tickLineProps, lineCoord)), tick && _this.constructor.renderTickItem(tick, tickProps, "".concat(isFunction_1(tickFormatter) ? tickFormatter(entry.value) : entry.value).concat(unit || '')));
        });
        return React__default['default'].createElement("g", {
          className: "recharts-cartesian-axis-ticks"
        }, items);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props7 = this.props,
            axisLine = _this$props7.axisLine,
            width = _this$props7.width,
            height = _this$props7.height,
            ticksGenerator = _this$props7.ticksGenerator,
            className = _this$props7.className,
            hide = _this$props7.hide;

        if (hide) {
          return null;
        }

        var _this$props8 = this.props,
            ticks = _this$props8.ticks,
            noTicksProps = _objectWithoutProperties$1(_this$props8, ["ticks"]);

        var finalTicks = ticks;

        if (isFunction_1(ticksGenerator)) {
          finalTicks = ticks && ticks.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);
        }

        if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) {
          return null;
        }

        return React__default['default'].createElement(Layer, {
          className: classnames('recharts-cartesian-axis', className)
        }, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks), Label$1.renderCallByParent(this.props));
      }
    }], [{
      key: "getTicks",
      value: function getTicks(props) {
        var tick = props.tick,
            ticks = props.ticks,
            viewBox = props.viewBox,
            minTickGap = props.minTickGap,
            orientation = props.orientation,
            interval = props.interval,
            tickFormatter = props.tickFormatter,
            unit = props.unit;

        if (!ticks || !ticks.length || !tick) {
          return [];
        }

        if (isNumber(interval) || isSsr()) {
          return CartesianAxis.getNumberIntervalTicks(ticks, isNumber(interval) ? interval : 0);
        }

        if (interval === 'preserveStartEnd') {
          return CartesianAxis.getTicksStart({
            ticks: ticks,
            tickFormatter: tickFormatter,
            viewBox: viewBox,
            orientation: orientation,
            minTickGap: minTickGap,
            unit: unit
          }, true);
        }

        if (interval === 'preserveStart') {
          return CartesianAxis.getTicksStart({
            ticks: ticks,
            tickFormatter: tickFormatter,
            viewBox: viewBox,
            orientation: orientation,
            minTickGap: minTickGap,
            unit: unit
          });
        }

        return CartesianAxis.getTicksEnd({
          ticks: ticks,
          tickFormatter: tickFormatter,
          viewBox: viewBox,
          orientation: orientation,
          minTickGap: minTickGap,
          unit: unit
        });
      }
    }, {
      key: "getNumberIntervalTicks",
      value: function getNumberIntervalTicks(ticks, interval) {
        return ticks.filter(function (entry, i) {
          return i % (interval + 1) === 0;
        });
      }
    }, {
      key: "getTicksStart",
      value: function getTicksStart(_ref2, preserveEnd) {
        var ticks = _ref2.ticks,
            tickFormatter = _ref2.tickFormatter,
            viewBox = _ref2.viewBox,
            orientation = _ref2.orientation,
            minTickGap = _ref2.minTickGap,
            unit = _ref2.unit;
        var x = viewBox.x,
            y = viewBox.y,
            width = viewBox.width,
            height = viewBox.height;
        var sizeKey = orientation === 'top' || orientation === 'bottom' ? 'width' : 'height';
        var result = (ticks || []).slice(); // we need add the width of 'unit' only when sizeKey === 'width'

        var unitSize = unit && sizeKey === 'width' ? getStringSize(unit)[sizeKey] : 0;
        var len = result.length;
        var sign = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;
        var start, end;

        if (sign === 1) {
          start = sizeKey === 'width' ? x : y;
          end = sizeKey === 'width' ? x + width : y + height;
        } else {
          start = sizeKey === 'width' ? x + width : y + height;
          end = sizeKey === 'width' ? x : y;
        }

        if (preserveEnd) {
          // Try to guarantee the tail to be displayed
          var tail = ticks[len - 1];
          var tailContent = isFunction_1(tickFormatter) ? tickFormatter(tail.value) : tail.value;
          var tailSize = getStringSize(tailContent)[sizeKey] + unitSize;
          var tailGap = sign * (tail.coordinate + sign * tailSize / 2 - end);
          result[len - 1] = tail = _objectSpread$1({}, tail, {
            tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign : tail.coordinate
          });
          var isTailShow = sign * (tail.tickCoord - sign * tailSize / 2 - start) >= 0 && sign * (tail.tickCoord + sign * tailSize / 2 - end) <= 0;

          if (isTailShow) {
            end = tail.tickCoord - sign * (tailSize / 2 + minTickGap);
            result[len - 1] = _objectSpread$1({}, tail, {
              isShow: true
            });
          }
        }

        var count = preserveEnd ? len - 1 : len;

        for (var _i = 0; _i < count; _i++) {
          var entry = result[_i];
          var content = isFunction_1(tickFormatter) ? tickFormatter(entry.value) : entry.value;
          var size = getStringSize(content)[sizeKey] + unitSize;

          if (_i === 0) {
            var gap = sign * (entry.coordinate - sign * size / 2 - start);
            result[_i] = entry = _objectSpread$1({}, entry, {
              tickCoord: gap < 0 ? entry.coordinate - gap * sign : entry.coordinate
            });
          } else {
            result[_i] = entry = _objectSpread$1({}, entry, {
              tickCoord: entry.coordinate
            });
          }

          var isShow = sign * (entry.tickCoord - sign * size / 2 - start) >= 0 && sign * (entry.tickCoord + sign * size / 2 - end) <= 0;

          if (isShow) {
            start = entry.tickCoord + sign * (size / 2 + minTickGap);
            result[_i] = _objectSpread$1({}, entry, {
              isShow: true
            });
          }
        }

        return result.filter(function (entry) {
          return entry.isShow;
        });
      }
    }, {
      key: "getTicksEnd",
      value: function getTicksEnd(_ref3) {
        var ticks = _ref3.ticks,
            tickFormatter = _ref3.tickFormatter,
            viewBox = _ref3.viewBox,
            orientation = _ref3.orientation,
            minTickGap = _ref3.minTickGap,
            unit = _ref3.unit;
        var x = viewBox.x,
            y = viewBox.y,
            width = viewBox.width,
            height = viewBox.height;
        var sizeKey = orientation === 'top' || orientation === 'bottom' ? 'width' : 'height'; // we need add the width of 'unit' only when sizeKey === 'width'

        var unitSize = unit && sizeKey === 'width' ? getStringSize(unit)[sizeKey] : 0;
        var result = (ticks || []).slice();
        var len = result.length;
        var sign = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;
        var start, end;

        if (sign === 1) {
          start = sizeKey === 'width' ? x : y;
          end = sizeKey === 'width' ? x + width : y + height;
        } else {
          start = sizeKey === 'width' ? x + width : y + height;
          end = sizeKey === 'width' ? x : y;
        }

        for (var _i2 = len - 1; _i2 >= 0; _i2--) {
          var entry = result[_i2];
          var content = isFunction_1(tickFormatter) ? tickFormatter(entry.value) : entry.value;
          var size = getStringSize(content)[sizeKey] + unitSize;

          if (_i2 === len - 1) {
            var gap = sign * (entry.coordinate + sign * size / 2 - end);
            result[_i2] = entry = _objectSpread$1({}, entry, {
              tickCoord: gap > 0 ? entry.coordinate - gap * sign : entry.coordinate
            });
          } else {
            result[_i2] = entry = _objectSpread$1({}, entry, {
              tickCoord: entry.coordinate
            });
          }

          var isShow = sign * (entry.tickCoord - sign * size / 2 - start) >= 0 && sign * (entry.tickCoord + sign * size / 2 - end) <= 0;

          if (isShow) {
            end = entry.tickCoord - sign * (size / 2 + minTickGap);
            result[_i2] = _objectSpread$1({}, entry, {
              isShow: true
            });
          }
        }

        return result.filter(function (entry) {
          return entry.isShow;
        });
      }
    }, {
      key: "renderTickItem",
      value: function renderTickItem(option, props, value) {
        var tickItem;

        if (React__default['default'].isValidElement(option)) {
          tickItem = React__default['default'].cloneElement(option, props);
        } else if (isFunction_1(option)) {
          tickItem = option(props);
        } else {
          tickItem = React__default['default'].createElement(Text, _extends$3({}, props, {
            className: "recharts-cartesian-axis-tick-value"
          }), value);
        }

        return tickItem;
      }
    }]);

    return CartesianAxis;
  }(React.Component);

  CartesianAxis.displayName = 'CartesianAxis';
  CartesianAxis.propTypes = _objectSpread$1({}, PRESENTATION_ATTRIBUTES, {}, EVENT_ATTRIBUTES, {
    className: propTypes$5.string,
    x: propTypes$5.number,
    y: propTypes$5.number,
    width: propTypes$5.number,
    height: propTypes$5.number,
    orientation: propTypes$5.oneOf(['top', 'bottom', 'left', 'right']),
    // The viewBox of svg
    viewBox: propTypes$5.shape({
      x: propTypes$5.number,
      y: propTypes$5.number,
      width: propTypes$5.number,
      height: propTypes$5.number
    }),
    tick: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.func, propTypes$5.object, propTypes$5.element]),
    axisLine: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.object]),
    tickLine: propTypes$5.oneOfType([propTypes$5.bool, propTypes$5.object]),
    mirror: propTypes$5.bool,
    tickMargin: propTypes$5.number.isRequired,
    minTickGap: propTypes$5.number,
    ticks: propTypes$5.array,
    tickSize: propTypes$5.number,
    stroke: propTypes$5.string,
    tickFormatter: propTypes$5.func,
    ticksGenerator: propTypes$5.func,
    interval: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.oneOf(['preserveStart', 'preserveEnd', 'preserveStartEnd'])])
  });
  CartesianAxis.defaultProps = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    viewBox: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    // The orientation of axis
    orientation: 'bottom',
    // The ticks
    ticks: [],
    stroke: '#666',
    tickLine: true,
    axisLine: true,
    tick: true,
    mirror: false,
    minTickGap: 5,
    // The width or height of tick
    tickSize: 6,
    tickMargin: 2,
    interval: 'preserveEnd'
  };

  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike_1(collection)) {
        var iteratee = _baseIteratee(predicate);
        collection = keys_1(collection);
        predicate = function(key) { return iteratee(iterable[key], key, iterable); };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }

  var _createFind = createFind;

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;

    return result === result ? (remainder ? result - remainder : result) : 0;
  }

  var toInteger_1 = toInteger;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex$1(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger_1(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return _baseFindIndex(array, _baseIteratee(predicate), index);
  }

  var findIndex_1 = findIndex$1;

  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */
  var find$1 = _createFind(findIndex_1);

  var find_1 = find$1;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject_1(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce_1(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  var throttle_1 = throttle;

  var detectReferenceElementsDomain = function detectReferenceElementsDomain(children, domain, axisId, axisType, specifiedTicks) {
    var lines = findAllByType(children, ReferenceLine);
    var dots = findAllByType(children, ReferenceDot);
    var elements = lines.concat(dots);
    var areas = findAllByType(children, ReferenceArea);
    var idKey = "".concat(axisType, "Id");
    var valueKey = axisType[0];
    var finalDomain = domain;

    if (elements.length) {
      finalDomain = elements.reduce(function (result, el) {
        if (el.props[idKey] === axisId && ifOverflowMatches(el.props, 'extendDomain') && isNumber(el.props[valueKey])) {
          var value = el.props[valueKey];
          return [Math.min(result[0], value), Math.max(result[1], value)];
        }

        return result;
      }, finalDomain);
    }

    if (areas.length) {
      var key1 = "".concat(valueKey, "1");
      var key2 = "".concat(valueKey, "2");
      finalDomain = areas.reduce(function (result, el) {
        if (el.props[idKey] === axisId && ifOverflowMatches(el.props, 'extendDomain') && isNumber(el.props[key1]) && isNumber(el.props[key2])) {
          var value1 = el.props[key1];
          var value2 = el.props[key2];
          return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];
        }

        return result;
      }, finalDomain);
    }

    if (specifiedTicks && specifiedTicks.length) {
      finalDomain = specifiedTicks.reduce(function (result, tick) {
        if (isNumber(tick)) {
          return [Math.min(result[0], tick), Math.max(result[1], tick)];
        }

        return result;
      }, finalDomain);
    }

    return finalDomain;
  };

  // Copyright Joyent, Inc. and other Node contributors.

  var R = typeof Reflect === 'object' ? Reflect : null;
  var ReflectApply = R && typeof R.apply === 'function'
    ? R.apply
    : function ReflectApply(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };

  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === 'function') {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target)
        .concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target);
    };
  }

  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }

  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
  };

  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  var events = EventEmitter;
  var once_1 = once;

  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  var defaultMaxListeners = 10;

  function checkListener(listener) {
    if (typeof listener !== 'function') {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }

  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
      }
      defaultMaxListeners = arg;
    }
  });

  EventEmitter.init = function() {

    if (this._events === undefined ||
        this._events === Object.getPrototypeOf(this)._events) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }
    this._maxListeners = n;
    return this;
  };

  function _getMaxListeners(that) {
    if (that._maxListeners === undefined)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };

  EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = (type === 'error');

    var events = this._events;
    if (events !== undefined)
      doError = (doError && events.error === undefined);
    else if (!doError)
      return false;

    // If there is no 'error' event listener then throw.
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
      }
      // At least give some kind of context to the user
      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
      err.context = er;
      throw err; // Unhandled 'error' event
    }

    var handler = events[type];

    if (handler === undefined)
      return false;

    if (typeof handler === 'function') {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;

    checkListener(listener);

    events = target._events;
    if (events === undefined) {
      events = target._events = Object.create(null);
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener !== undefined) {
        target.emit('newListener', type,
                    listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }

    if (existing === undefined) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
        // If we've already got an array, just append.
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }

      // Check for listener leak
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        // No error code for this since it is a Warning
        // eslint-disable-next-line no-restricted-syntax
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + String(type) + ' listeners ' +
                            'added. Use emitter.setMaxListeners() to ' +
                            'increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }

    return target;
  }

  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }

  function _onceWrap(target, type, listener) {
    var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

  // Emits a 'removeListener' event if and only if the listener was removed.
  EventEmitter.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;

        checkListener(listener);

        events = this._events;
        if (events === undefined)
          return this;

        list = events[type];
        if (list === undefined)
          return this;

        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0)
            return this;

          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }

          if (list.length === 1)
            events[type] = list[0];

          if (events.removeListener !== undefined)
            this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };

  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

  EventEmitter.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events, i;

        events = this._events;
        if (events === undefined)
          return this;

        // not listening for removeListener, no need to emit
        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else
              delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }

        return this;
      };

  function _listeners(target, type, unwrap) {
    var events = target._events;

    if (events === undefined)
      return [];

    var evlistener = events[type];
    if (evlistener === undefined)
      return [];

    if (typeof evlistener === 'function')
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];

    return unwrap ?
      unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }

  EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };

  EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };

  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events = this._events;

    if (events !== undefined) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener !== undefined) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };

  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
      copy[i] = arr[i];
    return copy;
  }

  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
      list[index] = list[index + 1];
    list.pop();
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }

  function once(emitter, name) {
    return new Promise(function (resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }

      function resolver() {
        if (typeof emitter.removeListener === 'function') {
          emitter.removeListener('error', errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== 'error') {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }

  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
  }

  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === 'function') {
      // EventTarget does not have `error` event semantics like Node
      // EventEmitters, we do not listen for `error` events here.
      emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  events.once = once_1;

  var eventCenter = new events();

  if (eventCenter.setMaxListeners) {
    eventCenter.setMaxListeners(10);
  }
  var SYNC_EVENT = 'recharts.syncMouseEvents';

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$1(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$1(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
  var ORIENT_MAP = {
    xAxis: ['bottom', 'top'],
    yAxis: ['left', 'right']
  };
  var originCoordinate = {
    x: 0,
    y: 0
  };

  var generateCategoricalChart = function generateCategoricalChart(_ref) {
    var chartName = _ref.chartName,
        GraphicalChild = _ref.GraphicalChild,
        _ref$eventType = _ref.eventType,
        eventType = _ref$eventType === void 0 ? 'axis' : _ref$eventType,
        axisComponents = _ref.axisComponents,
        legendContent = _ref.legendContent,
        formatAxisMap = _ref.formatAxisMap,
        defaultProps = _ref.defaultProps,
        propTypes = _ref.propTypes;

    var CategoricalChartWrapper =
    /*#__PURE__*/
    function (_Component) {
      _inherits(CategoricalChartWrapper, _Component);

      /**
       * Returns default, reset state for the categorical chart.
       * @param {Object} props Props object to use when creating the default state
       * @return {Object} Whole new state
       */
      function CategoricalChartWrapper(_props) {
        var _this;

        _classCallCheck(this, CategoricalChartWrapper);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(CategoricalChartWrapper).call(this, _props));

        _this.handleLegendBBoxUpdate = function (box) {
          if (box && _this.legendInstance) {
            var _this$state = _this.state,
                dataStartIndex = _this$state.dataStartIndex,
                dataEndIndex = _this$state.dataEndIndex,
                updateId = _this$state.updateId;

            _this.setState(_this.updateStateOfAxisMapsOffsetAndStackGroups({
              props: _this.props,
              dataStartIndex: dataStartIndex,
              dataEndIndex: dataEndIndex,
              updateId: updateId
            }));
          }
        };

        _this.handleReceiveSyncEvent = function (cId, chartId, data) {
          var _this$props = _this.props,
              syncId = _this$props.syncId,
              layout = _this$props.layout;
          var updateId = _this.state.updateId;

          if (syncId === cId && chartId !== _this.uniqueChartId) {
            var dataStartIndex = data.dataStartIndex,
                dataEndIndex = data.dataEndIndex;

            if (!isNil_1(data.dataStartIndex) || !isNil_1(data.dataEndIndex)) {
              _this.setState(_objectSpread({
                dataStartIndex: dataStartIndex,
                dataEndIndex: dataEndIndex
              }, _this.updateStateOfAxisMapsOffsetAndStackGroups({
                props: _this.props,
                dataStartIndex: dataStartIndex,
                dataEndIndex: dataEndIndex,
                updateId: updateId
              })));
            } else if (!isNil_1(data.activeTooltipIndex)) {
              var chartX = data.chartX,
                  chartY = data.chartY,
                  activeTooltipIndex = data.activeTooltipIndex;
              var _this$state2 = _this.state,
                  offset = _this$state2.offset,
                  tooltipTicks = _this$state2.tooltipTicks;

              if (!offset) {
                return;
              }

              var viewBox = _objectSpread({}, offset, {
                x: offset.left,
                y: offset.top
              }); // When a categotical chart is combined with another chart, the value of chartX
              // and chartY may beyond the boundaries.


              var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);
              var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);
              var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;

              var activePayload = _this.getTooltipContent(activeTooltipIndex);

              var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {
                x: layout === 'horizontal' ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,
                y: layout === 'horizontal' ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate
              } : originCoordinate;

              _this.setState(_objectSpread({}, data, {
                activeLabel: activeLabel,
                activeCoordinate: activeCoordinate,
                activePayload: activePayload
              }));
            } else {
              _this.setState(data);
            }
          }
        };

        _this.handleBrushChange = function (_ref2) {
          var startIndex = _ref2.startIndex,
              endIndex = _ref2.endIndex;

          // Only trigger changes if the extents of the brush have actually changed
          if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {
            var updateId = _this.state.updateId;

            _this.setState(function () {
              return _objectSpread({
                dataStartIndex: startIndex,
                dataEndIndex: endIndex
              }, _this.updateStateOfAxisMapsOffsetAndStackGroups({
                props: _this.props,
                dataStartIndex: startIndex,
                dataEndIndex: endIndex,
                updateId: updateId
              }));
            });

            _this.triggerSyncEvent({
              dataStartIndex: startIndex,
              dataEndIndex: endIndex
            });
          }
        };

        _this.handleMouseEnter = function (e) {
          var onMouseEnter = _this.props.onMouseEnter;

          var mouse = _this.getMouseInfo(e);

          if (mouse) {
            var nextState = _objectSpread({}, mouse, {
              isTooltipActive: true
            });

            _this.setState(nextState);

            _this.triggerSyncEvent(nextState);

            if (isFunction_1(onMouseEnter)) {
              onMouseEnter(nextState, e);
            }
          }
        };

        _this.triggeredAfterMouseMove = function (e) {
          var onMouseMove = _this.props.onMouseMove;

          var mouse = _this.getMouseInfo(e);

          var nextState = mouse ? _objectSpread({}, mouse, {
            isTooltipActive: true
          }) : {
            isTooltipActive: false
          };

          _this.setState(nextState);

          _this.triggerSyncEvent(nextState);

          if (isFunction_1(onMouseMove)) {
            onMouseMove(nextState, e);
          }
        };

        _this.handleItemMouseEnter = function (el) {
          _this.setState(function () {
            return {
              isTooltipActive: true,
              activeItem: el,
              activePayload: el.tooltipPayload,
              activeCoordinate: el.tooltipPosition || {
                x: el.cx,
                y: el.cy
              }
            };
          });
        };

        _this.handleItemMouseLeave = function () {
          _this.setState(function () {
            return {
              isTooltipActive: false
            };
          });
        };

        _this.handleMouseMove = function (e) {
          if (e && isFunction_1(e.persist)) {
            e.persist();
          }

          _this.triggeredAfterMouseMove(e);
        };

        _this.handleMouseLeave = function (e) {
          var onMouseLeave = _this.props.onMouseLeave;
          var nextState = {
            isTooltipActive: false
          };

          _this.setState(nextState);

          _this.triggerSyncEvent(nextState);

          if (isFunction_1(onMouseLeave)) {
            onMouseLeave(nextState, e);
          }
        };

        _this.handleOuterEvent = function (e) {
          var eventName = getReactEventByType(e);

          if (eventName && isFunction_1(_this.props[eventName])) {
            var mouse = _this.getMouseInfo(e);

            var handler = _this.props[eventName];
            handler(mouse, e);
          }
        };

        _this.handleClick = function (e) {
          var onClick = _this.props.onClick;

          if (isFunction_1(onClick)) {
            var mouse = _this.getMouseInfo(e);

            onClick(mouse, e);
          }
        };

        _this.handleMouseDown = function (e) {
          var onMouseDown = _this.props.onMouseDown;

          if (isFunction_1(onMouseDown)) {
            var mouse = _this.getMouseInfo(e);

            onMouseDown(mouse, e);
          }
        };

        _this.handleMouseUp = function (e) {
          var onMouseUp = _this.props.onMouseUp;

          if (isFunction_1(onMouseUp)) {
            var mouse = _this.getMouseInfo(e);

            onMouseUp(mouse, e);
          }
        };

        _this.handleTouchMove = function (e) {
          if (e.changedTouches != null && e.changedTouches.length > 0) {
            _this.handleMouseMove(e.changedTouches[0]);
          }
        };

        _this.handleTouchStart = function (e) {
          if (e.changedTouches != null && e.changedTouches.length > 0) {
            _this.handleMouseDown(e.changedTouches[0]);
          }
        };

        _this.handleTouchEnd = function (e) {
          if (e.changedTouches != null && e.changedTouches.length > 0) {
            _this.handleMouseUp(e.changedTouches[0]);
          }
        };

        _this.verticalCoordinatesGenerator = function (_ref3) {
          var xAxis = _ref3.xAxis,
              width = _ref3.width,
              height = _ref3.height,
              offset = _ref3.offset;
          return getCoordinatesOfGrid(CartesianAxis.getTicks(_objectSpread({}, CartesianAxis.defaultProps, {}, xAxis, {
            ticks: getTicksOfAxis(xAxis, true),
            viewBox: {
              x: 0,
              y: 0,
              width: width,
              height: height
            }
          })), offset.left, offset.left + offset.width);
        };

        _this.horizontalCoordinatesGenerator = function (_ref4) {
          var yAxis = _ref4.yAxis,
              width = _ref4.width,
              height = _ref4.height,
              offset = _ref4.offset;
          return getCoordinatesOfGrid(CartesianAxis.getTicks(_objectSpread({}, CartesianAxis.defaultProps, {}, yAxis, {
            ticks: getTicksOfAxis(yAxis, true),
            viewBox: {
              x: 0,
              y: 0,
              width: width,
              height: height
            }
          })), offset.top, offset.top + offset.height);
        };

        _this.axesTicksGenerator = function (axis) {
          return getTicksOfAxis(axis, true);
        };

        _this.tooltipTicksGenerator = function (axisMap) {
          var axis = getAnyElementOfObject(axisMap);
          var tooltipTicks = getTicksOfAxis(axis, false, true);
          return {
            tooltipTicks: tooltipTicks,
            orderedTooltipTicks: sortBy_1(tooltipTicks, function (o) {
              return o.coordinate;
            }),
            tooltipAxis: axis,
            tooltipAxisBandSize: getBandSizeOfAxis(axis)
          };
        };

        _this.renderCursor = function (element) {
          var _this$state3 = _this.state,
              isTooltipActive = _this$state3.isTooltipActive,
              activeCoordinate = _this$state3.activeCoordinate,
              activePayload = _this$state3.activePayload,
              offset = _this$state3.offset;

          if (!element || !element.props.cursor || !isTooltipActive || !activeCoordinate) {
            return null;
          }

          var layout = _this.props.layout;
          var restProps;
          var cursorComp = Curve;

          if (chartName === 'ScatterChart') {
            restProps = activeCoordinate;
            cursorComp = Cross;
          } else if (chartName === 'BarChart') {
            restProps = _this.getCursorRectangle();
            cursorComp = Rectangle;
          } else if (layout === 'radial') {
            var _this$getCursorPoints = _this.getCursorPoints(),
                cx = _this$getCursorPoints.cx,
                cy = _this$getCursorPoints.cy,
                radius = _this$getCursorPoints.radius,
                startAngle = _this$getCursorPoints.startAngle,
                endAngle = _this$getCursorPoints.endAngle;

            restProps = {
              cx: cx,
              cy: cy,
              startAngle: startAngle,
              endAngle: endAngle,
              innerRadius: radius,
              outerRadius: radius
            };
            cursorComp = Sector;
          } else {
            restProps = {
              points: _this.getCursorPoints()
            };
            cursorComp = Curve;
          }

          var key = element.key || '_recharts-cursor';

          var cursorProps = _objectSpread({
            stroke: '#ccc',
            pointerEvents: 'none'
          }, offset, {}, restProps, {}, getPresentationAttributes(element.props.cursor), {
            payload: activePayload,
            key: key,
            className: 'recharts-tooltip-cursor'
          });

          return React.isValidElement(element.props.cursor) ? React.cloneElement(element.props.cursor, cursorProps) : React.createElement(cursorComp, cursorProps);
        };

        _this.renderPolarAxis = function (element, displayName, index) {
          var axisType = element.type.axisType;

          var axisMap = _this.state["".concat(axisType, "Map")];

          var axisOption = axisMap[element.props["".concat(axisType, "Id")]];
          return React.cloneElement(element, _objectSpread({}, axisOption, {
            className: axisType,
            key: element.key || "".concat(displayName, "-").concat(index),
            ticks: getTicksOfAxis(axisOption, true)
          }));
        };

        _this.renderXAxis = function (element, displayName, index) {
          var xAxisMap = _this.state.xAxisMap;
          var axisObj = xAxisMap[element.props.xAxisId];
          return _this.renderAxis(axisObj, element, displayName, index);
        };

        _this.renderYAxis = function (element, displayName, index) {
          var yAxisMap = _this.state.yAxisMap;
          var axisObj = yAxisMap[element.props.yAxisId];
          return _this.renderAxis(axisObj, element, displayName, index);
        };

        _this.renderGrid = function (element) {
          var _this$state4 = _this.state,
              xAxisMap = _this$state4.xAxisMap,
              yAxisMap = _this$state4.yAxisMap,
              offset = _this$state4.offset;
          var _this$props2 = _this.props,
              width = _this$props2.width,
              height = _this$props2.height;
          var xAxis = getAnyElementOfObject(xAxisMap);

          var yAxisWithFiniteDomain = find_1(yAxisMap, function (axis) {
            return every_1(axis.domain, Number.isFinite);
          });

          var yAxis = yAxisWithFiniteDomain || getAnyElementOfObject(yAxisMap);
          var props = element.props || {};
          return React.cloneElement(element, {
            key: element.key || 'grid',
            x: isNumber(props.x) ? props.x : offset.left,
            y: isNumber(props.y) ? props.y : offset.top,
            width: isNumber(props.width) ? props.width : offset.width,
            height: isNumber(props.height) ? props.height : offset.height,
            xAxis: xAxis,
            yAxis: yAxis,
            offset: offset,
            chartWidth: width,
            chartHeight: height,
            verticalCoordinatesGenerator: props.verticalCoordinatesGenerator || _this.verticalCoordinatesGenerator,
            horizontalCoordinatesGenerator: props.horizontalCoordinatesGenerator || _this.horizontalCoordinatesGenerator
          });
        };

        _this.renderPolarGrid = function (element) {
          var _this$state5 = _this.state,
              radiusAxisMap = _this$state5.radiusAxisMap,
              angleAxisMap = _this$state5.angleAxisMap;
          var radiusAxis = getAnyElementOfObject(radiusAxisMap);
          var angleAxis = getAnyElementOfObject(angleAxisMap);
          var cx = angleAxis.cx,
              cy = angleAxis.cy,
              innerRadius = angleAxis.innerRadius,
              outerRadius = angleAxis.outerRadius;
          return React.cloneElement(element, {
            polarAngles: getTicksOfAxis(angleAxis, true).map(function (entry) {
              return entry.coordinate;
            }),
            polarRadius: getTicksOfAxis(radiusAxis, true).map(function (entry) {
              return entry.coordinate;
            }),
            cx: cx,
            cy: cy,
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            key: element.key || 'polar-grid'
          });
        };

        _this.renderBrush = function (element) {
          var _this$props3 = _this.props,
              margin = _this$props3.margin,
              data = _this$props3.data;
          var _this$state6 = _this.state,
              offset = _this$state6.offset,
              dataStartIndex = _this$state6.dataStartIndex,
              dataEndIndex = _this$state6.dataEndIndex,
              updateId = _this$state6.updateId; // TODO: update brush when children update

          return React.cloneElement(element, {
            key: element.key || '_recharts-brush',
            onChange: combineEventHandlers(_this.handleBrushChange, null, element.props.onChange),
            data: data,
            x: isNumber(element.props.x) ? element.props.x : offset.left,
            y: isNumber(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),
            width: isNumber(element.props.width) ? element.props.width : offset.width,
            startIndex: dataStartIndex,
            endIndex: dataEndIndex,
            updateId: "brush-".concat(updateId)
          });
        };

        _this.renderReferenceElement = function (element, displayName, index) {
          if (!element) {
            return null;
          }

          var _assertThisInitialize = _assertThisInitialized$1(_this),
              clipPathId = _assertThisInitialize.clipPathId;

          var _this$state7 = _this.state,
              xAxisMap = _this$state7.xAxisMap,
              yAxisMap = _this$state7.yAxisMap,
              offset = _this$state7.offset;
          var _element$props = element.props,
              xAxisId = _element$props.xAxisId,
              yAxisId = _element$props.yAxisId;
          return React.cloneElement(element, {
            key: element.key || "".concat(displayName, "-").concat(index),
            xAxis: xAxisMap[xAxisId],
            yAxis: yAxisMap[yAxisId],
            viewBox: {
              x: offset.left,
              y: offset.top,
              width: offset.width,
              height: offset.height
            },
            clipPathId: clipPathId
          });
        };

        _this.renderGraphicChild = function (element, displayName, index) {
          var item = _this.filterFormatItem(element, displayName, index);

          if (!item) {
            return null;
          }

          var graphicalItem = React.cloneElement(element, item.props);
          var _this$state8 = _this.state,
              isTooltipActive = _this$state8.isTooltipActive,
              tooltipAxis = _this$state8.tooltipAxis,
              activeTooltipIndex = _this$state8.activeTooltipIndex,
              activeLabel = _this$state8.activeLabel;
          var children = _this.props.children;
          var tooltipItem = findChildByType(children, Tooltip$1);
          var _item$props = item.props,
              points = _item$props.points,
              isRange = _item$props.isRange,
              baseLine = _item$props.baseLine;
          var _item$item$props = item.item.props,
              activeDot = _item$item$props.activeDot,
              hide = _item$item$props.hide;
          var hasActive = !hide && isTooltipActive && tooltipItem && activeDot && activeTooltipIndex >= 0;

          function findWithPayload(entry) {
            return tooltipAxis.dataKey(entry.payload);
          }

          if (hasActive) {
            var activePoint, basePoint;

            if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
              var specifiedKey = typeof tooltipAxis.dataKey === 'function' ? findWithPayload : 'payload.'.concat(tooltipAxis.dataKey);
              activePoint = findEntryInArray(points, specifiedKey, activeLabel);
              basePoint = isRange && baseLine && findEntryInArray(baseLine, specifiedKey, activeLabel);
            } else {
              activePoint = points[activeTooltipIndex];
              basePoint = isRange && baseLine && baseLine[activeTooltipIndex];
            }

            if (!isNil_1(activePoint)) {
              return [graphicalItem].concat(_toConsumableArray(_this.renderActivePoints({
                item: item,
                activePoint: activePoint,
                basePoint: basePoint,
                childIndex: activeTooltipIndex,
                isRange: isRange
              })));
            }
          }

          if (isRange) {
            return [graphicalItem, null, null];
          }

          return [graphicalItem, null];
        };

        _this.renderCustomized = function (element) {
          return React.cloneElement(element, _objectSpread({}, _this.props, {}, _this.state));
        };

        var defaultState = _this.constructor.createDefaultState(_props);

        var _updateId = 0;
        _this.state = _objectSpread({}, defaultState, {
          updateId: 0
        }, _this.updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({
          props: _props
        }, defaultState, {
          updateId: _updateId
        })));
        _this.uniqueChartId = isNil_1(_props.id) ? uniqueId('recharts') : _props.id;
        _this.clipPathId = "".concat(_this.uniqueChartId, "-clip");

        if (_props.throttleDelay) {
          _this.triggeredAfterMouseMove = throttle_1(_this.triggeredAfterMouseMove, _props.throttleDelay);
        }

        return _this;
      }
      /* eslint-disable  react/no-did-mount-set-state */


      _createClass(CategoricalChartWrapper, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (!isNil_1(this.props.syncId)) {
            this.addListener();
          }
        } // eslint-disable-next-line camelcase

      }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
          var _this2 = this;

          var _this$props4 = this.props,
              data = _this$props4.data,
              children = _this$props4.children,
              width = _this$props4.width,
              height = _this$props4.height,
              layout = _this$props4.layout,
              stackOffset = _this$props4.stackOffset,
              margin = _this$props4.margin;
          var updateId = this.state.updateId;

          if (nextProps.data !== data || nextProps.width !== width || nextProps.height !== height || nextProps.layout !== layout || nextProps.stackOffset !== stackOffset || !shallowEqual(nextProps.margin, margin)) {
            var defaultState = this.constructor.createDefaultState(nextProps);
            this.setState(_objectSpread({}, defaultState, {
              updateId: updateId + 1
            }, this.updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({
              props: nextProps
            }, defaultState, {
              updateId: updateId + 1
            }))));
          } else if (!isChildrenEqual(nextProps.children, children)) {
            // update configuration in chilren
            var hasGlobalData = !isNil_1(nextProps.data);
            var newUpdateId = hasGlobalData ? updateId : updateId + 1;
            this.setState(function (prevState) {
              return _objectSpread({
                updateId: newUpdateId
              }, _this2.updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({
                props: nextProps
              }, prevState, {
                updateId: newUpdateId
              })));
            });
          } // add syncId


          if (isNil_1(this.props.syncId) && !isNil_1(nextProps.syncId)) {
            this.addListener();
          } // remove syncId


          if (!isNil_1(this.props.syncId) && isNil_1(nextProps.syncId)) {
            this.removeListener();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (!isNil_1(this.props.syncId)) {
            this.removeListener();
          }

          if (typeof this.triggeredAfterMouseMove.cancel === 'function') {
            this.triggeredAfterMouseMove.cancel();
          }
        }
        /**
        * Get the configuration of all x-axis or y-axis
        * @param  {Object} props          Latest props
        * @param  {String} axisType       The type of axis
        * @param  {Array}  graphicalItems The instances of item
        * @param  {Object} stackGroups    The items grouped by axisId and stackId
        * @param {Number} dataStartIndex  The start index of the data series when a brush is applied
        * @param {Number} dataEndIndex    The end index of the data series when a brush is applied
        * @return {Object}          Configuration
        */

      }, {
        key: "getAxisMap",
        value: function getAxisMap(props, _ref5) {
          var _ref5$axisType = _ref5.axisType,
              axisType = _ref5$axisType === void 0 ? 'xAxis' : _ref5$axisType,
              AxisComp = _ref5.AxisComp,
              graphicalItems = _ref5.graphicalItems,
              stackGroups = _ref5.stackGroups,
              dataStartIndex = _ref5.dataStartIndex,
              dataEndIndex = _ref5.dataEndIndex;
          var children = props.children;
          var axisIdKey = "".concat(axisType, "Id"); // Get all the instance of Axis

          var axes = findAllByType(children, AxisComp);
          var axisMap = {};

          if (axes && axes.length) {
            axisMap = this.getAxisMapByAxes(props, {
              axes: axes,
              graphicalItems: graphicalItems,
              axisType: axisType,
              axisIdKey: axisIdKey,
              stackGroups: stackGroups,
              dataStartIndex: dataStartIndex,
              dataEndIndex: dataEndIndex
            });
          } else if (graphicalItems && graphicalItems.length) {
            axisMap = this.getAxisMapByItems(props, {
              Axis: AxisComp,
              graphicalItems: graphicalItems,
              axisType: axisType,
              axisIdKey: axisIdKey,
              stackGroups: stackGroups,
              dataStartIndex: dataStartIndex,
              dataEndIndex: dataEndIndex
            });
          }

          return axisMap;
        }
        /**
         * Get the configuration of axis by the options of axis instance
         * @param  {Object} props         Latest props
         * @param {Array}  axes           The instance of axes
         * @param  {Array} graphicalItems The instances of item
         * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis
         * @param  {String} axisIdKey     The unique id of an axis
         * @param  {Object} stackGroups   The items grouped by axisId and stackId
         * @param {Number} dataStartIndex The start index of the data series when a brush is applied
         * @param {Number} dataEndIndex   The end index of the data series when a brush is applied
         * @return {Object}      Configuration
         */

      }, {
        key: "getAxisMapByAxes",
        value: function getAxisMapByAxes(props, _ref6) {
          var _this3 = this;

          var axes = _ref6.axes,
              graphicalItems = _ref6.graphicalItems,
              axisType = _ref6.axisType,
              axisIdKey = _ref6.axisIdKey,
              stackGroups = _ref6.stackGroups,
              dataStartIndex = _ref6.dataStartIndex,
              dataEndIndex = _ref6.dataEndIndex;
          var layout = props.layout,
              children = props.children,
              stackOffset = props.stackOffset;
          var isCategorial = isCategorialAxis(layout, axisType); // Eliminate duplicated axes

          var axisMap = axes.reduce(function (result, child) {
            var _child$props = child.props,
                type = _child$props.type,
                dataKey = _child$props.dataKey,
                allowDataOverflow = _child$props.allowDataOverflow,
                allowDuplicatedCategory = _child$props.allowDuplicatedCategory,
                scale = _child$props.scale,
                ticks = _child$props.ticks;
            var axisId = child.props[axisIdKey];

            var displayedData = _this3.constructor.getDisplayedData(props, {
              graphicalItems: graphicalItems.filter(function (item) {
                return item.props[axisIdKey] === axisId;
              }),
              dataStartIndex: dataStartIndex,
              dataEndIndex: dataEndIndex
            });

            var len = displayedData.length;

            if (!result[axisId]) {
              var domain, duplicateDomain, categoricalDomain;

              if (dataKey) {
                domain = getDomainOfDataByKey(displayedData, dataKey, type);

                if (type === 'category' && isCategorial) {
                  var duplicate = hasDuplicate(domain);

                  if (allowDuplicatedCategory && duplicate) {
                    duplicateDomain = domain; // When category axis has duplicated text, serial numbers are used to generate scale

                    domain = range_1(0, len);
                  } else if (!allowDuplicatedCategory) {
                    // remove duplicated category
                    domain = parseDomainOfCategoryAxis(child.props.domain, domain, child).reduce(function (finalDomain, entry) {
                      return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
                    }, []);
                  }
                } else if (type === 'category') {
                  if (!allowDuplicatedCategory) {
                    domain = parseDomainOfCategoryAxis(child.props.domain, domain, child).reduce(function (finalDomain, entry) {
                      return finalDomain.indexOf(entry) >= 0 || entry === '' || isNil_1(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
                    }, []);
                  } else {
                    // eliminate undefined or null or empty string
                    domain = domain.filter(function (entry) {
                      return entry !== '' && !isNil_1(entry);
                    });
                  }
                } else if (type === 'number') {
                  var errorBarsDomain = parseErrorBarsOfAxis(displayedData, graphicalItems.filter(function (item) {
                    return item.props[axisIdKey] === axisId && !item.props.hide;
                  }), dataKey, axisType);

                  if (errorBarsDomain) {
                    domain = errorBarsDomain;
                  }
                }

                if (isCategorial && (type === 'number' || scale !== 'auto')) {
                  categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, 'category');
                }
              } else if (isCategorial) {
                domain = range_1(0, len);
              } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === 'number') {
                // when stackOffset is 'expand', the domain may be calculated as [0, 1.000000000002]
                domain = stackOffset === 'expand' ? [0, 1] : getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
              } else {
                domain = getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function (item) {
                  return item.props[axisIdKey] === axisId && !item.props.hide;
                }), type, true);
              }

              if (type === 'number') {
                // To detect wether there is any reference lines whose props alwaysShow is true
                domain = detectReferenceElementsDomain(children, domain, axisId, axisType, ticks);

                if (child.props.domain) {
                  domain = parseSpecifiedDomain(child.props.domain, domain, allowDataOverflow);
                }
              }

              return _objectSpread({}, result, _defineProperty$1({}, axisId, _objectSpread({}, child.props, {
                axisType: axisType,
                domain: domain,
                categoricalDomain: categoricalDomain,
                duplicateDomain: duplicateDomain,
                originalDomain: child.props.domain,
                isCategorial: isCategorial,
                layout: layout
              })));
            }

            return result;
          }, {});
          return axisMap;
        }
        /**
         * Get the configuration of axis by the options of item,
         * this kind of axis does not display in chart
         * @param  {Object} props         Latest props
         * @param  {Array} graphicalItems The instances of item
         * @param  {ReactElement} Axis    Axis Component
         * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis
         * @param  {String} axisIdKey     The unique id of an axis
         * @param  {Object} stackGroups   The items grouped by axisId and stackId
         * @param {Number} dataStartIndex The start index of the data series when a brush is applied
         * @param {Number} dataEndIndex   The end index of the data series when a brush is applied
         * @return {Object}               Configuration
         */

      }, {
        key: "getAxisMapByItems",
        value: function getAxisMapByItems(props, _ref7) {
          var graphicalItems = _ref7.graphicalItems,
              Axis = _ref7.Axis,
              axisType = _ref7.axisType,
              axisIdKey = _ref7.axisIdKey,
              stackGroups = _ref7.stackGroups,
              dataStartIndex = _ref7.dataStartIndex,
              dataEndIndex = _ref7.dataEndIndex;
          var layout = props.layout,
              children = props.children;
          var displayedData = this.constructor.getDisplayedData(props, {
            graphicalItems: graphicalItems,
            dataStartIndex: dataStartIndex,
            dataEndIndex: dataEndIndex
          });
          var len = displayedData.length;
          var isCategorial = isCategorialAxis(layout, axisType);
          var index = -1; // The default type of x-axis is category axis,
          // The default contents of x-axis is the serial numbers of data
          // The default type of y-axis is number axis
          // The default contents of y-axis is the domain of data

          var axisMap = graphicalItems.reduce(function (result, child) {
            var axisId = child.props[axisIdKey];

            if (!result[axisId]) {
              index++;
              var domain;

              if (isCategorial) {
                domain = range_1(0, len);
              } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {
                domain = getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
                domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
              } else {
                domain = parseSpecifiedDomain(Axis.defaultProps.domain, getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function (item) {
                  return item.props[axisIdKey] === axisId && !item.props.hide;
                }), 'number'), Axis.defaultProps.allowDataOverflow);
                domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
              }

              return _objectSpread({}, result, _defineProperty$1({}, axisId, _objectSpread({
                axisType: axisType
              }, Axis.defaultProps, {
                hide: true,
                orientation: ORIENT_MAP[axisType] && ORIENT_MAP[axisType][index % 2],
                domain: domain,
                originalDomain: Axis.defaultProps.domain,
                isCategorial: isCategorial,
                layout: layout // specify scale when no Axis
                // scale: isCategorial ? 'band' : 'linear',

              })));
            }

            return result;
          }, {});
          return axisMap;
        }
      }, {
        key: "getActiveCoordinate",
        value: function getActiveCoordinate(tooltipTicks, activeIndex, rangeObj) {
          var layout = this.props.layout;
          var entry = tooltipTicks.find(function (tick) {
            return tick && tick.index === activeIndex;
          });

          if (entry) {
            if (layout === 'horizontal') {
              return {
                x: entry.coordinate,
                y: rangeObj.y
              };
            }

            if (layout === 'vertical') {
              return {
                x: rangeObj.x,
                y: entry.coordinate
              };
            }

            if (layout === 'centric') {
              var _angle = entry.coordinate;
              var _radius = rangeObj.radius;
              return _objectSpread({}, rangeObj, {}, polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle), {
                angle: _angle,
                radius: _radius
              });
            }

            var radius = entry.coordinate;
            var angle = rangeObj.angle;
            return _objectSpread({}, rangeObj, {}, polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle), {
              angle: angle,
              radius: radius
            });
          }

          return originCoordinate;
        }
        /**
         * Get the information of mouse in chart, return null when the mouse is not in the chart
         * @param  {Object} event    The event object
         * @return {Object}          Mouse data
         */

      }, {
        key: "getMouseInfo",
        value: function getMouseInfo(event) {
          if (!this.container) {
            return null;
          }

          var containerOffset = getOffset(this.container);
          var e = calculateChartCoordinate(event, containerOffset);
          var rangeObj = this.inRange(e.chartX, e.chartY);

          if (!rangeObj) {
            return null;
          }

          var _this$state9 = this.state,
              xAxisMap = _this$state9.xAxisMap,
              yAxisMap = _this$state9.yAxisMap;

          if (eventType !== 'axis' && xAxisMap && yAxisMap) {
            var xScale = getAnyElementOfObject(xAxisMap).scale;
            var yScale = getAnyElementOfObject(yAxisMap).scale;
            var xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null;
            var yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;
            return _objectSpread({}, e, {
              xValue: xValue,
              yValue: yValue
            });
          }

          var _this$state10 = this.state,
              ticks = _this$state10.orderedTooltipTicks,
              axis = _this$state10.tooltipAxis,
              tooltipTicks = _this$state10.tooltipTicks;
          var pos = this.calculateTooltipPos(rangeObj);
          var activeIndex = calculateActiveTickIndex(pos, ticks, tooltipTicks, axis);

          if (activeIndex >= 0 && tooltipTicks) {
            var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;
            var activePayload = this.getTooltipContent(activeIndex, activeLabel);
            var activeCoordinate = this.getActiveCoordinate(ticks, activeIndex, rangeObj);
            return _objectSpread({}, e, {
              activeTooltipIndex: activeIndex,
              activeLabel: activeLabel,
              activePayload: activePayload,
              activeCoordinate: activeCoordinate
            });
          }

          return null;
        }
        /**
         * Get the content to be displayed in the tooltip
         * @param  {Number} activeIndex    Active index of data
         * @param  {String} activeLabel    Active label of data
         * @return {Array}                 The content of tooltip
         */

      }, {
        key: "getTooltipContent",
        value: function getTooltipContent(activeIndex, activeLabel) {
          var _this$state11 = this.state,
              graphicalItems = _this$state11.graphicalItems,
              tooltipAxis = _this$state11.tooltipAxis;
          var displayedData = this.constructor.getDisplayedData(this.props, this.state);

          if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) {
            return null;
          } // get data by activeIndex when the axis don't allow duplicated category


          return graphicalItems.reduce(function (result, child) {
            var hide = child.props.hide;

            if (hide) {
              return result;
            }

            var _child$props2 = child.props,
                dataKey = _child$props2.dataKey,
                name = _child$props2.name,
                unit = _child$props2.unit,
                formatter = _child$props2.formatter,
                data = _child$props2.data,
                tooltipType = _child$props2.tooltipType;
            var payload;

            if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
              // graphic child has data props
              payload = findEntryInArray(data || displayedData, tooltipAxis.dataKey, activeLabel);
            } else {
              payload = data && data[activeIndex] || displayedData[activeIndex];
            }

            if (!payload) {
              return result;
            }

            return [].concat(_toConsumableArray(result), [_objectSpread({}, getPresentationAttributes(child), {
              dataKey: dataKey,
              unit: unit,
              formatter: formatter,
              name: name || dataKey,
              color: getMainColorOfGraphicItem(child),
              value: getValueByDataKey(payload, dataKey),
              type: tooltipType,
              payload: payload
            })]);
          }, []);
        }
      }, {
        key: "getFormatItems",
        value: function getFormatItems(props, currentState) {
          var _this4 = this;

          var graphicalItems = currentState.graphicalItems,
              stackGroups = currentState.stackGroups,
              offset = currentState.offset,
              updateId = currentState.updateId,
              dataStartIndex = currentState.dataStartIndex,
              dataEndIndex = currentState.dataEndIndex;
          var barSize = props.barSize,
              layout = props.layout,
              barGap = props.barGap,
              barCategoryGap = props.barCategoryGap,
              globalMaxBarSize = props.maxBarSize;

          var _this$constructor$get = this.constructor.getAxisNameByLayout(layout),
              numericAxisName = _this$constructor$get.numericAxisName,
              cateAxisName = _this$constructor$get.cateAxisName;

          var hasBar = this.constructor.hasBar(graphicalItems);
          var sizeList = hasBar && getBarSizeList({
            barSize: barSize,
            stackGroups: stackGroups
          });
          var formatedItems = [];
          graphicalItems.forEach(function (item, index) {
            var displayedData = _this4.constructor.getDisplayedData(props, {
              dataStartIndex: dataStartIndex,
              dataEndIndex: dataEndIndex
            }, item);

            var _item$props2 = item.props,
                dataKey = _item$props2.dataKey,
                childMaxBarSize = _item$props2.maxBarSize;
            var numericAxisId = item.props["".concat(numericAxisName, "Id")];
            var cateAxisId = item.props["".concat(cateAxisName, "Id")];
            var axisObj = axisComponents.reduce(function (result, entry) {
              var _objectSpread4;

              var axisMap = currentState["".concat(entry.axisType, "Map")];
              var id = item.props["".concat(entry.axisType, "Id")];
              var axis = axisMap && axisMap[id];
              return _objectSpread({}, result, (_objectSpread4 = {}, _defineProperty$1(_objectSpread4, entry.axisType, axis), _defineProperty$1(_objectSpread4, "".concat(entry.axisType, "Ticks"), getTicksOfAxis(axis)), _objectSpread4));
            }, {});
            var cateAxis = axisObj[cateAxisName];
            var cateTicks = axisObj["".concat(cateAxisName, "Ticks")];
            var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);
            var bandSize = getBandSizeOfAxis(cateAxis, cateTicks);
            var maxBarSize = isNil_1(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
            var barPosition = hasBar && getBarPosition({
              barGap: barGap,
              barCategoryGap: barCategoryGap,
              bandSize: bandSize,
              sizeList: sizeList[cateAxisId],
              maxBarSize: maxBarSize
            });
            var componsedFn = item && item.type && item.type.getComposedData;

            if (componsedFn) {
              var _objectSpread5;

              formatedItems.push({
                props: _objectSpread({}, componsedFn(_objectSpread({}, axisObj, {
                  displayedData: displayedData,
                  props: props,
                  dataKey: dataKey,
                  item: item,
                  bandSize: bandSize,
                  barPosition: barPosition,
                  offset: offset,
                  stackedData: stackedData,
                  layout: layout,
                  dataStartIndex: dataStartIndex,
                  dataEndIndex: dataEndIndex,
                  onItemMouseLeave: combineEventHandlers(_this4.handleItemMouseLeave, null, item.props.onMouseLeave),
                  onItemMouseEnter: combineEventHandlers(_this4.handleItemMouseEnter, null, item.props.onMouseEnter)
                })), (_objectSpread5 = {
                  key: item.key || "item-".concat(index)
                }, _defineProperty$1(_objectSpread5, numericAxisName, axisObj[numericAxisName]), _defineProperty$1(_objectSpread5, cateAxisName, axisObj[cateAxisName]), _defineProperty$1(_objectSpread5, "animationId", updateId), _objectSpread5)),
                childIndex: parseChildIndex(item, props.children),
                item: item
              });
            }
          });
          return formatedItems;
        }
      }, {
        key: "getCursorRectangle",
        value: function getCursorRectangle() {
          var layout = this.props.layout;
          var _this$state12 = this.state,
              activeCoordinate = _this$state12.activeCoordinate,
              offset = _this$state12.offset,
              tooltipAxisBandSize = _this$state12.tooltipAxisBandSize;
          var halfSize = tooltipAxisBandSize / 2;
          return {
            stroke: 'none',
            fill: '#ccc',
            x: layout === 'horizontal' ? activeCoordinate.x - halfSize : offset.left + 0.5,
            y: layout === 'horizontal' ? offset.top + 0.5 : activeCoordinate.y - halfSize,
            width: layout === 'horizontal' ? tooltipAxisBandSize : offset.width - 1,
            height: layout === 'horizontal' ? offset.height - 1 : tooltipAxisBandSize
          };
        }
      }, {
        key: "getCursorPoints",
        value: function getCursorPoints() {
          var layout = this.props.layout;
          var _this$state13 = this.state,
              activeCoordinate = _this$state13.activeCoordinate,
              offset = _this$state13.offset;
          var x1, y1, x2, y2;

          if (layout === 'horizontal') {
            x1 = activeCoordinate.x;
            x2 = x1;
            y1 = offset.top;
            y2 = offset.top + offset.height;
          } else if (layout === 'vertical') {
            y1 = activeCoordinate.y;
            y2 = y1;
            x1 = offset.left;
            x2 = offset.left + offset.width;
          } else if (!isNil_1(activeCoordinate.cx) || !isNil_1(activeCoordinate.cy)) {
            if (layout === 'centric') {
              var cx = activeCoordinate.cx,
                  cy = activeCoordinate.cy,
                  innerRadius = activeCoordinate.innerRadius,
                  outerRadius = activeCoordinate.outerRadius,
                  angle = activeCoordinate.angle;
              var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
              var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
              x1 = innerPoint.x;
              y1 = innerPoint.y;
              x2 = outerPoint.x;
              y2 = outerPoint.y;
            } else {
              var _cx = activeCoordinate.cx,
                  _cy = activeCoordinate.cy,
                  radius = activeCoordinate.radius,
                  startAngle = activeCoordinate.startAngle,
                  endAngle = activeCoordinate.endAngle;
              var startPoint = polarToCartesian(_cx, _cy, radius, startAngle);
              var endPoint = polarToCartesian(_cx, _cy, radius, endAngle);
              return {
                points: [startPoint, endPoint],
                cx: _cx,
                cy: _cy,
                radius: radius,
                startAngle: startAngle,
                endAngle: endAngle
              };
            }
          }

          return [{
            x: x1,
            y: y1
          }, {
            x: x2,
            y: y2
          }];
        }
      }, {
        key: "calculateTooltipPos",
        value: function calculateTooltipPos(rangeObj) {
          var layout = this.props.layout;

          if (layout === 'horizontal') {
            return rangeObj.x;
          }

          if (layout === 'vertical') {
            return rangeObj.y;
          }

          if (layout === 'centric') {
            return rangeObj.angle;
          }

          return rangeObj.radius;
        }
      }, {
        key: "inRange",
        value: function inRange(x, y) {
          var layout = this.props.layout;

          if (layout === 'horizontal' || layout === 'vertical') {
            var offset = this.state.offset;
            var isInRange = x >= offset.left && x <= offset.left + offset.width && y >= offset.top && y <= offset.top + offset.height;
            return isInRange ? {
              x: x,
              y: y
            } : null;
          }

          var _this$state14 = this.state,
              angleAxisMap = _this$state14.angleAxisMap,
              radiusAxisMap = _this$state14.radiusAxisMap;

          if (angleAxisMap && radiusAxisMap) {
            var angleAxis = getAnyElementOfObject(angleAxisMap);
            return inRangeOfSector({
              x: x,
              y: y
            }, angleAxis);
          }

          return null;
        }
      }, {
        key: "parseEventsOfWrapper",
        value: function parseEventsOfWrapper() {
          var children = this.props.children;
          var tooltipItem = findChildByType(children, Tooltip$1);
          var tooltipEvents = tooltipItem && eventType === 'axis' ? {
            onMouseEnter: this.handleMouseEnter,
            onMouseMove: this.handleMouseMove,
            onMouseLeave: this.handleMouseLeave,
            onTouchMove: this.handleTouchMove,
            onTouchStart: this.handleTouchStart,
            onTouchEnd: this.handleTouchEnd
          } : {};
          var outerEvents = filterEventAttributes(this.props, this.handleOuterEvent);
          return _objectSpread({}, outerEvents, {}, tooltipEvents);
        }
        /**
         * The AxisMaps are expensive to render on large data sets
         * so provide the ability to store them in state and only update them when necessary
         * they are dependent upon the start and end index of
         * the brush so it's important that this method is called _after_
         * the state is updated with any new start/end indices
         *
         * @param {Object} props          The props object to be used for updating the axismaps
         * @param {Number} dataStartIndex The start index of the data series when a brush is applied
         * @param {Number} dataEndIndex   The end index of the data series when a brush is applied
         * @param {Number} updateId       The update id
         * @return {Object} state New state to set
         */

      }, {
        key: "updateStateOfAxisMapsOffsetAndStackGroups",
        value: function updateStateOfAxisMapsOffsetAndStackGroups(_ref8) {
          var _this5 = this;

          var props = _ref8.props,
              dataStartIndex = _ref8.dataStartIndex,
              dataEndIndex = _ref8.dataEndIndex,
              updateId = _ref8.updateId;

          if (!validateWidthHeight({
            props: props
          })) {
            return null;
          }

          var children = props.children,
              layout = props.layout,
              stackOffset = props.stackOffset,
              data = props.data,
              reverseStackOrder = props.reverseStackOrder;

          var _this$constructor$get2 = this.constructor.getAxisNameByLayout(layout),
              numericAxisName = _this$constructor$get2.numericAxisName,
              cateAxisName = _this$constructor$get2.cateAxisName;

          var graphicalItems = findAllByType(children, GraphicalChild);
          var stackGroups = getStackGroupsByAxisId(data, graphicalItems, "".concat(numericAxisName, "Id"), "".concat(cateAxisName, "Id"), stackOffset, reverseStackOrder);
          var axisObj = axisComponents.reduce(function (result, entry) {
            var name = "".concat(entry.axisType, "Map");
            return _objectSpread({}, result, _defineProperty$1({}, name, _this5.getAxisMap(props, _objectSpread({}, entry, {
              graphicalItems: graphicalItems,
              stackGroups: entry.axisType === numericAxisName && stackGroups,
              dataStartIndex: dataStartIndex,
              dataEndIndex: dataEndIndex
            }))));
          }, {});
          var offset = this.calculateOffset(_objectSpread({}, axisObj, {
            props: props,
            graphicalItems: graphicalItems
          }));
          Object.keys(axisObj).forEach(function (key) {
            axisObj[key] = formatAxisMap(props, axisObj[key], offset, key.replace('Map', ''), chartName);
          });
          var cateAxisMap = axisObj["".concat(cateAxisName, "Map")];
          var ticksObj = this.tooltipTicksGenerator(cateAxisMap);
          var formatedGraphicalItems = this.getFormatItems(props, _objectSpread({}, axisObj, {
            dataStartIndex: dataStartIndex,
            dataEndIndex: dataEndIndex,
            updateId: updateId,
            graphicalItems: graphicalItems,
            stackGroups: stackGroups,
            offset: offset
          }));
          return _objectSpread({
            formatedGraphicalItems: formatedGraphicalItems,
            graphicalItems: graphicalItems,
            offset: offset,
            stackGroups: stackGroups
          }, ticksObj, {}, axisObj);
        }
        /* eslint-disable  no-underscore-dangle */

      }, {
        key: "addListener",
        value: function addListener() {
          eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);

          if (eventCenter.setMaxListeners && eventCenter._maxListeners) {
            eventCenter.setMaxListeners(eventCenter._maxListeners + 1);
          }
        }
      }, {
        key: "removeListener",
        value: function removeListener() {
          eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);

          if (eventCenter.setMaxListeners && eventCenter._maxListeners) {
            eventCenter.setMaxListeners(eventCenter._maxListeners - 1);
          }
        }
        /**
         * Calculate the offset of main part in the svg element
         * @param  {Object} props          Latest props
         * @param  {Array}  graphicalItems The instances of item
         * @param  {Object} xAxisMap       The configuration of x-axis
         * @param  {Object} yAxisMap       The configuration of y-axis
         * @return {Object} The offset of main part in the svg element
         */

      }, {
        key: "calculateOffset",
        value: function calculateOffset(_ref9) {
          var props = _ref9.props,
              graphicalItems = _ref9.graphicalItems,
              _ref9$xAxisMap = _ref9.xAxisMap,
              xAxisMap = _ref9$xAxisMap === void 0 ? {} : _ref9$xAxisMap,
              _ref9$yAxisMap = _ref9.yAxisMap,
              yAxisMap = _ref9$yAxisMap === void 0 ? {} : _ref9$yAxisMap;
          var width = props.width,
              height = props.height,
              children = props.children;
          var margin = props.margin || {};
          var brushItem = findChildByType(children, Brush);
          var legendItem = findChildByType(children, Legend$1);
          var offsetH = Object.keys(yAxisMap).reduce(function (result, id) {
            var entry = yAxisMap[id];
            var orientation = entry.orientation;

            if (!entry.mirror && !entry.hide) {
              return _objectSpread({}, result, _defineProperty$1({}, orientation, result[orientation] + entry.width));
            }

            return result;
          }, {
            left: margin.left || 0,
            right: margin.right || 0
          });
          var offsetV = Object.keys(xAxisMap).reduce(function (result, id) {
            var entry = xAxisMap[id];
            var orientation = entry.orientation;

            if (!entry.mirror && !entry.hide) {
              return _objectSpread({}, result, _defineProperty$1({}, orientation, result[orientation] + entry.height));
            }

            return result;
          }, {
            top: margin.top || 0,
            bottom: margin.bottom || 0
          });

          var offset = _objectSpread({}, offsetV, {}, offsetH);

          var brushBottom = offset.bottom;

          if (brushItem) {
            offset.bottom += brushItem.props.height || Brush.defaultProps.height;
          }

          if (legendItem && this.legendInstance) {
            var legendBox = this.legendInstance.getBBox();
            offset = appendOffsetOfLegend(offset, graphicalItems, props, legendBox);
          }

          return _objectSpread({
            brushBottom: brushBottom
          }, offset, {
            width: width - offset.left - offset.right,
            height: height - offset.top - offset.bottom
          });
        }
      }, {
        key: "triggerSyncEvent",
        value: function triggerSyncEvent(data) {
          var syncId = this.props.syncId;

          if (!isNil_1(syncId)) {
            eventCenter.emit(SYNC_EVENT, syncId, this.uniqueChartId, data);
          }
        }
      }, {
        key: "filterFormatItem",
        value: function filterFormatItem(item, displayName, childIndex) {
          var formatedGraphicalItems = this.state.formatedGraphicalItems;

          for (var i = 0, len = formatedGraphicalItems.length; i < len; i++) {
            var entry = formatedGraphicalItems[i];

            if (entry.item === item || entry.props.key === item.key || displayName === getDisplayName(entry.item.type) && childIndex === entry.childIndex) {
              return entry;
            }
          }

          return null;
        }
      }, {
        key: "renderAxis",

        /**
         * Draw axis
         * @param {Object} axisOptions The options of axis
         * @param {Object} element      The axis element
         * @param {String} displayName  The display name of axis
         * @param {Number} index        The index of element
         * @return {ReactElement}       The instance of x-axes
         */
        value: function renderAxis(axisOptions, element, displayName, index) {
          var _this$props5 = this.props,
              width = _this$props5.width,
              height = _this$props5.height;
          return React__default['default'].createElement(CartesianAxis, _extends$2({}, axisOptions, {
            className: "recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType),
            key: element.key || "".concat(displayName, "-").concat(index),
            viewBox: {
              x: 0,
              y: 0,
              width: width,
              height: height
            },
            ticksGenerator: this.axesTicksGenerator
          }));
        }
        /**
         * Draw grid
         * @param  {ReactElement} element the grid item
         * @return {ReactElement} The instance of grid
         */

      }, {
        key: "renderLegend",

        /**
         * Draw legend
         * @return {ReactElement}            The instance of Legend
         */
        value: function renderLegend() {
          var _this6 = this;

          var formatedGraphicalItems = this.state.formatedGraphicalItems;
          var _this$props6 = this.props,
              children = _this$props6.children,
              width = _this$props6.width,
              height = _this$props6.height;
          var margin = this.props.margin || {};
          var legendWidth = width - (margin.left || 0) - (margin.right || 0);
          var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);
          var props = getLegendProps({
            children: children,
            formatedGraphicalItems: formatedGraphicalItems,
            legendWidth: legendWidth,
            legendHeight: legendHeight,
            legendContent: legendContent
          });

          if (!props) {
            return null;
          }

          var item = props.item,
              otherProps = _objectWithoutProperties(props, ["item"]);

          return React.cloneElement(item, _objectSpread({}, otherProps, {
            chartWidth: width,
            chartHeight: height,
            margin: margin,
            ref: function ref(legend) {
              _this6.legendInstance = legend;
            },
            onBBoxUpdate: this.handleLegendBBoxUpdate
          }));
        }
        /**
         * Draw Tooltip
         * @return {ReactElement}  The instance of Tooltip
         */

      }, {
        key: "renderTooltip",
        value: function renderTooltip() {
          var children = this.props.children;
          var tooltipItem = findChildByType(children, Tooltip$1);

          if (!tooltipItem) {
            return null;
          }

          var _this$state15 = this.state,
              isTooltipActive = _this$state15.isTooltipActive,
              activeCoordinate = _this$state15.activeCoordinate,
              activePayload = _this$state15.activePayload,
              activeLabel = _this$state15.activeLabel,
              offset = _this$state15.offset;
          return React.cloneElement(tooltipItem, {
            viewBox: _objectSpread({}, offset, {
              x: offset.left,
              y: offset.top
            }),
            active: isTooltipActive,
            label: activeLabel,
            payload: isTooltipActive ? activePayload : [],
            coordinate: activeCoordinate
          });
        }
      }, {
        key: "renderActivePoints",
        value: function renderActivePoints(_ref10) {
          var item = _ref10.item,
              activePoint = _ref10.activePoint,
              basePoint = _ref10.basePoint,
              childIndex = _ref10.childIndex,
              isRange = _ref10.isRange;
          var result = [];
          var key = item.props.key;
          var _item$item$props2 = item.item.props,
              activeDot = _item$item$props2.activeDot,
              dataKey = _item$item$props2.dataKey;

          var dotProps = _objectSpread({
            index: childIndex,
            dataKey: dataKey,
            cx: activePoint.x,
            cy: activePoint.y,
            r: 4,
            fill: getMainColorOfGraphicItem(item.item),
            strokeWidth: 2,
            stroke: '#fff',
            payload: activePoint.payload,
            value: activePoint.value,
            key: "".concat(key, "-activePoint-").concat(childIndex)
          }, getPresentationAttributes(activeDot), {}, filterEventAttributes(activeDot));

          result.push(this.constructor.renderActiveDot(activeDot, dotProps, childIndex));

          if (basePoint) {
            result.push(this.constructor.renderActiveDot(activeDot, _objectSpread({}, dotProps, {
              cx: basePoint.x,
              cy: basePoint.y,
              key: "".concat(key, "-basePoint-").concat(childIndex)
            }), childIndex));
          } else if (isRange) {
            result.push(null);
          }

          return result;
        }
      }, {
        key: "renderClipPath",
        value: function renderClipPath() {
          var clipPathId = this.clipPathId;
          var _this$state$offset = this.state.offset,
              left = _this$state$offset.left,
              top = _this$state$offset.top,
              height = _this$state$offset.height,
              width = _this$state$offset.width;
          return React__default['default'].createElement("defs", null, React__default['default'].createElement("clipPath", {
            id: clipPathId
          }, React__default['default'].createElement("rect", {
            x: left,
            y: top,
            height: height,
            width: width
          })));
        }
      }, {
        key: "render",
        value: function render() {
          var _this7 = this;

          if (!validateWidthHeight(this)) {
            return null;
          }

          var _this$props7 = this.props,
              children = _this$props7.children,
              className = _this$props7.className,
              width = _this$props7.width,
              height = _this$props7.height,
              style = _this$props7.style,
              compact = _this$props7.compact,
              others = _objectWithoutProperties(_this$props7, ["children", "className", "width", "height", "style", "compact"]);

          var attrs = getPresentationAttributes(others);
          var map = {
            CartesianGrid: {
              handler: this.renderGrid,
              once: true
            },
            ReferenceArea: {
              handler: this.renderReferenceElement
            },
            ReferenceLine: {
              handler: this.renderReferenceElement
            },
            ReferenceDot: {
              handler: this.renderReferenceElement
            },
            XAxis: {
              handler: this.renderXAxis
            },
            YAxis: {
              handler: this.renderYAxis
            },
            Brush: {
              handler: this.renderBrush,
              once: true
            },
            Bar: {
              handler: this.renderGraphicChild
            },
            Line: {
              handler: this.renderGraphicChild
            },
            Area: {
              handler: this.renderGraphicChild
            },
            Radar: {
              handler: this.renderGraphicChild
            },
            RadialBar: {
              handler: this.renderGraphicChild
            },
            Scatter: {
              handler: this.renderGraphicChild
            },
            Pie: {
              handler: this.renderGraphicChild
            },
            Funnel: {
              handler: this.renderGraphicChild
            },
            Tooltip: {
              handler: this.renderCursor,
              once: true
            },
            PolarGrid: {
              handler: this.renderPolarGrid,
              once: true
            },
            PolarAngleAxis: {
              handler: this.renderPolarAxis
            },
            PolarRadiusAxis: {
              handler: this.renderPolarAxis
            },
            Customized: {
              handler: this.renderCustomized
            }
          }; // The "compact" mode is mainly used as the panorama within Brush

          if (compact) {
            return React__default['default'].createElement(Surface, _extends$2({}, attrs, {
              width: width,
              height: height
            }), this.renderClipPath(), renderByOrder(children, map));
          }

          var events = this.parseEventsOfWrapper();
          return React__default['default'].createElement("div", _extends$2({
            className: classnames('recharts-wrapper', className),
            style: _objectSpread({
              position: 'relative',
              cursor: 'default',
              width: width,
              height: height
            }, style)
          }, events, {
            ref: function ref(node) {
              _this7.container = node;
            }
          }), React__default['default'].createElement(Surface, _extends$2({}, attrs, {
            width: width,
            height: height
          }), this.renderClipPath(), renderByOrder(children, map)), this.renderLegend(), this.renderTooltip());
        }
      }], [{
        key: "getAxisNameByLayout",
        value: function getAxisNameByLayout(layout) {
          if (layout === 'horizontal') {
            return {
              numericAxisName: 'yAxis',
              cateAxisName: 'xAxis'
            };
          }

          if (layout === 'vertical') {
            return {
              numericAxisName: 'xAxis',
              cateAxisName: 'yAxis'
            };
          }

          if (layout === 'centric') {
            return {
              numericAxisName: 'radiusAxis',
              cateAxisName: 'angleAxis'
            };
          }

          return {
            numericAxisName: 'angleAxis',
            cateAxisName: 'radiusAxis'
          };
        }
      }, {
        key: "renderActiveDot",
        value: function renderActiveDot(option, props) {
          var dot;

          if (React.isValidElement(option)) {
            dot = React.cloneElement(option, props);
          } else if (isFunction_1(option)) {
            dot = option(props);
          } else {
            dot = React__default['default'].createElement(Dot, props);
          }

          return React__default['default'].createElement(Layer, {
            className: "recharts-active-dot",
            key: props.key
          }, dot);
        }
      }]);

      return CategoricalChartWrapper;
    }(React.Component);

    CategoricalChartWrapper.displayName = chartName;
    CategoricalChartWrapper.propTypes = _objectSpread({
      syncId: propTypes$5.oneOfType([propTypes$5.string, propTypes$5.number]),
      compact: propTypes$5.bool,
      width: propTypes$5.number,
      height: propTypes$5.number,
      data: propTypes$5.arrayOf(propTypes$5.object),
      layout: propTypes$5.oneOf(['horizontal', 'vertical']),
      stackOffset: propTypes$5.oneOf(['sign', 'expand', 'none', 'wiggle', 'silhouette']),
      throttleDelay: propTypes$5.number,
      margin: propTypes$5.shape({
        top: propTypes$5.number,
        right: propTypes$5.number,
        bottom: propTypes$5.number,
        left: propTypes$5.number
      }),
      barCategoryGap: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
      barGap: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
      barSize: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
      maxBarSize: propTypes$5.number,
      style: propTypes$5.object,
      className: propTypes$5.string,
      children: propTypes$5.oneOfType([propTypes$5.arrayOf(propTypes$5.node), propTypes$5.node]),
      defaultShowTooltip: propTypes$5.bool,
      onClick: propTypes$5.func,
      onMouseLeave: propTypes$5.func,
      onMouseEnter: propTypes$5.func,
      onMouseMove: propTypes$5.func,
      onMouseDown: propTypes$5.func,
      onMouseUp: propTypes$5.func,
      reverseStackOrder: propTypes$5.bool,
      id: propTypes$5.string
    }, propTypes);
    CategoricalChartWrapper.defaultProps = _objectSpread({
      layout: 'horizontal',
      stackOffset: 'none',
      barCategoryGap: '10%',
      barGap: 4,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      },
      reverseStackOrder: false
    }, defaultProps);

    CategoricalChartWrapper.createDefaultState = function (props) {
      var children = props.children,
          defaultShowTooltip = props.defaultShowTooltip;
      var brushItem = findChildByType(children, Brush);
      var startIndex = brushItem && brushItem.props && brushItem.props.startIndex || 0;
      var endIndex = brushItem && brushItem.props && brushItem.props.endIndex || props.data && props.data.length - 1 || 0;
      return {
        chartX: 0,
        chartY: 0,
        dataStartIndex: startIndex,
        dataEndIndex: endIndex,
        activeTooltipIndex: -1,
        isTooltipActive: !isNil_1(defaultShowTooltip) ? defaultShowTooltip : false
      };
    };

    CategoricalChartWrapper.hasBar = function (graphicalItems) {
      if (!graphicalItems || !graphicalItems.length) {
        return false;
      }

      return graphicalItems.some(function (item) {
        var name = getDisplayName(item && item.type);
        return name && name.indexOf('Bar') >= 0;
      });
    };

    CategoricalChartWrapper.getDisplayedData = function (props, _ref11, item) {
      var graphicalItems = _ref11.graphicalItems,
          dataStartIndex = _ref11.dataStartIndex,
          dataEndIndex = _ref11.dataEndIndex;
      var itemsData = (graphicalItems || []).reduce(function (result, child) {
        var itemData = child.props.data;

        if (itemData && itemData.length) {
          return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));
        }

        return result;
      }, []);

      if (itemsData && itemsData.length > 0) {
        return itemsData;
      }

      if (item && item.props && item.props.data && item.props.data.length > 0) {
        return item.props.data;
      }

      var data = props.data;

      if (data && data.length && isNumber(dataStartIndex) && isNumber(dataEndIndex)) {
        return data.slice(dataStartIndex, dataEndIndex + 1);
      }

      return [];
    };

    return CategoricalChartWrapper;
  };

  /**
   * @fileOverview Pie Chart
   */
  var PieChart = generateCategoricalChart({
    chartName: 'PieChart',
    GraphicalChild: Pie,
    eventType: 'item',
    legendContent: 'children',
    axisComponents: [{
      axisType: 'angleAxis',
      AxisComp: PolarAngleAxis
    }, {
      axisType: 'radiusAxis',
      AxisComp: PolarRadiusAxis
    }],
    formatAxisMap: formatAxisMap,
    defaultProps: {
      layout: 'centric',
      startAngle: 0,
      endAngle: 360,
      cx: '50%',
      cy: '50%',
      innerRadius: 0,
      outerRadius: '80%'
    },
    propTypes: {
      layout: propTypes$5.oneOf(['centric']),
      startAngle: propTypes$5.number,
      endAngle: propTypes$5.number,
      cx: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
      cy: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
      innerRadius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string]),
      outerRadius: propTypes$5.oneOfType([propTypes$5.number, propTypes$5.string])
    }
  });

  var DonutChart = function DonutChart(props) {
    var width = props.width,
        legendWidth = props.legendWidth,
        colors = props.colors,
        withCenterText = props.withCenterText,
        colorOfTotalCount = props.colorOfTotalCount,
        data = props.data,
        radius = props.radius,
        withLegends = props.withLegends,
        withTooltip = props.withTooltip,
        customTooltip = props.customTooltip,
        withActiveSegment = props.withActiveSegment,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var legendSize = legendWidth;
    var chartSize = 12 - legendWidth;
    var columnOptions = {
      chart: {
        size: withLegends ? chartSize : '12',
        sizeS: '12',
        sizeXS: '12'
      },
      legends: {
        size: legendSize,
        sizeS: '12',
        sizeXS: '12'
      }
    };

    var ChartTooltip = function ChartTooltip(chartProps) {
      var payload = chartProps.payload[0];

      if (payload) {
        if (customTooltip) return customTooltip(payload);
        return /*#__PURE__*/React.createElement("div", {
          className: "DonutChart-tooltip"
        }, "".concat(payload.name).concat(chartProps.separator).concat((+payload.value).toLocaleString()));
      }

      return null;
    };

    var colorToHex$1 = colorToHex;

    var renderActiveShape = function renderActiveShape(activeShapeProps) {
      var RADIAN = Math.PI / 180;
      var cx = activeShapeProps.cx,
          cy = activeShapeProps.cy,
          midAngle = activeShapeProps.midAngle,
          innerRadius = activeShapeProps.innerRadius,
          outerRadius = activeShapeProps.outerRadius,
          startAngle = activeShapeProps.startAngle,
          endAngle = activeShapeProps.endAngle,
          fill = activeShapeProps.fill,
          payload = activeShapeProps.payload,
          percent = activeShapeProps.percent,
          value = activeShapeProps.value;
      var sin = Math.sin(-RADIAN * midAngle);
      var cos = Math.cos(-RADIAN * midAngle);
      var sx = cx + (outerRadius + 10) * cos;
      var sy = cy + (outerRadius + 10) * sin;
      var mx = cx + (outerRadius + 30) * cos;
      var my = cy + (outerRadius + 30) * sin;
      var ex = mx + (cos >= 0 ? 1 : -1) * 22;
      var ey = my;
      var textAnchor = cos >= 0 ? 'start' : 'end';
      var total = Math.ceil(value / percent);
      return /*#__PURE__*/React.createElement("g", null, withCenterText && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("text", {
        x: cx,
        y: cy,
        "font-size": 'var(--font-size-xl)',
        textAnchor: "middle"
      }, "Total"), /*#__PURE__*/React.createElement("text", {
        x: cx,
        y: cy,
        dy: 22,
        "font-size": 'var(--font-size-l)',
        textAnchor: "middle",
        fill: colorToHex$1(colorOfTotalCount)
      }, total.toLocaleString())), /*#__PURE__*/React.createElement(Sector, {
        cx: cx,
        cy: cy,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        startAngle: startAngle,
        endAngle: endAngle,
        fill: fill
      }), withActiveSegment && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Sector, {
        cx: cx,
        cy: cy,
        startAngle: startAngle,
        endAngle: endAngle,
        innerRadius: outerRadius + 6,
        outerRadius: outerRadius + 10,
        fill: fill
      }), /*#__PURE__*/React.createElement("path", {
        d: "M".concat(sx, ",").concat(sy, "L").concat(mx, ",").concat(my, "L").concat(ex, ",").concat(ey),
        stroke: fill,
        fill: "none"
      }), /*#__PURE__*/React.createElement("circle", {
        cx: ex,
        cy: ey,
        r: 2,
        fill: fill,
        stroke: "none"
      }), /*#__PURE__*/React.createElement("text", {
        x: ex + (cos >= 0 ? 1 : -1) * 12,
        y: ey,
        dy: -18,
        textAnchor: textAnchor,
        fill: fill
      }, "".concat(payload.name)), /*#__PURE__*/React.createElement("text", {
        x: ex + (cos >= 0 ? 1 : -1) * 12,
        y: ey,
        textAnchor: textAnchor,
        fill: "#333"
      }, "".concat(value.toLocaleString())), /*#__PURE__*/React.createElement("text", {
        x: ex + (cos >= 0 ? 1 : -1) * 12,
        y: ey,
        dy: 18,
        textAnchor: textAnchor,
        fill: "#999"
      }, "".concat((percent * 100).toFixed(0), "%"))));
    };

    var _React$useState = React.useState(0),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        activeIndex = _React$useState2[0],
        setActiveIndex = _React$useState2[1];

    var onPieEnter = function onPieEnter(_data, index) {
      setActiveIndex(index);
    };

    var getColor = function getColor(index, type) {
      var color = colors[index % colors.length];
      var colorHex = colorToHex$1(color);
      return type === 'hex' ? colorHex : color;
    };

    var oRadius = withActiveSegment ? radius ? .7 * radius : '70%' : radius || '100%';
    var iRadius = withActiveSegment ? radius ? (100 - width) / 100 * oRadius : "".concat((100 - width) / 100 * 70, "%") : radius ? (100 - width) / 100 * radius : "".concat(100 - width, "%"); // const tooltipPayload = data.reduce((out: Data[], curr) => {
    //   out.push({
    //     name: curr.name,
    //     value: (+curr.value).toLocaleString()
    //   });
    //   return out;
    // }, []);

    var classes = classnames(_defineProperty$w({}, 'DonutChart', true), className);
    return /*#__PURE__*/React.createElement(Row, _extends$p({}, baseProps, {
      className: classes
    }), /*#__PURE__*/React.createElement(Column, columnOptions.chart, /*#__PURE__*/React.createElement(ResponsiveContainer, null, /*#__PURE__*/React.createElement(PieChart, null, /*#__PURE__*/React.createElement(Pie, {
      data: data,
      dataKey: "value",
      activeIndex: activeIndex,
      activeShape: renderActiveShape,
      onMouseEnter: onPieEnter,
      outerRadius: oRadius,
      innerRadius: iRadius
    }, data.map(function (_entry, index) {
      return /*#__PURE__*/React.createElement(Cell$1, {
        fill: getColor(index, 'hex'),
        key: index
      });
    })), withTooltip && /*#__PURE__*/React.createElement(Tooltip$1, {
      separator: ": ",
      content: /*#__PURE__*/React.createElement(ChartTooltip, null)
    })))), withLegends && /*#__PURE__*/React.createElement(Column, _extends$p({
      className: "DonutChart-legends"
    }, columnOptions.legends), data.map(function (d, i) {
      return /*#__PURE__*/React.createElement(Legend, {
        key: i,
        iconAppearance: getColor(i)
      }, "".concat(d.name, " - ").concat((+d.value).toLocaleString()));
    })));
  };
  DonutChart.displayName = 'DonutChart';
  DonutChart.defaultProps = {
    width: 20,
    legendWidth: 3,
    colors: ['primary', 'secondary', 'success', 'warning', 'alert'],
    withCenterText: true,
    colorOfTotalCount: 'success'
  };

  var sizeMapping = {
    tiny: 12,
    regular: 16,
    large: 20
  };
  /**
   * ###### Input has two types:
   *  - [Controlled Input](https://reactjs.org/docs/forms.html#controlled-components)
   *  - [Uncontrolled Input](https://reactjs.org/docs/uncontrolled-components.html)
   */

  var Input = /*#__PURE__*/React.forwardRef(function (props, forwardedRef) {
    var _classNames, _classNames2, _classNames3, _classNames4;

    var _props$size = props.size,
        size = _props$size === void 0 ? 'regular' : _props$size,
        _props$type = props.type,
        type = _props$type === void 0 ? 'text' : _props$type,
        _props$minWidth = props.minWidth,
        minWidth = _props$minWidth === void 0 ? type !== 'number' ? 256 : undefined : _props$minWidth,
        defaultValue = props.defaultValue,
        name = props.name,
        placeholder = props.placeholder,
        value = props.value,
        icon = props.icon,
        inlineLabel = props.inlineLabel,
        required = props.required,
        error = props.error,
        info = props.info,
        onChange = props.onChange,
        onClick = props.onClick,
        onClear = props.onClear,
        onBlur = props.onBlur,
        onFocus = props.onFocus,
        actionIcon = props.actionIcon,
        className = props.className,
        autoFocus = props.autoFocus,
        disabled = props.disabled,
        readOnly = props.readOnly,
        rest = _objectWithoutProperties$a(props, ["size", "type", "minWidth", "defaultValue", "name", "placeholder", "value", "icon", "inlineLabel", "required", "error", "info", "onChange", "onClick", "onClear", "onBlur", "onFocus", "actionIcon", "className", "autoFocus", "disabled", "readOnly"]);

    var ref = React.useRef(null);
    React.useImperativeHandle(forwardedRef, function () {
      return ref.current;
    });
    React.useEffect(function () {
      var _ref$current;

      if (autoFocus) (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus({
        preventScroll: true
      });
    }, []);
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Input', true), _defineProperty$w(_classNames, "Input--".concat(size), size), _defineProperty$w(_classNames, 'Input--disabled', disabled || readOnly), _defineProperty$w(_classNames, 'Input--error', error), _classNames), className);
    var inputClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Input-input', true), _defineProperty$w(_classNames2, "Input-input--".concat(size), size), _classNames2));
    var leftIconClass = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'Input-icon', true), _defineProperty$w(_classNames3, 'Input-icon--left', true), _defineProperty$w(_classNames3, 'Input-icon--disabled', !value), _classNames3));
    var rightIconClass = classnames((_classNames4 = {}, _defineProperty$w(_classNames4, 'Input-icon', true), _defineProperty$w(_classNames4, 'Input-icon--right', true), _classNames4));
    var trigger = /*#__PURE__*/React.createElement("div", {
      className: rightIconClass
    }, /*#__PURE__*/React.createElement(Icon, {
      name: 'info',
      size: sizeMapping[size]
    }));
    return /*#__PURE__*/React.createElement("div", {
      "data-test": "DesignSystem-InputWrapper",
      className: classes,
      style: {
        minWidth: minWidth
      },
      onClick: function onClick() {
        var _ref$current2;

        return (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();
      }
    }, inlineLabel && /*#__PURE__*/React.createElement("div", {
      className: "Input-inlineLabel"
    }, /*#__PURE__*/React.createElement(Text$1, {
      appearance: "subtle"
    }, inlineLabel)), size !== 'tiny' && icon && /*#__PURE__*/React.createElement("div", {
      className: leftIconClass
    }, /*#__PURE__*/React.createElement(Icon, {
      name: icon,
      size: sizeMapping[size]
    })), /*#__PURE__*/React.createElement("input", _extends$p({
      "data-test": "DesignSystem-Input"
    }, baseProps, rest, {
      ref: ref,
      name: name,
      type: type,
      defaultValue: defaultValue,
      placeholder: placeholder,
      className: inputClass,
      value: value,
      required: required,
      disabled: disabled,
      readOnly: readOnly,
      onChange: onChange,
      onBlur: onBlur,
      onClick: onClick,
      onFocus: onFocus
    })), !value && !disabled || value && disabled || defaultValue && disabled ? info && /*#__PURE__*/React.createElement(Tooltip, {
      position: "top",
      tooltip: info
    }, trigger) : actionIcon ? actionIcon : onClear && value && !disabled && /*#__PURE__*/React.createElement("div", {
      className: rightIconClass,
      onClick: function onClick(e) {
        return onClear(e);
      }
    }, /*#__PURE__*/React.createElement(Icon, {
      name: 'close',
      size: sizeMapping[size]
    })));
  });
  Input.displayName = 'Input';

  var isEditable = function isEditable(mask, pos) {
    return _typeof$p(mask[pos]) === 'object';
  };
  var getDefaultValue = function getDefaultValue(mask, placeholderChar) {
    var val = '';

    for (var i = 0; i < mask.length; i++) {
      val += isEditable(mask, i) ? placeholderChar : mask[i];
    }

    return val;
  };

  /**
   * It works as Uncontrolled Input
   *
   * **Updated value can be passed**
   */
  var InputMask = /*#__PURE__*/React.forwardRef(function (props, forwardRef) {
    props.mask;
        var valueProp = props.value,
        _props$placeholderCha = props.placeholderChar,
        placeholderChar = _props$placeholderCha === void 0 ? '_' : _props$placeholderCha,
        _props$validators = props.validators,
        validators = _props$validators === void 0 ? [] : _props$validators,
        _props$clearOnEmptyBl = props.clearOnEmptyBlur,
        clearOnEmptyBlur = _props$clearOnEmptyBl === void 0 ? true : _props$clearOnEmptyBl,
        defaultValue = props.defaultValue,
        mask = props.mask,
        error = props.error,
        caption = props.caption,
        required = props.required,
        onChange = props.onChange,
        onBlur = props.onBlur,
        onFocus = props.onFocus,
        onClear = props.onClear,
        className = props.className,
        rest = _objectWithoutProperties$a(props, ["mask", "value", "placeholderChar", "validators", "clearOnEmptyBlur", "defaultValue", "mask", "error", "caption", "required", "onChange", "onBlur", "onFocus", "onClear", "className"]);

    var getNewCursorPosition = function getNewCursorPosition(type, position) {
      if (type === 'right') {
        for (var i = position; i < mask.length; i++) {
          if (isEditable(i)) return i;
        }

        return mask.length;
      }

      if (type === 'left') {
        for (var _i = position; _i >= 0; _i--) {
          if (isEditable(_i - 1)) return _i;
        }

        return 0;
      }

      return position;
    };

    var getDefaultSelection = function getDefaultSelection() {
      var pos = getNewCursorPosition('right', 0);
      return {
        start: pos,
        end: pos
      };
    };

    var getPlaceholderValue = function getPlaceholderValue() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mask.length - 1;
      return getDefaultValue(mask, placeholderChar).slice(start, end + 1);
    };

    var getSelectionLength = function getSelectionLength(val) {
      return Math.abs(val.end - val.start);
    };

    var isEditable = function isEditable(pos) {
      return _typeof$p(mask[pos]) === 'object';
    };

    var deferId = React.useRef();
    var selectionRef = React.useRef(0);

    var _React$useState = React.useState(defaultValue || valueProp || ''),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        value = _React$useState2[0],
        setValue = _React$useState2[1];

    var _React$useState3 = React.useState(getDefaultSelection()),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        selection = _React$useState4[0],
        setSelection = _React$useState4[1];

    var ref = React.useRef(null);
    React.useImperativeHandle(forwardRef, function () {
      return ref.current;
    });
    React.useEffect(function () {
      setValue(valueProp || '');
    }, [valueProp]);

    var setCursorPosition = function setCursorPosition(val) {
      return setSelectionPos({
        start: val,
        end: val
      });
    };

    var getCurrSelection = function getCurrSelection() {
      return {
        start: ref.current.selectionStart || 0,
        end: ref.current.selectionEnd || 0
      };
    };

    var setSelectionPos = function setSelectionPos(pos) {
      if (ref.current) {
        var el = ref.current;
        var start = Math.min(pos.start, pos.end);
        var end = Math.max(pos.start, pos.end);
        el.setSelectionRange(start, end);
      }
    };

    var updateSelection = function updateSelection() {
      setSelection(getCurrSelection());
      deferId.current = window.requestAnimationFrame(updateSelection);
    };

    var insertAtIndex = function insertAtIndex(currValue, index) {
      var iterator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var newValue = '';
      var newIndex = index + 1;
      var newIterator = iterator;

      if (index >= mask.length) {
        return newValue;
      }

      if (iterator >= currValue.length) {
        selectionRef.current = index;
        return newValue;
      }

      var m = mask[index];

      if (isEditable(index)) {
        if (currValue[iterator].match(m)) {
          newValue += currValue[iterator];
        } else {
          newValue += placeholderChar;
        }

        newIterator++;
      } else {
        newValue += m;
      }

      newValue += insertAtIndex(currValue, newIndex, newIterator);
      return newValue;
    };

    var onChangeHandler = function onChangeHandler(e) {
      var inputVal = e.currentTarget.value;
      var currSelection = getCurrSelection();
      var start = Math.min(selection.start, currSelection.start);
      var end = currSelection.end;
      var cursorPosition = start;
      var enteredVal = '';
      var updatedVal = '';
      var removedLength = 0;
      var insertedStringLength = 0;
      enteredVal = inputVal.slice(start, end);
      updatedVal = insertAtIndex(enteredVal, start);
      insertedStringLength = updatedVal.length;

      if (currSelection.end > selection.end) {
        removedLength = insertedStringLength ? getSelectionLength(selection) : 0;
      } else if (inputVal.length < value.length) {
        removedLength = value.length - inputVal.length;
      }

      cursorPosition += insertedStringLength;
      var maskedVal = value.split('');

      for (var i = 0; i < insertedStringLength; i++) {
        maskedVal[start + i] = updatedVal[i];
      }

      for (var _i2 = 0; _i2 < removedLength; _i2++) {
        var index = start + insertedStringLength + _i2;
        maskedVal[index] = getPlaceholderValue(index, index);
      }

      var newCursorPosition = getNewCursorPosition(removedLength ? 'left' : 'right', cursorPosition);

      if (removedLength === 1 && !updatedVal.length && !isEditable(cursorPosition) && newCursorPosition > 0) {
        cursorPosition = newCursorPosition;
        cursorPosition--;
        maskedVal[cursorPosition] = placeholderChar;
      } else if (removedLength !== 1) {
        cursorPosition = newCursorPosition;
      }

      var newValue = maskedVal.slice(0, mask.length).join('');
      window.requestAnimationFrame(function () {
        return setCursorPosition(cursorPosition);
      });

      if (isValid(validators, newValue)) {
        setValue(newValue);
        if (onChange) onChange(e, newValue);
      }
    };

    var onBlurHandler = function onBlurHandler(e) {
      var inputVal = e.currentTarget.value;

      if (clearOnEmptyBlur) {
        if (inputVal === getPlaceholderValue()) {
          setValue('');
          inputVal = '';
        }
      }

      if (onBlur) onBlur(e, inputVal);
      if (deferId.current) window.cancelAnimationFrame(deferId.current);
    };

    var onClearHandler = function onClearHandler(e) {
      // setValue('');
      // window.requestAnimationFrame(() => ref.current!.blur());
      setValue(getPlaceholderValue());
      window.requestAnimationFrame(function () {
        return setCursorPosition(getDefaultSelection().start);
      });
      if (onClear) onClear(e);
    };

    var onFocusHandler = function onFocusHandler(e) {
      deferId.current = window.requestAnimationFrame(updateSelection);

      if (!value) {
        setValue(getPlaceholderValue());
        window.requestAnimationFrame(function () {
          return setSelectionPos(getDefaultSelection());
        });
      }

      if (onFocus) onFocus(e);
    };

    var classes = classnames({
      'd-flex flex-column flex-grow-1': true
    }, className);
    return /*#__PURE__*/React.createElement("div", {
      className: classes
    }, /*#__PURE__*/React.createElement(Input, _extends$p({}, rest, {
      value: value,
      error: error,
      required: required,
      onFocus: onFocusHandler,
      onChange: onChangeHandler,
      onClear: onClearHandler,
      onBlur: onBlurHandler,
      autoComplete: 'off',
      ref: ref
    })), /*#__PURE__*/React.createElement(Caption, {
      error: error,
      withInput: true,
      hide: !caption
    }, caption));
  });
  InputMask.displayName = 'InputMask'; // @ts-ignore

  InputMask.utils = {
    getDefaultValue: getDefaultValue
  };

  /**
   * *NOTE: Extends props with HTMLProps<HTMLLabelElement>*
   */
  var Label = function Label(props) {
    var _classNames;

    var required = props.required,
        withInput = props.withInput,
        disabled = props.disabled,
        children = props.children,
        className = props.className,
        rest = _objectWithoutProperties$a(props, ["required", "withInput", "disabled", "children", "className"]);

    var baseProps = extractBaseProps(props);
    var LabelClass = classnames((_classNames = {
      Label: true
    }, _defineProperty$w(_classNames, 'Label--withInput', withInput), _defineProperty$w(_classNames, "".concat(className), className), _classNames));
    var classes = classnames({
      'Label-label': true,
      'Label--disabled': disabled
    });
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-Label"
    }, baseProps, {
      className: LabelClass
    }), /*#__PURE__*/React.createElement(GenericText, _extends$p({
      className: classes,
      componentType: "label"
    }, rest), children), required && /*#__PURE__*/React.createElement("span", {
      className: "Label-requiredIndicator",
      "data-test": "DesignSystem-Label--RequiredIndicator"
    }));
  };
  Label.displayName = 'Label';

  var Caption = function Caption(props) {
    var _classNames;

    var error = props.error,
        hide = props.hide,
        withInput = props.withInput,
        children = props.children,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {
      Caption: true
    }, _defineProperty$w(_classNames, 'Caption--hidden', hide), _defineProperty$w(_classNames, 'Caption--withInput', withInput), _classNames), className);
    var errorIconClass = classnames(_defineProperty$w({}, 'Caption-icon', true));
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: classes
    }), error && /*#__PURE__*/React.createElement("div", {
      className: errorIconClass
    }, /*#__PURE__*/React.createElement(Icon, {
      size: 14,
      name: 'error',
      appearance: 'alert'
    })), /*#__PURE__*/React.createElement(Text$1, {
      appearance: error ? 'destructive' : 'subtle',
      size: "small",
      weight: "medium"
    }, "".concat(children)));
  };
  Caption.displayName = 'Caption';

  var Legend = function Legend(props) {
    var iconAppearance = props.iconAppearance,
        iconSize = props.iconSize,
        labelAppearance = props.labelAppearance,
        children = props.children,
        labelWeight = props.labelWeight,
        _onMouseEnter = props.onMouseEnter,
        _onMouseLeave = props.onMouseLeave,
        _onClick = props.onClick,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var legendClass = classnames(_defineProperty$w({}, 'Legend', true), className);
    var styles = {
      background: "var(--".concat(iconAppearance, ")"),
      height: "".concat(iconSize, "px"),
      width: "".concat(iconSize, "px")
    };
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: legendClass,
      onClick: function onClick(e) {
        return _onClick && _onClick(e);
      },
      onMouseEnter: function onMouseEnter(e) {
        return _onMouseEnter && _onMouseEnter(e);
      },
      onMouseLeave: function onMouseLeave(e) {
        return _onMouseLeave && _onMouseLeave(e);
      }
    }), /*#__PURE__*/React.createElement("span", {
      className: "Legend-icon",
      style: styles
    }), /*#__PURE__*/React.createElement(Text$1, {
      appearance: labelAppearance,
      weight: labelWeight
    }, children));
  };
  Legend.displayName = 'Legend';
  Legend.defaultProps = {
    iconAppearance: 'inverse',
    iconSize: 16
  };

  var Editable = function Editable(props) {
    var className = props.className,
        onChange = props.onChange,
        editing = props.editing,
        children = props.children;
    var baseProps = extractBaseProps(props);
    var EditableClass = classnames(_defineProperty$w({}, 'Editable', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-Editable"
    }, baseProps, {
      className: EditableClass
    }), /*#__PURE__*/React.createElement("div", {
      "data-test": "DesignSystem-EditableWrapper",
      onClick: function onClick() {
        return onChange('edit');
      },
      onMouseEnter: function onMouseEnter() {
        return !editing && onChange('hover');
      },
      onMouseLeave: function onMouseLeave() {
        return !editing && onChange('default');
      }
    }, children));
  };
  Editable.displayName = 'Editable';

  var EditableDropdown = function EditableDropdown(props) {
    var _classNames2;

    var placeholder = props.placeholder,
        dropdownOptions = props.dropdownOptions,
        className = props.className,
        customTriggerRenderer = props.customTriggerRenderer;

    var onDropdownChange = dropdownOptions.onChange,
        onDropdownClose = dropdownOptions.onClose,
        rest = _objectWithoutProperties$a(dropdownOptions, ["onChange", "onClose"]);

    var _React$useState = React.useState(placeholder),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        label = _React$useState2[0],
        setLabel = _React$useState2[1];

    var _React$useState3 = React.useState(false),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        editing = _React$useState4[0],
        setEditing = _React$useState4[1];

    var _React$useState5 = React.useState(false),
        _React$useState6 = _slicedToArray$6(_React$useState5, 2),
        showComponent = _React$useState6[0],
        setShowComponent = _React$useState6[1];

    var CompClass = classnames(_defineProperty$w({}, 'EditableDropdown', true), className);
    var DefaultCompClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'EditableDropdown-default', true), _defineProperty$w(_classNames2, 'd-none', showComponent), _classNames2));
    var EditableDropdownClass = classnames(_defineProperty$w({}, 'd-none', !showComponent));
    var baseProps = extractBaseProps(props);

    var getLabel = function getLabel(updatedLabel) {
      setLabel(updatedLabel);
    };

    var onChangeHandler = function onChangeHandler(eventType) {
      switch (eventType) {
        case 'edit':
          setEditing(true);

        case 'hover':
          setShowComponent(true);
          return;

        case 'default':
          setShowComponent(false);
          return;
      }
    };

    var onChange = function onChange(value) {
      setEditing(false);
      setShowComponent(false);
      if (onDropdownChange) onDropdownChange(value);
    };

    var onClose = function onClose(selected) {
      setEditing(false);
      setShowComponent(false);
      if (onDropdownClose) onDropdownClose(selected);
    };

    var renderComponent = function renderComponent(componentLabel) {
      if (customTriggerRenderer) return customTriggerRenderer(componentLabel);
      return componentLabel;
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-EditableDropdown"
    }, baseProps, {
      className: CompClass
    }), /*#__PURE__*/React.createElement(Editable, {
      onChange: onChangeHandler,
      editing: editing
    }, /*#__PURE__*/React.createElement(Dropdown, _extends$p({
      placeholder: placeholder,
      onChange: onChange,
      getLabel: getLabel,
      onClose: onClose,
      className: EditableDropdownClass,
      "data-test": "DesignSystem-EditableDropdown--Dropdown"
    }, rest)), /*#__PURE__*/React.createElement("div", {
      className: DefaultCompClass,
      "data-test": "DesignSystem-EditableDropdown--Default"
    }, renderComponent(label || placeholder))));
  };
  EditableDropdown.defaultProps = {
    placeholder: '',
    dropdownOptions: {}
  };

  var Link = function Link(props) {
    var children = props.children,
        className = props.className,
        rest = _objectWithoutProperties$a(props, ["children", "className"]);

    var classes = classnames({
      Link: true
    }, className);
    return /*#__PURE__*/React.createElement(GenericText, _extends$p({
      className: classes,
      componentType: "a"
    }, rest), children);
  };
  Link.displayName = 'Link';

  var IconMapping$1 = {
    success: 'check_circle',
    info: 'info',
    warning: 'warning',
    alert: 'error'
  };
  var Message = function Message(props) {
    var _classNames, _classNames2;

    var appearance = props.appearance,
        title = props.title,
        children = props.children,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var MessageClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Message', true), _defineProperty$w(_classNames, "Message--".concat(appearance), appearance), _classNames), className);
    var MessageIcon = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Message-icon', true), _defineProperty$w(_classNames2, "Message-icon--".concat(appearance), appearance), _defineProperty$w(_classNames2, 'Message-icon--withTitle', title), _classNames2));
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-Message"
    }, baseProps, {
      className: MessageClass
    }), appearance !== 'default' && /*#__PURE__*/React.createElement("div", {
      className: MessageIcon,
      "data-test": "DesignSystem-Message--Icon"
    }, /*#__PURE__*/React.createElement(Icon, {
      name: IconMapping$1[appearance],
      appearance: appearance
    })), /*#__PURE__*/React.createElement("div", {
      "data-test": "DesignSystem-Message--Title"
    }, title && /*#__PURE__*/React.createElement("div", {
      className: "Message-title"
    }, /*#__PURE__*/React.createElement(Heading, {
      size: "s"
    }, title)), /*#__PURE__*/React.createElement("div", {
      "data-test": "DesignSystem-Message--Description",
      className: "Message-description"
    }, children)));
  };
  Message.displayName = 'Message';
  Message.defaultProps = {
    appearance: 'default'
  };

  var Meta = function Meta(props) {
    var label = props.label,
        icon = props.icon,
        iconAppearance = props.iconAppearance,
        labelAppearance = props.labelAppearance;
    return /*#__PURE__*/React.createElement("span", {
      className: 'Meta'
    }, icon && /*#__PURE__*/React.createElement(Icon, {
      name: icon,
      appearance: iconAppearance,
      className: 'Meta-icon'
    }), /*#__PURE__*/React.createElement(Text$1, {
      appearance: labelAppearance
    }, label));
  };
  Meta.displayName = 'Meta';

  var MetaList = function MetaList(props) {
    var _classNames3;

    var list = props.list,
        seperator = props.seperator,
        seperatorAppearance = props.seperatorAppearance,
        iconAppearance = props.iconAppearance,
        labelAppearance = props.labelAppearance,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var MetaClass = classnames(_defineProperty$w({}, 'MetaList', true), className);
    var SeperatorClass = classnames(_defineProperty$w({}, 'MetaList-seperator', true));
    var LeftSeperatorClass = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'MetaList-seperator', true), _defineProperty$w(_classNames3, 'MetaList-seperator--left', true), _classNames3));
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: MetaClass
    }), seperator && /*#__PURE__*/React.createElement(Icon, {
      name: "fiber_manual_record",
      size: 8,
      className: LeftSeperatorClass,
      appearance: seperatorAppearance
    }), list.map(function (item, ind) {
      var _item$label = item.label,
          label = _item$label === void 0 ? '' : _item$label,
          icon = item.icon;
      var rightSeperator = ind !== list.length - 1;
      return /*#__PURE__*/React.createElement("span", {
        key: ind,
        className: "MetaList-item"
      }, /*#__PURE__*/React.createElement(Meta, {
        label: label,
        icon: icon,
        iconAppearance: iconAppearance,
        labelAppearance: labelAppearance
      }), rightSeperator && /*#__PURE__*/React.createElement(Icon, {
        name: "fiber_manual_record",
        size: 8,
        className: SeperatorClass,
        appearance: seperatorAppearance
      }));
    }));
  };
  MetaList.displayName = 'MetaList';
  MetaList.defaultProps = {
    seperatorAppearance: 'disabled',
    iconAppearance: 'disabled',
    labelAppearance: 'subtle'
  };

  var OutsideClick = /*#__PURE__*/React.forwardRef(function (props, ref) {
    var children = props.children,
        className = props.className,
        onOutsideClick = props.onOutsideClick,
        rest = _objectWithoutProperties$a(props, ["children", "className", "onOutsideClick"]);

    var innerRef = React.useRef(null);
    React.useImperativeHandle(ref, function () {
      return innerRef.current;
    }, [innerRef]);
    React.useEffect(function () {
      document.addEventListener('click', handleOutsideClick, true);
      return function () {
        document.removeEventListener('click', handleOutsideClick);
      };
    }, []);
    var handleOutsideClick = React.useCallback(function (event) {
      var element = innerRef;

      if (!event.target || !element.current) {
        return;
      }

      if (!ReactDOM.findDOMNode(element.current).contains(event.target)) {
        onOutsideClick(event);
      }
    }, []);
    var classes = classnames(_defineProperty$w({}, 'OutsideClick', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      ref: innerRef
    }, rest, {
      className: classes
    }), children);
  });
  OutsideClick.displayName = 'OutsideClick';

  var Paragraph = function Paragraph(props) {
    var appearance = props.appearance,
        children = props.children,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames(_defineProperty$w({
      Text: true
    }, "Text--".concat(appearance), appearance), className);
    return /*#__PURE__*/React.createElement(GenericText, _extends$p({
      "data-test": "DesignSystem-Paragraph"
    }, baseProps, {
      className: classes,
      componentType: "p"
    }), children);
  };
  Paragraph.displayName = 'Paragraph';
  Paragraph.defaultProps = {
    appearance: 'default'
  };

  var ProgressBar = function ProgressBar(props) {
    var max = props.max,
        value = props.value,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var style = {
      width: value > 0 ? "".concat(Math.min(value, max) * 100 / max, "%") : '0'
    };
    var ProgressBarClass = classnames({
      ProgressBar: true
    }, className);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-ProgressBar"
    }, baseProps, {
      className: ProgressBarClass
    }), /*#__PURE__*/React.createElement("div", {
      className: 'ProgressBar-indicator',
      style: style
    }));
  };
  ProgressBar.displayName = 'ProgressBar';
  ProgressBar.defaultProps = {
    max: 100
  };

  var Radio = /*#__PURE__*/React.forwardRef(function (props, forwardedRef) {
    var _classNames, _classNames2, _classNames3;

    var _props$size = props.size,
        size = _props$size === void 0 ? 'regular' : _props$size,
        label = props.label,
        disabled = props.disabled,
        onChange = props.onChange,
        name = props.name,
        value = props.value,
        checked = props.checked,
        defaultChecked = props.defaultChecked,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var ref = React.useRef(null);
    React.useImperativeHandle(forwardedRef, function () {
      return ref.current;
    });
    var RadioClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Radio', true), _defineProperty$w(_classNames, 'Radio--disabled', disabled), _defineProperty$w(_classNames, "Radio--".concat(size), size), _classNames), className);
    var RadioWrapper = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Radio-wrapper', true), _defineProperty$w(_classNames2, "Radio-wrapper--".concat(size), size), _classNames2));
    var RadioOuterWrapper = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'Radio-outerWrapper', true), _defineProperty$w(_classNames3, "Radio-outerWrapper--".concat(size), size), _classNames3));
    var id = "".concat(name, "-").concat(label, "-").concat(uidGenerator());
    return /*#__PURE__*/React.createElement("div", {
      className: RadioClass
    }, /*#__PURE__*/React.createElement("div", {
      className: RadioOuterWrapper
    }, /*#__PURE__*/React.createElement("input", _extends$p({}, baseProps, {
      type: "radio",
      disabled: disabled,
      checked: checked,
      defaultChecked: defaultChecked,
      ref: ref,
      name: name,
      value: value,
      onChange: onChange,
      className: "Radio-input",
      id: id
    })), /*#__PURE__*/React.createElement("span", {
      className: RadioWrapper
    })), label && /*#__PURE__*/React.createElement("label", {
      className: "Radio-label",
      htmlFor: id
    }, /*#__PURE__*/React.createElement(Text$1, {
      size: size === 'tiny' ? 'small' : 'regular',
      appearance: disabled ? 'disabled' : 'default'
    }, label)));
  });
  Radio.displayName = 'Radio';

  var Row = /*#__PURE__*/React.forwardRef(function (props, ref) {
    var className = props.className,
        children = props.children,
        rest = _objectWithoutProperties$a(props, ["className", "children"]);

    var classes = classnames(_defineProperty$w({
      Row: true
    }, "".concat(className), className));
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-Row",
      ref: ref
    }, rest, {
      className: classes
    }), children);
  });
  Row.displayName = 'Row';

  var StatusHint = function StatusHint(props) {
    var _classNames2;

    var appearance = props.appearance,
        children = props.children,
        _onMouseEnter = props.onMouseEnter,
        _onMouseLeave = props.onMouseLeave,
        _onClick = props.onClick,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var StatusHintClass = classnames(_defineProperty$w({}, 'StatusHint', true), className);
    var StatusHintIconClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'StatusHint-icon', true), _defineProperty$w(_classNames2, "StatusHint--".concat(appearance), appearance), _classNames2));
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-StatusHint"
    }, baseProps, {
      className: StatusHintClass,
      onClick: function onClick(e) {
        return _onClick && _onClick(e);
      },
      onMouseEnter: function onMouseEnter(e) {
        return _onMouseEnter && _onMouseEnter(e);
      },
      onMouseLeave: function onMouseLeave(e) {
        return _onMouseLeave && _onMouseLeave(e);
      }
    }), /*#__PURE__*/React.createElement("span", {
      "data-test": "DesignSystem-StatusHint--Icon",
      className: StatusHintIconClass
    }), /*#__PURE__*/React.createElement(Text$1, {
      "data-test": "DesignSystem-StatusHint--Text",
      weight: 'medium'
    }, children));
  };
  StatusHint.displayName = 'StatusHint';
  StatusHint.defaultProps = {
    appearance: 'default'
  };

  var Pills = function Pills(props) {
    var _classNames;

    var appearance = props.appearance,
        children = props.children,
        subtle = props.subtle,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {
      Pills: true
    }, _defineProperty$w(_classNames, "Badge--".concat(appearance), appearance && !subtle), _defineProperty$w(_classNames, "Badge--subtle-".concat(appearance), subtle), _classNames), className);
    return /*#__PURE__*/React.createElement("span", _extends$p({
      "data-test": "DesignSystem-Pills"
    }, baseProps, {
      className: classes
    }), children);
  };
  Pills.displayName = 'Pills';
  Pills.defaultProps = {
    appearance: 'secondary'
  };

  var ARROW_LEFT = 37;
  var ARROW_RIGHT = 39;

  var formatPercentage = function formatPercentage(ratio) {
    return "".concat((ratio * 100).toFixed(2), "%");
  };
  var countDecimalPlaces = function countDecimalPlaces(value) {
    if (!isFinite(value)) return 0;

    if (Math.floor(value) !== value) {
      var valueArray = value.toString().split('.');
      return valueArray[1].length || 0;
    }

    return 0;
  };
  var approxEqual = function approxEqual(a, b) {
    var tolerance = 0.00001;
    return Math.abs(a - b) <= tolerance;
  };
  var clamp = function clamp(value, min, max) {
    if (value == null) {
      return value;
    }

    return Math.min(Math.max(value, min), max);
  };
  var arraysEqual = function arraysEqual(oldValues, newValues) {
    if (oldValues.length !== oldValues.length) return;
    return newValues.every(function (value, index) {
      return value === oldValues[index];
    });
  };
  function argMin(values, argFn) {
    if (values.length === 0) {
      return undefined;
    }

    var minValue = values[0];
    var minArg = argFn(minValue);

    for (var index = 1; index < values.length; index++) {
      var _value = values[index];
      var arg = argFn(_value);

      if (arg < minArg) {
        minValue = _value;
        minArg = arg;
      }
    }

    return minValue;
  }
  function fillValues(values, startIndex, endIndex, fillValue) {
    var inc = startIndex < endIndex ? 1 : -1;

    for (var index = startIndex; index !== endIndex + inc; index += inc) {
      values[index] = fillValue;
    }
  }
  function isElementOfType(element, _ComponentType) {
    return element != null && element.type != null;
  }

  var Handle = /*#__PURE__*/function (_React$Component) {
    _inherits$o(Handle, _React$Component);

    var _super = _createSuper(Handle);

    function Handle() {
      var _this;

      _classCallCheck$p(this, Handle);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$w(_assertThisInitialized$p(_this), "state", {
        isMoving: false
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "handleElement", null);

      _defineProperty$w(_assertThisInitialized$p(_this), "refHandlers", {
        handle: function handle(el) {
          return _this.handleElement = el;
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "mouseEventClientOffset", function (event) {
        return event.clientX;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "clientToValue", function (clientPixel) {
        var _this$props = _this.props,
            stepSize = _this$props.stepSize,
            tickSize = _this$props.tickSize,
            value = _this$props.value;

        if (_this.handleElement == null) {
          return value;
        }

        var clientPixelNormalized = clientPixel;

        var _this$getHandleMidpoi = _this.getHandleMidpointAndOffset(_this.handleElement),
            handleMidpoint = _this$getHandleMidpoi.handleMidpoint,
            handleOffset = _this$getHandleMidpoi.handleOffset;

        var handleCenterPixel = handleMidpoint + handleOffset;
        var pixelDelta = clientPixelNormalized - handleCenterPixel;

        if (isNaN(pixelDelta)) {
          return value;
        }

        return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "changeValue", function (newValue) {
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.props.onChange;
        var updatedValue = clamp(newValue, _this.props.min, _this.props.max);

        if (!isNaN(updatedValue) && _this.props.value !== updatedValue) {
          if (callback) callback(updatedValue);
        }

        return updatedValue;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "endHandleMovement", function (event) {
        var clientPixel = _this.mouseEventClientOffset(event);

        var onRelease = _this.props.onRelease;

        _this.removeDocumentEventListeners();

        _this.setState({
          isMoving: false
        });

        var finalValue = _this.changeValue(_this.clientToValue(clientPixel));

        if (onRelease) onRelease(finalValue);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "continueHandleMovement", function (event) {
        var clientPixel = _this.mouseEventClientOffset(event);

        if (_this.state.isMoving && !_this.props.disabled) {
          var value = _this.clientToValue(clientPixel);

          _this.changeValue(value);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "beginHandleMovement", function (event) {
        if (_this.props.disabled) return;
        document.addEventListener('mousemove', _this.continueHandleMovement);
        document.addEventListener('mouseup', _this.endHandleMovement);

        _this.setState({
          isMoving: true
        });

        var value = _this.clientToValue(event.clientX);

        _this.changeValue(value);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "handleKeyDown", function (event) {
        if (_this.props.disabled) return;
        var _this$props2 = _this.props,
            stepSize = _this$props2.stepSize,
            value = _this$props2.value;
        var which = event.which;

        if (which === ARROW_LEFT) {
          _this.changeValue(value - stepSize);

          event.preventDefault();
        } else if (which === ARROW_RIGHT) {
          _this.changeValue(value + stepSize);

          event.preventDefault();
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "handleKeyUp", function (event) {
        if (_this.props.disabled) return;

        if ([ARROW_LEFT, ARROW_RIGHT].indexOf(event.which) >= 0) {
          var onRelease = _this.props.onRelease;
          if (onRelease) onRelease(_this.props.value);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getHandleMidpointAndOffset", function (handleElement) {
        var useOppositeDimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (handleElement == null) {
          return {
            handleMidpoint: 0,
            handleOffset: 0
          };
        }

        var handleRect = handleElement.getBoundingClientRect();
        var sizeKey = useOppositeDimension ? 'height' : 'width';
        var handleOffset = handleRect.left;
        return {
          handleOffset: handleOffset,
          handleMidpoint: handleRect[sizeKey] / 2
        };
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "removeDocumentEventListeners", function () {
        document.removeEventListener('mousemove', _this.continueHandleMovement);
        document.removeEventListener('mouseup', _this.endHandleMovement);
      });

      return _this;
    }

    _createClass$p(Handle, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.removeDocumentEventListeners();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(_prevProps, prevState) {
        if (prevState.isMoving !== this.state.isMoving) {
          if (this.handleElement) this.handleElement.focus();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames;

        var _this$props3 = this.props,
            min = _this$props3.min,
            tickSizeRatio = _this$props3.tickSizeRatio,
            value = _this$props3.value,
            disabled = _this$props3.disabled,
            label = _this$props3.label;

        var _this$getHandleMidpoi2 = this.getHandleMidpointAndOffset(this.handleElement, true),
            handleMidpoint = _this$getHandleMidpoi2.handleMidpoint;

        var offsetRatio = (value - min) * tickSizeRatio;
        var offsetCalc = "calc(".concat(formatPercentage(offsetRatio), " - ").concat(handleMidpoint, "px)");
        var style = {
          left: offsetCalc
        };
        var className = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Slider-handle', true), _defineProperty$w(_classNames, 'Slider-handle--disabled', disabled), _defineProperty$w(_classNames, 'Slider-handle--active', this.state.isMoving), _classNames));
        return /*#__PURE__*/React.createElement("div", {
          className: className,
          onMouseDown: this.beginHandleMovement,
          onKeyDown: this.handleKeyDown,
          onKeyUp: this.handleKeyUp,
          ref: this.refHandlers.handle,
          style: style,
          tabIndex: 1
        }, !this.state.isMoving && /*#__PURE__*/React.createElement(Tooltip, {
          tooltip: label,
          position: "top",
          triggerClass: 'Slider-tooltip'
        }, /*#__PURE__*/React.createElement("span", {
          className: "h-100 w-100"
        })));
      }
    }]);

    return Handle;
  }(React.Component);

  var MultiSliderHandle = function MultiSliderHandle() {
    return null;
  };

  var MultiSlider = /*#__PURE__*/function (_React$Component) {
    _inherits$o(MultiSlider, _React$Component);

    var _super = _createSuper(MultiSlider);

    function MultiSlider(_props) {
      var _this;

      _classCallCheck$p(this, MultiSlider);

      _this = _super.call(this, _props);

      _defineProperty$w(_assertThisInitialized$p(_this), "handleElements", []);

      _defineProperty$w(_assertThisInitialized$p(_this), "trackElement", null);

      _defineProperty$w(_assertThisInitialized$p(_this), "getLabelPrecision", function (_ref) {
        var labelPrecision = _ref.labelPrecision,
            stepSize = _ref.stepSize;
        return labelPrecision == null ? countDecimalPlaces(stepSize) : labelPrecision;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getOffsetRatio", function (value) {
        return clamp((value - _this.props.min) * _this.state.tickSizeRatio, 0, 1);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "addHandleRef", function (ref) {
        if (ref != null) {
          _this.handleElements.push(ref);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getHandleValues", function (props) {
        var maybeHandles = React.Children.map(props.children, function (child) {
          return isElementOfType(child) ? child.props : null;
        });
        var handles = maybeHandles != null ? maybeHandles : [];
        handles = handles.filter(function (handle) {
          return handle !== null;
        });
        handles.sort(function (left, right) {
          return left.value - right.value;
        });
        return handles;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateTickSize", function () {
        if (_this.trackElement != null) {
          var trackSize = _this.trackElement.clientWidth;
          var tickSizeRatio = 1 / (_this.props.max - _this.props.min);
          var tickSize = trackSize * tickSizeRatio;

          _this.setState({
            tickSize: tickSize,
            tickSizeRatio: tickSizeRatio
          });
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getTrackFill", function (start, end) {
        if (start.fillAfter !== undefined) {
          return start.fillAfter;
        }

        if (end !== undefined && end.fillBefore !== undefined) {
          return end.fillBefore;
        }

        return false;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "maybeHandleTrackClick", function (event) {
        var target = event.target;
        var canHandleTrackEvent = !_this.props.disabled && target.closest('.Slider-handle') == null;

        if (canHandleTrackEvent) {
          var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {
            return handle.mouseEventClientOffset(event);
          });

          if (foundHandle) {
            foundHandle.beginHandleMovement(event);
          }
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getLockedHandleIndex", function (startIndex, endIndex) {
        var inc = startIndex < endIndex ? 1 : -1;

        for (var index = startIndex + inc; index !== endIndex + inc; index += inc) {
          return index;
        }

        return -1;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getNewHandleValues", function (newValue, oldIndex) {
        var handleProps = _this.getHandleValues(_this.props);

        var oldValues = handleProps.map(function (handle) {
          return handle.value;
        });
        var newValues = oldValues.slice();
        newValues[oldIndex] = newValue;
        if (newValues.length > 1) newValues.sort(function (left, right) {
          return left - right;
        });
        var newIndex = newValues.indexOf(newValue);

        var lockIndex = _this.getLockedHandleIndex(oldIndex, newIndex);

        if (lockIndex === -1) {
          fillValues(newValues, oldIndex, newIndex, newValue);
        } else {
          var lockValue = oldValues[lockIndex];
          fillValues(oldValues, oldIndex, lockIndex, lockValue);
          return oldValues;
        }

        return newValues;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onReleaseHandler", function (newValue, index) {
        var onRangeRelease = _this.props.onRangeRelease;

        var handleProps = _this.getHandleValues(_this.props);

        var newValues = _this.getNewHandleValues(newValue, index); // Range Slider callback


        if (onRangeRelease) {
          var range = newValues;
          onRangeRelease(range);
        } // Slider callback


        handleProps.forEach(function (handle, i) {
          if (handle.onRelease) handle.onRelease(newValues[i]);
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onChangeHandler", function (newValue, index) {
        var onRangeChange = _this.props.onRangeChange;

        var handleProps = _this.getHandleValues(_this.props);

        var oldValues = handleProps.map(function (handle) {
          return handle.value;
        });

        var newValues = _this.getNewHandleValues(newValue, index);

        if (!arraysEqual(newValues, oldValues)) {
          // Range Slider Callback
          if (onRangeChange) {
            var range = newValues;
            onRangeChange(range);
          } // Slider callback


          handleProps.forEach(function (handle, i) {
            if (handle.onChange) handle.onChange(newValues[i]);
          });
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderHandles", function () {
        var _this$props = _this.props,
            disabled = _this$props.disabled,
            max = _this$props.max,
            min = _this$props.min,
            stepSize = _this$props.stepSize;

        var handleProps = _this.getHandleValues(_this.props);

        if (handleProps.length === 0) {
          return null;
        }

        return handleProps.map(function (_ref2, index) {
          var value = _ref2.value;
          return /*#__PURE__*/React.createElement(Handle, {
            disabled: disabled,
            key: "".concat(index, "-").concat(handleProps.length),
            max: max,
            min: min,
            onRelease: function onRelease(newValue) {
              return _this.onReleaseHandler(newValue, index);
            },
            onChange: function onChange(newValue) {
              return _this.onChangeHandler(newValue, index);
            },
            label: value.toFixed(_this.state.labelPrecision),
            ref: _this.addHandleRef,
            stepSize: stepSize,
            tickSize: _this.state.tickSize,
            tickSizeRatio: _this.state.tickSizeRatio,
            value: value
          });
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "formatLabel", function (value) {
        var labelRenderer = _this.props.labelRenderer;

        if (typeof labelRenderer === 'function') {
          return labelRenderer(value);
        }

        return value.toFixed(_this.state.labelPrecision);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderLabels", function () {
        var _this$props2 = _this.props,
            labelStepSize = _this$props2.labelStepSize,
            max = _this$props2.max,
            min = _this$props2.min,
            labelRenderer = _this$props2.labelRenderer,
            disabled = _this$props2.disabled;
        var labels = [];
        var stepSizeRatio = _this.state.tickSizeRatio * labelStepSize;

        var handles = _this.getHandleValues(_this.props);

        var activeLabels = handles.map(function (handle) {
          return handle.value.toFixed(_this.state.labelPrecision);
        });

        for (var i = min, offsetRatio = 0; i < max || approxEqual(i, max); i += labelStepSize, offsetRatio += stepSizeRatio) {
          var offsetPercentage = formatPercentage(offsetRatio);
          var style = {
            left: offsetPercentage
          };
          var active = !disabled && activeLabels.indexOf(i.toFixed(_this.state.labelPrecision)) !== -1;
          labels.push( /*#__PURE__*/React.createElement("div", {
            className: 'Slider-label',
            key: i,
            style: style
          }, /*#__PURE__*/React.createElement("span", {
            className: 'Slider-ticks'
          }), labelRenderer !== false && /*#__PURE__*/React.createElement(Text$1, {
            size: "small",
            appearance: active ? 'default' : 'disabled'
          }, _this.formatLabel(i))));
        }

        return labels;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderTrackFill", function (index, start, end) {
        var _classNames;

        var _sort = [_this.getOffsetRatio(start.value), _this.getOffsetRatio(end.value)].sort(function (left, right) {
          return left - right;
        }),
            _sort2 = _slicedToArray$6(_sort, 2),
            startRatio = _sort2[0],
            endRatio = _sort2[1];

        var startOffset = Number((startRatio * 100).toFixed(2));
        var endOffset = Number(((1 - endRatio) * 100).toFixed(2));
        var width = "".concat(100 - endOffset - startOffset, "%");
        var orientationStyle = {
          width: width
        };

        var style = _objectSpread2({}, orientationStyle);

        var fillTrack = _this.getTrackFill(start, end);

        var classes = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Slider-progress', true), _defineProperty$w(_classNames, 'Slider-progress--disabled', _this.props.disabled), _defineProperty$w(_classNames, 'Slider-progress--inRange', fillTrack), _defineProperty$w(_classNames, 'Slider-progress--inRangeDisabled', fillTrack && _this.props.disabled), _classNames));
        return /*#__PURE__*/React.createElement("div", {
          key: "track-".concat(index),
          className: classes,
          style: style
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "renderTracks", function () {
        var trackStops = _this.getHandleValues(_this.props);

        trackStops.push({
          value: _this.props.max
        });
        var previous = {
          value: _this.props.min || 0
        };
        var handles = [];
        trackStops.forEach(function (track, index) {
          var current = track;
          handles.push(_this.renderTrackFill(index, previous, current));
          previous = current;
        });
        return handles;
      });

      _this.state = {
        labelPrecision: _this.getLabelPrecision(_this.props),
        tickSize: 0,
        tickSizeRatio: 0
      };
      return _this;
    }

    _createClass$p(MultiSlider, [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props) {
        return {
          labelPrecision: this.getLabelPrecision(props)
        };
      }
    }, {
      key: "getSnapshotBeforeUpdate",
      value: function getSnapshotBeforeUpdate(prevProps) {
        var prevHandleProps = this.getHandleValues(prevProps);
        var newHandleProps = this.getHandleValues(this.props);

        if (newHandleProps.length !== prevHandleProps.length) {
          this.handleElements = [];
        }

        return null;
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateTickSize();
      }
    }, {
      key: "nearestHandleForValue",
      value: function nearestHandleForValue(handles, getOffset) {
        return argMin(handles, function (handle) {
          var offset = getOffset(handle);
          var offsetValue = handle.clientToValue(offset);
          var handleValue = handle.props.value;
          return Math.abs(offsetValue - handleValue);
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames3,
            _this2 = this;

        var _this$props3 = this.props,
            label = _this$props3.label,
            className = _this$props3.className;
        var baseProps = extractBaseProps(this.props);
        var SliderClass = classnames(_defineProperty$w({}, 'Slider', true), className);
        var WrapperClass = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'Slider-wrapper', true), _defineProperty$w(_classNames3, 'Slider-wrapper--disabled', this.props.disabled), _classNames3));
        return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
          className: SliderClass
        }), label && /*#__PURE__*/React.createElement(Label, {
          withInput: true
        }, label), /*#__PURE__*/React.createElement("div", {
          className: WrapperClass,
          onMouseDown: this.maybeHandleTrackClick
        }, /*#__PURE__*/React.createElement("div", {
          className: "Slider-track",
          ref: function ref(_ref3) {
            return _this2.trackElement = _ref3;
          }
        }, this.renderTracks()), /*#__PURE__*/React.createElement("div", {
          className: "Slider-axis'"
        }, this.renderLabels()), this.renderHandles()));
      }
    }]);

    return MultiSlider;
  }(React.Component);

  _defineProperty$w(MultiSlider, "defaultProps", {
    labelStepSize: 1,
    max: 10,
    min: 0,
    stepSize: 1,
    labelRenderer: true
  });

  _defineProperty$w(MultiSlider, "Handle", MultiSliderHandle);

  var Slider = function Slider(props) {
    var valueProp = props.value,
        defaultValue = props.defaultValue,
        onRelease = props.onRelease,
        onChange = props.onChange,
        rest = _objectWithoutProperties$a(props, ["value", "defaultValue", "onRelease", "onChange"]);

    var _React$useState = React.useState(valueProp === undefined ? defaultValue : valueProp),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        value = _React$useState2[0],
        setValue = _React$useState2[1];

    React.useEffect(function () {
      if (valueProp !== undefined) {
        setValue(valueProp);
      }
    }, [valueProp]);

    var onChangeHandler = function onChangeHandler(newValue) {
      if (valueProp === undefined) {
        setValue(newValue);
      }

      if (onChange) onChange(newValue);
    };

    return /*#__PURE__*/React.createElement(MultiSlider, rest, /*#__PURE__*/React.createElement(MultiSlider.Handle, {
      value: value,
      onChange: onChangeHandler,
      onRelease: onRelease,
      fillBefore: true
    }));
  };
  Slider.displayName = 'Slider';
  Slider.defaultProps = _objectSpread2(_objectSpread2({}, MultiSlider.defaultProps), {}, {
    defaultValue: 0
  });

  var RangeIndex;

  (function (RangeIndex) {
    RangeIndex[RangeIndex["START"] = 0] = "START";
    RangeIndex[RangeIndex["END"] = 1] = "END";
  })(RangeIndex || (RangeIndex = {}));

  var RangeSlider = function RangeSlider(props) {
    var valueProp = props.value,
        defaultValue = props.defaultValue,
        onChange = props.onChange,
        onRelease = props.onRelease,
        rest = _objectWithoutProperties$a(props, ["value", "defaultValue", "onChange", "onRelease"]);

    var _React$useState = React.useState(valueProp === undefined ? defaultValue : valueProp),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        value = _React$useState2[0],
        setValue = _React$useState2[1];

    React.useEffect(function () {
      if (valueProp !== undefined) {
        setValue(valueProp);
      }
    }, [valueProp]);

    var onChangeHandler = function onChangeHandler(range) {
      if (valueProp === undefined) {
        setValue(range);
      }

      if (onChange) onChange(range);
    };

    return /*#__PURE__*/React.createElement(MultiSlider, _extends$p({
      onRangeChange: onChangeHandler,
      onRangeRelease: onRelease
    }, rest), /*#__PURE__*/React.createElement(MultiSlider.Handle, {
      value: value[RangeIndex.START],
      fillAfter: true
    }), /*#__PURE__*/React.createElement(MultiSlider.Handle, {
      value: value[RangeIndex.END]
    }));
  };
  RangeSlider.displayName = 'RangeSlider';
  RangeSlider.defaultProps = _objectSpread2(_objectSpread2({}, MultiSlider.defaultProps), {}, {
    defaultValue: [0, 10]
  });

  /**
   * ######Switch has two types:
   *  - [Controlled Switch](https://reactjs.org/docs/forms.html#controlled-components)
   *  - [Uncontrolled Switch](https://reactjs.org/docs/uncontrolled-components.html)
   */
  var Switch = /*#__PURE__*/React.forwardRef(function (props, ref) {
    var _classNames, _classNames2;

    var _props$size = props.size,
        size = _props$size === void 0 ? 'regular' : _props$size,
        _props$appearance = props.appearance,
        appearance = _props$appearance === void 0 ? 'primary' : _props$appearance,
        defaultChecked = props.defaultChecked,
        disabled = props.disabled,
        onChange = props.onChange,
        name = props.name,
        value = props.value,
        className = props.className;
    var baseProps = extractBaseProps(props);

    var _React$useState = React.useState(props.checked === undefined ? defaultChecked : props.checked),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        checked = _React$useState2[0],
        setChecked = _React$useState2[1];

    React.useEffect(function () {
      if (props.checked !== undefined) setChecked(props.checked);
    }, [props.checked]);
    var SwitchClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Switch', true), _defineProperty$w(_classNames, 'Switch--disabled', disabled), _defineProperty$w(_classNames, "Switch--".concat(size), size), _classNames), className);
    var SwitchWrapper = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Switch-wrapper', true), _defineProperty$w(_classNames2, 'Switch-wrapper--disabled', disabled), _defineProperty$w(_classNames2, "Switch-wrapper--".concat(size), size), _defineProperty$w(_classNames2, "Switch-wrapper--".concat(appearance), appearance), _defineProperty$w(_classNames2, 'Switch-wrapper--checked', checked), _defineProperty$w(_classNames2, 'Switch-wrapper--checkedDisabled', checked && disabled), _classNames2));

    var onChangeHandler = function onChangeHandler(event) {
      if (props.checked === undefined) setChecked(!checked);
      if (onChange) onChange(event, !checked);
    };

    return /*#__PURE__*/React.createElement("div", {
      className: SwitchClass
    }, /*#__PURE__*/React.createElement("input", _extends$p({}, baseProps, {
      type: "checkbox",
      defaultChecked: defaultChecked,
      disabled: disabled,
      onChange: onChangeHandler,
      checked: checked,
      ref: ref,
      name: name,
      value: value,
      className: "Switch-input"
    })), /*#__PURE__*/React.createElement("span", {
      className: SwitchWrapper
    }));
  });
  Switch.displayName = 'Switch';

  var Textarea = /*#__PURE__*/React.forwardRef(function (props, ref) {
    var _classNames2;

    var _props$rows = props.rows,
        rows = _props$rows === void 0 ? 3 : _props$rows,
        _props$resize = props.resize,
        resize = _props$resize === void 0 ? true : _props$resize,
        disabled = props.disabled,
        name = props.name,
        placeholder = props.placeholder,
        value = props.value,
        defaultValue = props.defaultValue,
        required = props.required,
        error = props.error,
        onChange = props.onChange,
        onClick = props.onClick,
        onBlur = props.onBlur,
        onFocus = props.onFocus,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames(_defineProperty$w({}, 'Textarea', true), className);
    var TextareaClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Textarea-textarea', true), _defineProperty$w(_classNames2, 'Textarea-textarea--resize', resize), _defineProperty$w(_classNames2, 'Textarea-textarea--error', error), _classNames2));
    return /*#__PURE__*/React.createElement("div", {
      className: classes
    }, /*#__PURE__*/React.createElement("textarea", _extends$p({
      "data-test": "DesignSystem-Textarea"
    }, baseProps, {
      ref: ref,
      name: name,
      rows: rows,
      placeholder: placeholder,
      className: TextareaClass,
      value: value,
      defaultValue: defaultValue,
      required: required,
      disabled: disabled,
      onChange: onChange,
      onBlur: onBlur,
      onClick: onClick,
      onFocus: onFocus
    })));
  });
  Textarea.displayName = 'Textarea';

  var ActionButton = function ActionButton(props) {
    var _classNames;

    var appearance = props.appearance,
        label = props.label,
        onClick = props.onClick;
    var buttonClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Button', true), _defineProperty$w(_classNames, 'Button--tiny', true), _defineProperty$w(_classNames, 'Toast-actionButton', true), _defineProperty$w(_classNames, "Toast-actionButton--".concat(appearance), appearance), _classNames));

    var onClickHandler = function onClickHandler(e) {
      e.preventDefault();
      if (onClick) onClick(e);
    };

    return /*#__PURE__*/React.createElement("button", {
      className: buttonClass,
      onClick: onClickHandler
    }, /*#__PURE__*/React.createElement(Text$1, {
      appearance: "white"
    }, label));
  };

  ActionButton.displayName = 'ActionButton';
  ActionButton.defaultProps = {
    appearance: 'default'
  };

  var Toast = function Toast(props) {
    var _classNames, _classNames2;

    var appearance = props.appearance,
        title = props.title,
        message = props.message,
        actions = props.actions,
        onClose = props.onClose,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var wrapperClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Toast', true), _defineProperty$w(_classNames, 'Toast--withMessage', message), _defineProperty$w(_classNames, "Toast--".concat(appearance), appearance), _classNames), className);
    var IconMapping = {
      info: 'info',
      success: 'check_circle',
      alert: 'error',
      warning: 'error'
    };
    var icon = IconMapping[appearance];
    var titleClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Toast-title', true), _defineProperty$w(_classNames2, 'Toast-title--withMessage', message), _classNames2));

    var iconClass = function iconClass(align) {
      var _classNames3;

      return classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'Toast-icon', true), _defineProperty$w(_classNames3, "Toast-icon--".concat(align), align), _classNames3));
    };

    var onCloseHandler = function onCloseHandler() {
      if (onClose) onClose();
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: wrapperClass
    }), icon && /*#__PURE__*/React.createElement("div", {
      className: iconClass('left')
    }, /*#__PURE__*/React.createElement(Icon, {
      name: icon,
      appearance: appearance !== 'warning' ? 'white' : 'default'
    })), /*#__PURE__*/React.createElement("div", {
      className: "Toast-body"
    }, /*#__PURE__*/React.createElement("div", {
      className: titleClass
    }, /*#__PURE__*/React.createElement(Heading, {
      size: "s",
      appearance: appearance !== 'warning' ? 'white' : 'default'
    }, title), /*#__PURE__*/React.createElement("div", {
      onClick: onCloseHandler
    }, /*#__PURE__*/React.createElement("div", {
      className: iconClass('right')
    }, /*#__PURE__*/React.createElement(Icon, {
      name: 'close',
      appearance: appearance !== 'warning' ? 'white' : 'default'
    })))), message && /*#__PURE__*/React.createElement("div", {
      className: "Toast-message"
    }, /*#__PURE__*/React.createElement(Text$1, {
      appearance: appearance !== 'warning' ? 'white' : 'default'
    }, message)), !!(actions !== null && actions !== void 0 && actions.length) && /*#__PURE__*/React.createElement("div", {
      className: "Toast-actions"
    }, actions.slice(0, 2).map(function (action, index) {
      return /*#__PURE__*/React.createElement(ActionButton, {
        key: index,
        label: action.label,
        appearance: appearance,
        onClick: action.onClick
      });
    }))));
  };
  Toast.displayName = 'Toast';
  Toast.defaultProps = {
    appearance: 'default'
  };

  var objectWithoutPropertiesLoose = createCommonjsModule(function (module) {
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  module.exports = _objectWithoutPropertiesLoose;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _objectWithoutPropertiesLoose = unwrapExports(objectWithoutPropertiesLoose);

  var _extends_1 = createCommonjsModule(function (module) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _extends$1 = unwrapExports(_extends_1);

  var setPrototypeOf = createCommonjsModule(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  unwrapExports(setPrototypeOf);

  var inheritsLoose = createCommonjsModule(function (module) {
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }

  module.exports = _inheritsLoose;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _inheritsLoose = unwrapExports(inheritsLoose);

  var assertThisInitialized = createCommonjsModule(function (module) {
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  module.exports = _assertThisInitialized;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _assertThisInitialized = unwrapExports(assertThisInitialized);

  var defineProperty$3 = createCommonjsModule(function (module) {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  module.exports = _defineProperty;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _defineProperty = unwrapExports(defineProperty$3);

  var toStr$4 = Object.prototype.toString;

  var isArguments$1 = function isArguments(value) {
  	var str = toStr$4.call(value);
  	var isArgs = str === '[object Arguments]';
  	if (!isArgs) {
  		isArgs = str !== '[object Array]' &&
  			value !== null &&
  			typeof value === 'object' &&
  			typeof value.length === 'number' &&
  			value.length >= 0 &&
  			toStr$4.call(value.callee) === '[object Function]';
  	}
  	return isArgs;
  };

  var keysShim$1;
  if (!Object.keys) {
  	// modified from https://github.com/es-shims/es5-shim
  	var has$1 = Object.prototype.hasOwnProperty;
  	var toStr$3 = Object.prototype.toString;
  	var isArgs = isArguments$1; // eslint-disable-line global-require
  	var isEnumerable = Object.prototype.propertyIsEnumerable;
  	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
  	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  	var dontEnums = [
  		'toString',
  		'toLocaleString',
  		'valueOf',
  		'hasOwnProperty',
  		'isPrototypeOf',
  		'propertyIsEnumerable',
  		'constructor'
  	];
  	var equalsConstructorPrototype = function (o) {
  		var ctor = o.constructor;
  		return ctor && ctor.prototype === o;
  	};
  	var excludedKeys = {
  		$applicationCache: true,
  		$console: true,
  		$external: true,
  		$frame: true,
  		$frameElement: true,
  		$frames: true,
  		$innerHeight: true,
  		$innerWidth: true,
  		$onmozfullscreenchange: true,
  		$onmozfullscreenerror: true,
  		$outerHeight: true,
  		$outerWidth: true,
  		$pageXOffset: true,
  		$pageYOffset: true,
  		$parent: true,
  		$scrollLeft: true,
  		$scrollTop: true,
  		$scrollX: true,
  		$scrollY: true,
  		$self: true,
  		$webkitIndexedDB: true,
  		$webkitStorageInfo: true,
  		$window: true
  	};
  	var hasAutomationEqualityBug = (function () {
  		/* global window */
  		if (typeof window === 'undefined') { return false; }
  		for (var k in window) {
  			try {
  				if (!excludedKeys['$' + k] && has$1.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
  					try {
  						equalsConstructorPrototype(window[k]);
  					} catch (e) {
  						return true;
  					}
  				}
  			} catch (e) {
  				return true;
  			}
  		}
  		return false;
  	}());
  	var equalsConstructorPrototypeIfNotBuggy = function (o) {
  		/* global window */
  		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
  			return equalsConstructorPrototype(o);
  		}
  		try {
  			return equalsConstructorPrototype(o);
  		} catch (e) {
  			return false;
  		}
  	};

  	keysShim$1 = function keys(object) {
  		var isObject = object !== null && typeof object === 'object';
  		var isFunction = toStr$3.call(object) === '[object Function]';
  		var isArguments = isArgs(object);
  		var isString = isObject && toStr$3.call(object) === '[object String]';
  		var theKeys = [];

  		if (!isObject && !isFunction && !isArguments) {
  			throw new TypeError('Object.keys called on a non-object');
  		}

  		var skipProto = hasProtoEnumBug && isFunction;
  		if (isString && object.length > 0 && !has$1.call(object, 0)) {
  			for (var i = 0; i < object.length; ++i) {
  				theKeys.push(String(i));
  			}
  		}

  		if (isArguments && object.length > 0) {
  			for (var j = 0; j < object.length; ++j) {
  				theKeys.push(String(j));
  			}
  		} else {
  			for (var name in object) {
  				if (!(skipProto && name === 'prototype') && has$1.call(object, name)) {
  					theKeys.push(String(name));
  				}
  			}
  		}

  		if (hasDontEnumBug) {
  			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

  			for (var k = 0; k < dontEnums.length; ++k) {
  				if (!(skipConstructor && dontEnums[k] === 'constructor') && has$1.call(object, dontEnums[k])) {
  					theKeys.push(dontEnums[k]);
  				}
  			}
  		}
  		return theKeys;
  	};
  }
  var implementation$4 = keysShim$1;

  var slice$1 = Array.prototype.slice;


  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o) { return origKeys(o); } : implementation$4;

  var originalKeys = Object.keys;

  keysShim.shim = function shimObjectKeys() {
  	if (Object.keys) {
  		var keysWorksWithArguments = (function () {
  			// Safari 5.0 bug
  			var args = Object.keys(arguments);
  			return args && args.length === arguments.length;
  		}(1, 2));
  		if (!keysWorksWithArguments) {
  			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
  				if (isArguments$1(object)) {
  					return originalKeys(slice$1.call(object));
  				}
  				return originalKeys(object);
  			};
  		}
  	} else {
  		Object.keys = keysShim;
  	}
  	return Object.keys || keysShim;
  };

  var objectKeys = keysShim;

  /* eslint complexity: [2, 18], max-statements: [2, 33] */
  var shams = function hasSymbols() {
  	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
  	if (typeof Symbol.iterator === 'symbol') { return true; }

  	var obj = {};
  	var sym = Symbol('test');
  	var symObj = Object(sym);
  	if (typeof sym === 'string') { return false; }

  	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
  	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

  	// temp disabled per https://github.com/ljharb/object.assign/issues/17
  	// if (sym instanceof Symbol) { return false; }
  	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  	// if (!(symObj instanceof Symbol)) { return false; }

  	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
  	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  	var symVal = 42;
  	obj[sym] = symVal;
  	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
  	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

  	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

  	var syms = Object.getOwnPropertySymbols(obj);
  	if (syms.length !== 1 || syms[0] !== sym) { return false; }

  	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

  	if (typeof Object.getOwnPropertyDescriptor === 'function') {
  		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
  		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
  	}

  	return true;
  };

  var origSymbol = typeof Symbol !== 'undefined' && Symbol;


  var hasSymbols$3 = function hasNativeSymbols() {
  	if (typeof origSymbol !== 'function') { return false; }
  	if (typeof Symbol !== 'function') { return false; }
  	if (typeof origSymbol('foo') !== 'symbol') { return false; }
  	if (typeof Symbol('bar') !== 'symbol') { return false; }

  	return shams();
  };

  /* eslint no-invalid-this: 1 */

  var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
  var slice = Array.prototype.slice;
  var toStr$2 = Object.prototype.toString;
  var funcType = '[object Function]';

  var implementation$3 = function bind(that) {
      var target = this;
      if (typeof target !== 'function' || toStr$2.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);

      var bound;
      var binder = function () {
          if (this instanceof bound) {
              var result = target.apply(
                  this,
                  args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return this;
          } else {
              return target.apply(
                  that,
                  args.concat(slice.call(arguments))
              );
          }
      };

      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
          boundArgs.push('$' + i);
      }

      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

      if (target.prototype) {
          var Empty = function Empty() {};
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
      }

      return bound;
  };

  var functionBind = Function.prototype.bind || implementation$3;

  var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

  var undefined$1;

  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError$2 = TypeError;

  // eslint-disable-next-line consistent-return
  var getEvalledConstructor = function (expressionSyntax) {
  	try {
  		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  	} catch (e) {}
  };

  var $gOPD$1 = Object.getOwnPropertyDescriptor;
  if ($gOPD$1) {
  	try {
  		$gOPD$1({}, '');
  	} catch (e) {
  		$gOPD$1 = null; // this is IE 8, which has a broken gOPD
  	}
  }

  var throwTypeError = function () {
  	throw new $TypeError$2();
  };
  var ThrowTypeError = $gOPD$1
  	? (function () {
  		try {
  			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
  			arguments.callee; // IE 8 does not throw here
  			return throwTypeError;
  		} catch (calleeThrows) {
  			try {
  				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
  				return $gOPD$1(arguments, 'callee').get;
  			} catch (gOPDthrows) {
  				return throwTypeError;
  			}
  		}
  	}())
  	: throwTypeError;

  var hasSymbols$2 = hasSymbols$3();

  var getProto$1 = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

  var needsEval = {};

  var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto$1(Uint8Array);

  var INTRINSICS = {
  	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
  	'%Array%': Array,
  	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
  	'%ArrayIteratorPrototype%': hasSymbols$2 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  	'%AsyncFromSyncIteratorPrototype%': undefined$1,
  	'%AsyncFunction%': needsEval,
  	'%AsyncGenerator%': needsEval,
  	'%AsyncGeneratorFunction%': needsEval,
  	'%AsyncIteratorPrototype%': needsEval,
  	'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
  	'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
  	'%Boolean%': Boolean,
  	'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
  	'%Date%': Date,
  	'%decodeURI%': decodeURI,
  	'%decodeURIComponent%': decodeURIComponent,
  	'%encodeURI%': encodeURI,
  	'%encodeURIComponent%': encodeURIComponent,
  	'%Error%': Error,
  	'%eval%': eval, // eslint-disable-line no-eval
  	'%EvalError%': EvalError,
  	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
  	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
  	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
  	'%Function%': $Function,
  	'%GeneratorFunction%': needsEval,
  	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
  	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
  	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
  	'%isFinite%': isFinite,
  	'%isNaN%': isNaN,
  	'%IteratorPrototype%': hasSymbols$2 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  	'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
  	'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
  	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$2 ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
  	'%Math%': Math,
  	'%Number%': Number,
  	'%Object%': Object,
  	'%parseFloat%': parseFloat,
  	'%parseInt%': parseInt,
  	'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
  	'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
  	'%RangeError%': RangeError,
  	'%ReferenceError%': ReferenceError,
  	'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
  	'%RegExp%': RegExp,
  	'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
  	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$2 ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
  	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
  	'%String%': String,
  	'%StringIteratorPrototype%': hasSymbols$2 ? getProto$1(''[Symbol.iterator]()) : undefined$1,
  	'%Symbol%': hasSymbols$2 ? Symbol : undefined$1,
  	'%SyntaxError%': $SyntaxError,
  	'%ThrowTypeError%': ThrowTypeError,
  	'%TypedArray%': TypedArray,
  	'%TypeError%': $TypeError$2,
  	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
  	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
  	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
  	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
  	'%URIError%': URIError,
  	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
  	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
  	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
  };

  var doEval = function doEval(name) {
  	var value;
  	if (name === '%AsyncFunction%') {
  		value = getEvalledConstructor('async function () {}');
  	} else if (name === '%GeneratorFunction%') {
  		value = getEvalledConstructor('function* () {}');
  	} else if (name === '%AsyncGeneratorFunction%') {
  		value = getEvalledConstructor('async function* () {}');
  	} else if (name === '%AsyncGenerator%') {
  		var fn = doEval('%AsyncGeneratorFunction%');
  		if (fn) {
  			value = fn.prototype;
  		}
  	} else if (name === '%AsyncIteratorPrototype%') {
  		var gen = doEval('%AsyncGenerator%');
  		if (gen) {
  			value = getProto$1(gen.prototype);
  		}
  	}

  	INTRINSICS[name] = value;

  	return value;
  };

  var LEGACY_ALIASES = {
  	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  	'%ArrayPrototype%': ['Array', 'prototype'],
  	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
  	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  	'%BooleanPrototype%': ['Boolean', 'prototype'],
  	'%DataViewPrototype%': ['DataView', 'prototype'],
  	'%DatePrototype%': ['Date', 'prototype'],
  	'%ErrorPrototype%': ['Error', 'prototype'],
  	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
  	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  	'%FunctionPrototype%': ['Function', 'prototype'],
  	'%Generator%': ['GeneratorFunction', 'prototype'],
  	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  	'%JSONParse%': ['JSON', 'parse'],
  	'%JSONStringify%': ['JSON', 'stringify'],
  	'%MapPrototype%': ['Map', 'prototype'],
  	'%NumberPrototype%': ['Number', 'prototype'],
  	'%ObjectPrototype%': ['Object', 'prototype'],
  	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  	'%PromisePrototype%': ['Promise', 'prototype'],
  	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  	'%Promise_all%': ['Promise', 'all'],
  	'%Promise_reject%': ['Promise', 'reject'],
  	'%Promise_resolve%': ['Promise', 'resolve'],
  	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
  	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  	'%RegExpPrototype%': ['RegExp', 'prototype'],
  	'%SetPrototype%': ['Set', 'prototype'],
  	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  	'%StringPrototype%': ['String', 'prototype'],
  	'%SymbolPrototype%': ['Symbol', 'prototype'],
  	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
  	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  	'%URIErrorPrototype%': ['URIError', 'prototype'],
  	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
  	'%WeakSetPrototype%': ['WeakSet', 'prototype']
  };



  var $concat = functionBind.call(Function.call, Array.prototype.concat);
  var $spliceApply = functionBind.call(Function.apply, Array.prototype.splice);
  var $replace = functionBind.call(Function.call, String.prototype.replace);
  var $strSlice = functionBind.call(Function.call, String.prototype.slice);

  /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
  var stringToPath = function stringToPath(string) {
  	var first = $strSlice(string, 0, 1);
  	var last = $strSlice(string, -1);
  	if (first === '%' && last !== '%') {
  		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  	} else if (last === '%' && first !== '%') {
  		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  	}
  	var result = [];
  	$replace(string, rePropName, function (match, number, quote, subString) {
  		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  	});
  	return result;
  };
  /* end adaptation */

  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  	var intrinsicName = name;
  	var alias;
  	if (src(LEGACY_ALIASES, intrinsicName)) {
  		alias = LEGACY_ALIASES[intrinsicName];
  		intrinsicName = '%' + alias[0] + '%';
  	}

  	if (src(INTRINSICS, intrinsicName)) {
  		var value = INTRINSICS[intrinsicName];
  		if (value === needsEval) {
  			value = doEval(intrinsicName);
  		}
  		if (typeof value === 'undefined' && !allowMissing) {
  			throw new $TypeError$2('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
  		}

  		return {
  			alias: alias,
  			name: intrinsicName,
  			value: value
  		};
  	}

  	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
  };

  var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  	if (typeof name !== 'string' || name.length === 0) {
  		throw new $TypeError$2('intrinsic name must be a non-empty string');
  	}
  	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
  		throw new $TypeError$2('"allowMissing" argument must be a boolean');
  	}

  	var parts = stringToPath(name);
  	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

  	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  	var intrinsicRealName = intrinsic.name;
  	var value = intrinsic.value;
  	var skipFurtherCaching = false;

  	var alias = intrinsic.alias;
  	if (alias) {
  		intrinsicBaseName = alias[0];
  		$spliceApply(parts, $concat([0, 1], alias));
  	}

  	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
  		var part = parts[i];
  		var first = $strSlice(part, 0, 1);
  		var last = $strSlice(part, -1);
  		if (
  			(
  				(first === '"' || first === "'" || first === '`')
  				|| (last === '"' || last === "'" || last === '`')
  			)
  			&& first !== last
  		) {
  			throw new $SyntaxError('property names with quotes must have matching quotes');
  		}
  		if (part === 'constructor' || !isOwn) {
  			skipFurtherCaching = true;
  		}

  		intrinsicBaseName += '.' + part;
  		intrinsicRealName = '%' + intrinsicBaseName + '%';

  		if (src(INTRINSICS, intrinsicRealName)) {
  			value = INTRINSICS[intrinsicRealName];
  		} else if (value != null) {
  			if (!(part in value)) {
  				if (!allowMissing) {
  					throw new $TypeError$2('base intrinsic for ' + name + ' exists, but the property is not available.');
  				}
  				return void undefined$1;
  			}
  			if ($gOPD$1 && (i + 1) >= parts.length) {
  				var desc = $gOPD$1(value, part);
  				isOwn = !!desc;

  				// By convention, when a data property is converted to an accessor
  				// property to emulate a data property that does not suffer from
  				// the override mistake, that accessor's getter is marked with
  				// an `originalValue` property. Here, when we detect this, we
  				// uphold the illusion by pretending to see that original data
  				// property, i.e., returning the value rather than the getter
  				// itself.
  				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
  					value = desc.get;
  				} else {
  					value = value[part];
  				}
  			} else {
  				isOwn = src(value, part);
  				value = value[part];
  			}

  			if (isOwn && !skipFurtherCaching) {
  				INTRINSICS[intrinsicRealName] = value;
  			}
  		}
  	}
  	return value;
  };

  var callBind = createCommonjsModule(function (module) {




  var $apply = getIntrinsic('%Function.prototype.apply%');
  var $call = getIntrinsic('%Function.prototype.call%');
  var $reflectApply = getIntrinsic('%Reflect.apply%', true) || functionBind.call($call, $apply);

  var $gOPD = getIntrinsic('%Object.getOwnPropertyDescriptor%', true);
  var $defineProperty = getIntrinsic('%Object.defineProperty%', true);
  var $max = getIntrinsic('%Math.max%');

  if ($defineProperty) {
  	try {
  		$defineProperty({}, 'a', { value: 1 });
  	} catch (e) {
  		// IE 8 has a broken defineProperty
  		$defineProperty = null;
  	}
  }

  module.exports = function callBind(originalFunction) {
  	var func = $reflectApply(functionBind, $call, arguments);
  	if ($gOPD && $defineProperty) {
  		var desc = $gOPD(func, 'length');
  		if (desc.configurable) {
  			// original length, plus the receiver, minus any additional arguments (after the receiver)
  			$defineProperty(
  				func,
  				'length',
  				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
  			);
  		}
  	}
  	return func;
  };

  var applyBind = function applyBind() {
  	return $reflectApply(functionBind, $apply, arguments);
  };

  if ($defineProperty) {
  	$defineProperty(module.exports, 'apply', { value: applyBind });
  } else {
  	module.exports.apply = applyBind;
  }
  });
  callBind.apply;

  var $indexOf = callBind(getIntrinsic('String.prototype.indexOf'));

  var callBound = function callBoundIntrinsic(name, allowMissing) {
  	var intrinsic = getIntrinsic(name, !!allowMissing);
  	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
  		return callBind(intrinsic);
  	}
  	return intrinsic;
  };

  var hasToStringTag$2 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';


  var $toString$1 = callBound('Object.prototype.toString');

  var isStandardArguments = function isArguments(value) {
  	if (hasToStringTag$2 && value && typeof value === 'object' && Symbol.toStringTag in value) {
  		return false;
  	}
  	return $toString$1(value) === '[object Arguments]';
  };

  var isLegacyArguments = function isArguments(value) {
  	if (isStandardArguments(value)) {
  		return true;
  	}
  	return value !== null &&
  		typeof value === 'object' &&
  		typeof value.length === 'number' &&
  		value.length >= 0 &&
  		$toString$1(value) !== '[object Array]' &&
  		$toString$1(value.callee) === '[object Function]';
  };

  var supportsStandardArguments = (function () {
  	return isStandardArguments(arguments);
  }());

  isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

  var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

  var hasSymbols$1 = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

  var toStr$1 = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var origDefineProperty = Object.defineProperty;

  var isFunction$1 = function (fn) {
  	return typeof fn === 'function' && toStr$1.call(fn) === '[object Function]';
  };

  var arePropertyDescriptorsSupported = function () {
  	var obj = {};
  	try {
  		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
  		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
  		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
  			return false;
  		}
  		return obj.x === obj;
  	} catch (e) { /* this is IE 8. */
  		return false;
  	}
  };
  var supportsDescriptors$2 = origDefineProperty && arePropertyDescriptorsSupported();

  var defineProperty$2 = function (object, name, value, predicate) {
  	if (name in object && (!isFunction$1(predicate) || !predicate())) {
  		return;
  	}
  	if (supportsDescriptors$2) {
  		origDefineProperty(object, name, {
  			configurable: true,
  			enumerable: false,
  			value: value,
  			writable: true
  		});
  	} else {
  		object[name] = value;
  	}
  };

  var defineProperties = function (object, map) {
  	var predicates = arguments.length > 2 ? arguments[2] : {};
  	var props = objectKeys(map);
  	if (hasSymbols$1) {
  		props = concat.call(props, Object.getOwnPropertySymbols(map));
  	}
  	for (var i = 0; i < props.length; i += 1) {
  		defineProperty$2(object, props[i], map[props[i]], predicates[props[i]]);
  	}
  };

  defineProperties.supportsDescriptors = !!supportsDescriptors$2;

  var defineProperties_1 = defineProperties;

  var numberIsNaN = function (value) {
  	return value !== value;
  };

  var implementation$2 = function is(a, b) {
  	if (a === 0 && b === 0) {
  		return 1 / a === 1 / b;
  	}
  	if (a === b) {
  		return true;
  	}
  	if (numberIsNaN(a) && numberIsNaN(b)) {
  		return true;
  	}
  	return false;
  };

  var polyfill$2 = function getPolyfill() {
  	return typeof Object.is === 'function' ? Object.is : implementation$2;
  };

  var shim$1 = function shimObjectIs() {
  	var polyfill = polyfill$2();
  	defineProperties_1(Object, { is: polyfill }, {
  		is: function testObjectIs() {
  			return Object.is !== polyfill;
  		}
  	});
  	return polyfill;
  };

  var polyfill$1 = callBind(polyfill$2(), Object);

  defineProperties_1(polyfill$1, {
  	getPolyfill: polyfill$2,
  	implementation: implementation$2,
  	shim: shim$1
  });

  var objectIs = polyfill$1;

  var hasSymbols = hasSymbols$3();
  var hasToStringTag$1 = hasSymbols && typeof Symbol.toStringTag === 'symbol';
  var has;
  var $exec;
  var isRegexMarker;
  var badStringifier;

  if (hasToStringTag$1) {
  	has = callBound('Object.prototype.hasOwnProperty');
  	$exec = callBound('RegExp.prototype.exec');
  	isRegexMarker = {};

  	var throwRegexMarker = function () {
  		throw isRegexMarker;
  	};
  	badStringifier = {
  		toString: throwRegexMarker,
  		valueOf: throwRegexMarker
  	};

  	if (typeof Symbol.toPrimitive === 'symbol') {
  		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  	}
  }

  var $toString = callBound('Object.prototype.toString');
  var gOPD$1 = Object.getOwnPropertyDescriptor;
  var regexClass = '[object RegExp]';

  var isRegex = hasToStringTag$1
  	// eslint-disable-next-line consistent-return
  	? function isRegex(value) {
  		if (!value || typeof value !== 'object') {
  			return false;
  		}

  		var descriptor = gOPD$1(value, 'lastIndex');
  		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
  		if (!hasLastIndexDataProperty) {
  			return false;
  		}

  		try {
  			$exec(value, badStringifier);
  		} catch (e) {
  			return e === isRegexMarker;
  		}
  	}
  	: function isRegex(value) {
  		// In older browsers, typeof regex incorrectly returns 'function'
  		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
  			return false;
  		}

  		return $toString(value) === regexClass;
  	};

  var $Object = Object;
  var $TypeError$1 = TypeError;

  var implementation$1 = function flags() {
  	if (this != null && this !== $Object(this)) {
  		throw new $TypeError$1('RegExp.prototype.flags getter called on non-object');
  	}
  	var result = '';
  	if (this.global) {
  		result += 'g';
  	}
  	if (this.ignoreCase) {
  		result += 'i';
  	}
  	if (this.multiline) {
  		result += 'm';
  	}
  	if (this.dotAll) {
  		result += 's';
  	}
  	if (this.unicode) {
  		result += 'u';
  	}
  	if (this.sticky) {
  		result += 'y';
  	}
  	return result;
  };

  var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
  var $gOPD = Object.getOwnPropertyDescriptor;
  var $TypeError = TypeError;

  var polyfill = function getPolyfill() {
  	if (!supportsDescriptors$1) {
  		throw new $TypeError('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
  	}
  	if ((/a/mig).flags === 'gim') {
  		var descriptor = $gOPD(RegExp.prototype, 'flags');
  		if (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {
  			return descriptor.get;
  		}
  	}
  	return implementation$1;
  };

  var supportsDescriptors = defineProperties_1.supportsDescriptors;

  var gOPD = Object.getOwnPropertyDescriptor;
  var defineProperty$1 = Object.defineProperty;
  var TypeErr = TypeError;
  var getProto = Object.getPrototypeOf;
  var regex = /a/;

  var shim = function shimFlags() {
  	if (!supportsDescriptors || !getProto) {
  		throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
  	}
  	var polyfill$1 = polyfill();
  	var proto = getProto(regex);
  	var descriptor = gOPD(proto, 'flags');
  	if (!descriptor || descriptor.get !== polyfill$1) {
  		defineProperty$1(proto, 'flags', {
  			configurable: true,
  			enumerable: false,
  			get: polyfill$1
  		});
  	}
  	return polyfill$1;
  };

  var flagsBound = callBind(implementation$1);

  defineProperties_1(flagsBound, {
  	getPolyfill: polyfill,
  	implementation: implementation$1,
  	shim: shim
  });

  var regexp_prototype_flags = flagsBound;

  var getDay = Date.prototype.getDay;
  var tryDateObject = function tryDateGetDayCall(value) {
  	try {
  		getDay.call(value);
  		return true;
  	} catch (e) {
  		return false;
  	}
  };

  var toStr = Object.prototype.toString;
  var dateClass = '[object Date]';
  var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

  var isDateObject = function isDateObject(value) {
  	if (typeof value !== 'object' || value === null) {
  		return false;
  	}
  	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
  };

  var getTime = Date.prototype.getTime;

  function deepEqual(actual, expected, options) {
    var opts = options || {};

    // 7.1. All identical values are equivalent, as determined by ===.
    if (opts.strict ? objectIs(actual, expected) : actual === expected) {
      return true;
    }

    // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
    if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
      return opts.strict ? objectIs(actual, expected) : actual == expected;
    }

    /*
     * 7.4. For all other Object pairs, including Array objects, equivalence is
     * determined by having the same number of owned properties (as verified
     * with Object.prototype.hasOwnProperty.call), the same set of keys
     * (although not necessarily the same order), equivalent values for every
     * corresponding key, and an identical 'prototype' property. Note: this
     * accounts for both named and indexed properties on Arrays.
     */
    // eslint-disable-next-line no-use-before-define
    return objEquiv(actual, expected, opts);
  }

  function isUndefinedOrNull(value) {
    return value === null || value === undefined;
  }

  function isBuffer(x) {
    if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
      return false;
    }
    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
      return false;
    }
    if (x.length > 0 && typeof x[0] !== 'number') {
      return false;
    }
    return true;
  }

  function objEquiv(a, b, opts) {
    /* eslint max-statements: [2, 50] */
    var i, key;
    if (typeof a !== typeof b) { return false; }
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }

    // an identical 'prototype' property.
    if (a.prototype !== b.prototype) { return false; }

    if (isArguments(a) !== isArguments(b)) { return false; }

    var aIsRegex = isRegex(a);
    var bIsRegex = isRegex(b);
    if (aIsRegex !== bIsRegex) { return false; }
    if (aIsRegex || bIsRegex) {
      return a.source === b.source && regexp_prototype_flags(a) === regexp_prototype_flags(b);
    }

    if (isDateObject(a) && isDateObject(b)) {
      return getTime.call(a) === getTime.call(b);
    }

    var aIsBuffer = isBuffer(a);
    var bIsBuffer = isBuffer(b);
    if (aIsBuffer !== bIsBuffer) { return false; }
    if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
      if (a.length !== b.length) { return false; }
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) { return false; }
      }
      return true;
    }

    if (typeof a !== typeof b) { return false; }

    try {
      var ka = objectKeys(a);
      var kb = objectKeys(b);
    } catch (e) { // happens when one is a string literal and the other isn't
      return false;
    }
    // having the same number of owned properties (keys incorporates hasOwnProperty)
    if (ka.length !== kb.length) { return false; }

    // the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    // ~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i]) { return false; }
    }
    // equivalent values for every corresponding key, and ~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!deepEqual(a[key], b[key], opts)) { return false; }
    }

    return true;
  }

  var deepEqual_1 = deepEqual;

  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

  var timeoutDuration = function () {
    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        return 1;
      }
    }
    return 0;
  }();

  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  var supportsMicroTasks = isBrowser && window.Promise;

  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }

  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }

  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }

  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */
  function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }

    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent(getParentNode(element));
  }

  /**
   * Returns the reference node of the reference object, or the reference object itself.
   * @method
   * @memberof Popper.Utils
   * @param {Element|Object} reference - the reference element (the popper will be relative to this)
   * @returns {Element} parent
   */
  function getReferenceNode(reference) {
    return reference && reference.referenceNode ? reference.referenceNode : reference;
  }

  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   */
  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }

  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }

    var noOffsetParent = isIE(10) ? document.body : null;

    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent || null;
    // Skip hidden elements which don't have an offsetParent
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }

    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }

    // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }

  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }

  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }

  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }

  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }

  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */

  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
  }

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }

  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);

    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();





  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */
  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }

  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.width;
    var height = sizes.height || element.clientHeight || result.height;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');

      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth);

    // In cases where the parent is fixed, we must ignore negative scroll in offset calc
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop);
      var marginLeft = parseFloat(styles.marginLeft);

      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;

      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };

    return getClientRect(offset);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }

  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   */

  function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   */
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    // NOTE: 1 DOM access here

    var boundaries = { top: 0, left: 0 };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

    // Handle viewport case
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }

    // Add paddings
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;

    return width * height;
  }

  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };

    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });

    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split('-')[1];

    return computedPlacement + (variation ? '-' + variation : '');
  }

  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }

  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }

  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }

  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }

  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);

        data = fn(data, modifier);
      }
    });

    return data;
  }

  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    data.positionFixed = this.options.positionFixed;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }

  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }

  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   */
  function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners();

    // remove the popper if user explicitly asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }

  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, { passive: true });

    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
  }

  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }

  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }

  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      // add unit if the value is numeric and is one of the following
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if arrowElement is defined and arrowStyles has some properties
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
  }

  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   */
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

    popper.setAttribute('x-placement', placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

    return options;
  }

  /**
   * @function
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Boolean} shouldRound - If the offsets should be rounded at all
   * @returns {Object} The popper's position offsets rounded
   *
   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
   * good as it can be within reason.
   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
   *
   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
   * as well on High DPI screens).
   *
   * Firefox prefers no rounding for positioning and does not have blurriness on
   * high DPI screens.
   *
   * Only horizontal placement and left/right values need to be considered.
   */
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;

    var noRound = function noRound(v) {
      return v;
    };

    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);

    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;

    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }

  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
      position: popper.position
    };

    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }

    // Attributes
    var attributes = {
      'x-placement': data.placement
    };

    // Update `data` attributes, styles and arrowStyles
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

    return data;
  }

  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });

    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function arrow(data, options) {
    var _data$offsets$arrow;

    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);

      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

    return data;
  }

  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }

  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements.slice(3);

  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';

    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);

      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;

      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

      // flip the variation if required
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

      // flips variation if reference element overflows boundaries
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

      // flips variation if popper content overflows boundaries
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

      var flippedVariation = flippedVariationByRef || flippedVariationByContent;

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : '');

        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }

  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }

  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var basePlacement = placement.split('-')[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }

    // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];

    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

    // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;

    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };

    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;

      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };

      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
  }

  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries"  or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: 'flip',
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: 'viewport',
      /**
       * @prop {Boolean} flipVariations=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the reference element overlaps its boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariations: false,
      /**
       * @prop {Boolean} flipVariationsByContent=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the popper element overlaps its reference boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariationsByContent: false
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: undefined
    }
  };

  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overridden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */
  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
  };

  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */

  // Utils
  // Methods
  var Popper$1 = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };

      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce(this.update.bind(this));

      // with {} we create a new object with the options inside it
      this.options = _extends({}, Popper.Defaults, options);

      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };

      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;

      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });

      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      })
      // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      });

      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });

      // fire the first update to position the popper in the right place
      this.update();

      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }

      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */


      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }]);
    return Popper;
  }();

  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */


  Popper$1.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper$1.placements = placements;
  Popper$1.Defaults = Defaults;

  var key = '__global_unique_id__';

  var gud = function() {
    return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
  };

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var warning = function() {};

  var warning_1 = warning;

  var implementation = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  _interopRequireDefault(React__default['default']);



  var _propTypes2 = _interopRequireDefault(propTypes$5);



  var _gud2 = _interopRequireDefault(gud);



  _interopRequireDefault(warning_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var MAX_SIGNED_31_BIT_INT = 1073741823;

  // Inlined Object.is polyfill.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  function objectIs(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }

  function createEventEmitter(value) {
    var handlers = [];
    return {
      on: function on(handler) {
        handlers.push(handler);
      },
      off: function off(handler) {
        handlers = handlers.filter(function (h) {
          return h !== handler;
        });
      },
      get: function get() {
        return value;
      },
      set: function set(newValue, changedBits) {
        value = newValue;
        handlers.forEach(function (handler) {
          return handler(value, changedBits);
        });
      }
    };
  }

  function onlyChild(children) {
    return Array.isArray(children) ? children[0] : children;
  }

  function createReactContext(defaultValue, calculateChangedBits) {
    var _Provider$childContex, _Consumer$contextType;

    var contextProp = '__create-react-context-' + (0, _gud2.default)() + '__';

    var Provider = function (_Component) {
      _inherits(Provider, _Component);

      function Provider() {
        var _temp, _this, _ret;

        _classCallCheck(this, Provider);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
      }

      Provider.prototype.getChildContext = function getChildContext() {
        var _ref;

        return _ref = {}, _ref[contextProp] = this.emitter, _ref;
      };

      Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.value !== nextProps.value) {
          var oldValue = this.props.value;
          var newValue = nextProps.value;
          var changedBits = void 0;

          if (objectIs(oldValue, newValue)) {
            changedBits = 0; // No change
          } else {
            changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

            changedBits |= 0;

            if (changedBits !== 0) {
              this.emitter.set(nextProps.value, changedBits);
            }
          }
        }
      };

      Provider.prototype.render = function render() {
        return this.props.children;
      };

      return Provider;
    }(React__default['default'].Component);

    Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);

    var Consumer = function (_Component2) {
      _inherits(Consumer, _Component2);

      function Consumer() {
        var _temp2, _this2, _ret2;

        _classCallCheck(this, Consumer);

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
          value: _this2.getValue()
        }, _this2.onUpdate = function (newValue, changedBits) {
          var observedBits = _this2.observedBits | 0;
          if ((observedBits & changedBits) !== 0) {
            _this2.setState({ value: _this2.getValue() });
          }
        }, _temp2), _possibleConstructorReturn(_this2, _ret2);
      }

      Consumer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var observedBits = nextProps.observedBits;

        this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
        : observedBits;
      };

      Consumer.prototype.componentDidMount = function componentDidMount() {
        if (this.context[contextProp]) {
          this.context[contextProp].on(this.onUpdate);
        }
        var observedBits = this.props.observedBits;

        this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
        : observedBits;
      };

      Consumer.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.context[contextProp]) {
          this.context[contextProp].off(this.onUpdate);
        }
      };

      Consumer.prototype.getValue = function getValue() {
        if (this.context[contextProp]) {
          return this.context[contextProp].get();
        } else {
          return defaultValue;
        }
      };

      Consumer.prototype.render = function render() {
        return onlyChild(this.props.children)(this.state.value);
      };

      return Consumer;
    }(React__default['default'].Component);

    Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);


    return {
      Provider: Provider,
      Consumer: Consumer
    };
  }

  exports.default = createReactContext;
  module.exports = exports['default'];
  });

  unwrapExports(implementation);

  var lib = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(React__default['default']);



  var _implementation2 = _interopRequireDefault(implementation);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _react2.default.createContext || _implementation2.default;
  module.exports = exports['default'];
  });

  var createContext = unwrapExports(lib);

  var ManagerReferenceNodeContext = createContext();
  var ManagerReferenceNodeSetterContext = createContext();

  var Manager =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Manager, _React$Component);

    function Manager() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "referenceNode", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "setReferenceNode", function (newReferenceNode) {
        if (newReferenceNode && _this.referenceNode !== newReferenceNode) {
          _this.referenceNode = newReferenceNode;

          _this.forceUpdate();
        }
      });

      return _this;
    }

    var _proto = Manager.prototype;

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.referenceNode = null;
    };

    _proto.render = function render() {
      return React.createElement(ManagerReferenceNodeContext.Provider, {
        value: this.referenceNode
      }, React.createElement(ManagerReferenceNodeSetterContext.Provider, {
        value: this.setReferenceNode
      }, this.props.children));
    };

    return Manager;
  }(React.Component);

  /**
   * Takes an argument and if it's an array, returns the first item in the array,
   * otherwise returns the argument. Used for Preact compatibility.
   */
  var unwrapArray = function unwrapArray(arg) {
    return Array.isArray(arg) ? arg[0] : arg;
  };
  /**
   * Takes a maybe-undefined function and arbitrary args and invokes the function
   * only if it is defined.
   */

  var safeInvoke = function safeInvoke(fn) {
    if (typeof fn === "function") {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return fn.apply(void 0, args);
    }
  };
  /**
   * Sets a ref using either a ref callback or a ref object
   */

  var setRef = function setRef(ref, node) {
    // if its a function call it
    if (typeof ref === "function") {
      return safeInvoke(ref, node);
    } // otherwise we should treat it as a ref object
    else if (ref != null) {
        ref.current = node;
      }
  };

  var initialStyle = {
    position: 'absolute',
    top: 0,
    left: 0,
    opacity: 0,
    pointerEvents: 'none'
  };
  var initialArrowStyle = {};
  var InnerPopper =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(InnerPopper, _React$Component);

    function InnerPopper() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        data: undefined,
        placement: undefined
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "popperInstance", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "popperNode", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "arrowNode", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "setPopperNode", function (popperNode) {
        if (!popperNode || _this.popperNode === popperNode) return;
        setRef(_this.props.innerRef, popperNode);
        _this.popperNode = popperNode;

        _this.updatePopperInstance();
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "setArrowNode", function (arrowNode) {
        _this.arrowNode = arrowNode;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateStateModifier", {
        enabled: true,
        order: 900,
        fn: function fn(data) {
          var placement = data.placement;

          _this.setState({
            data: data,
            placement: placement
          });

          return data;
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getOptions", function () {
        return {
          placement: _this.props.placement,
          eventsEnabled: _this.props.eventsEnabled,
          positionFixed: _this.props.positionFixed,
          modifiers: _extends$1({}, _this.props.modifiers, {
            arrow: _extends$1({}, _this.props.modifiers && _this.props.modifiers.arrow, {
              enabled: !!_this.arrowNode,
              element: _this.arrowNode
            }),
            applyStyle: {
              enabled: false
            },
            updateStateModifier: _this.updateStateModifier
          })
        };
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getPopperStyle", function () {
        return !_this.popperNode || !_this.state.data ? initialStyle : _extends$1({
          position: _this.state.data.offsets.popper.position
        }, _this.state.data.styles);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getPopperPlacement", function () {
        return !_this.state.data ? undefined : _this.state.placement;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getArrowStyle", function () {
        return !_this.arrowNode || !_this.state.data ? initialArrowStyle : _this.state.data.arrowStyles;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getOutOfBoundariesState", function () {
        return _this.state.data ? _this.state.data.hide : undefined;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "destroyPopperInstance", function () {
        if (!_this.popperInstance) return;

        _this.popperInstance.destroy();

        _this.popperInstance = null;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updatePopperInstance", function () {
        _this.destroyPopperInstance();

        var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),
            popperNode = _assertThisInitialize.popperNode;

        var referenceElement = _this.props.referenceElement;
        if (!referenceElement || !popperNode) return;
        _this.popperInstance = new Popper$1(referenceElement, popperNode, _this.getOptions());
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "scheduleUpdate", function () {
        if (_this.popperInstance) {
          _this.popperInstance.scheduleUpdate();
        }
      });

      return _this;
    }

    var _proto = InnerPopper.prototype;

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      // If the Popper.js options have changed, update the instance (destroy + create)
      if (this.props.placement !== prevProps.placement || this.props.referenceElement !== prevProps.referenceElement || this.props.positionFixed !== prevProps.positionFixed || !deepEqual_1(this.props.modifiers, prevProps.modifiers, {
        strict: true
      })) {

        this.updatePopperInstance();
      } else if (this.props.eventsEnabled !== prevProps.eventsEnabled && this.popperInstance) {
        this.props.eventsEnabled ? this.popperInstance.enableEventListeners() : this.popperInstance.disableEventListeners();
      } // A placement difference in state means popper determined a new placement
      // apart from the props value. By the time the popper element is rendered with
      // the new position Popper has already measured it, if the place change triggers
      // a size change it will result in a misaligned popper. So we schedule an update to be sure.


      if (prevState.placement !== this.state.placement) {
        this.scheduleUpdate();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      setRef(this.props.innerRef, null);
      this.destroyPopperInstance();
    };

    _proto.render = function render() {
      return unwrapArray(this.props.children)({
        ref: this.setPopperNode,
        style: this.getPopperStyle(),
        placement: this.getPopperPlacement(),
        outOfBoundaries: this.getOutOfBoundariesState(),
        scheduleUpdate: this.scheduleUpdate,
        arrowProps: {
          ref: this.setArrowNode,
          style: this.getArrowStyle()
        }
      });
    };

    return InnerPopper;
  }(React.Component);

  _defineProperty(InnerPopper, "defaultProps", {
    placement: 'bottom',
    eventsEnabled: true,
    referenceElement: undefined,
    positionFixed: false
  });
  function Popper(_ref) {
    var referenceElement = _ref.referenceElement,
        props = _objectWithoutPropertiesLoose(_ref, ["referenceElement"]);

    return React.createElement(ManagerReferenceNodeContext.Consumer, null, function (referenceNode) {
      return React.createElement(InnerPopper, _extends$1({
        referenceElement: referenceElement !== undefined ? referenceElement : referenceNode
      }, props));
    });
  }

  var InnerReference =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(InnerReference, _React$Component);

    function InnerReference() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "refHandler", function (node) {
        setRef(_this.props.innerRef, node);
        safeInvoke(_this.props.setReferenceNode, node);
      });

      return _this;
    }

    var _proto = InnerReference.prototype;

    _proto.componentWillUnmount = function componentWillUnmount() {
      setRef(this.props.innerRef, null);
    };

    _proto.render = function render() {
      warning_1(Boolean(this.props.setReferenceNode));
      return unwrapArray(this.props.children)({
        ref: this.refHandler
      });
    };

    return InnerReference;
  }(React.Component);

  function Reference(props) {
    return React.createElement(ManagerReferenceNodeSetterContext.Consumer, null, function (setReferenceNode) {
      return React.createElement(InnerReference, _extends$1({
        setReferenceNode: setReferenceNode
      }, props));
    });
  }

  var PopperWrapper = /*#__PURE__*/function (_React$Component) {
    _inherits$o(PopperWrapper, _React$Component);

    var _super = _createSuper(PopperWrapper);

    function PopperWrapper(props) {
      var _this;

      _classCallCheck$p(this, PopperWrapper);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "triggerRef", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "popupRef", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "hoverableDelay", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "_timer", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "_throttleWait", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "offsetMapping", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "togglePopper", function (type, newValue) {
        var _this$props = _this.props,
            open = _this$props.open,
            onToggle = _this$props.onToggle;
        onToggle(newValue === undefined ? !open : newValue, type);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "findDOMNode", function (ref) {
        return ReactDOM.findDOMNode(ref.current);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "doesEventContainsElement", function (event, ref) {
        var el = _this.findDOMNode(ref);

        return el && el.contains(event.target);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getUpdatedStyle", function (oldStyle, placement, offset) {
        var style = _this.props.style;

        var newStyle = _objectSpread2(_objectSpread2({}, style), oldStyle);

        var position = placement ? placement.split('-')[0] : placement;

        switch (position) {
          case 'top':
            newStyle.marginBottom = _this.offsetMapping[offset];
            break;

          case 'bottom':
            newStyle.marginTop = _this.offsetMapping[offset];
            break;

          case 'left':
            newStyle.marginRight = _this.offsetMapping[offset];
            break;

          case 'right':
            newStyle.marginLeft = _this.offsetMapping[offset];
            break;
        }

        return newStyle;
      });

      _this.state = {};
      _this.hoverableDelay = 100;
      _this.offsetMapping = {
        small: '2px',
        medium: '4px',
        large: '8px'
      };
      _this.triggerRef = /*#__PURE__*/React.createRef();
      _this.popupRef = /*#__PURE__*/React.createRef();
      _this.getPopperChildren = _this.getPopperChildren.bind(_assertThisInitialized$p(_this));
      _this.mouseMoveHandler = _this.mouseMoveHandler.bind(_assertThisInitialized$p(_this));
      _this.handleMouseEnter = _this.handleMouseEnter.bind(_assertThisInitialized$p(_this));
      _this.handleMouseLeave = _this.handleMouseLeave.bind(_assertThisInitialized$p(_this));
      _this.boundaryScrollHandler = _this.boundaryScrollHandler.bind(_assertThisInitialized$p(_this));
      return _this;
    }

    _createClass$p(PopperWrapper, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.addBoundaryScrollHandler();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (!prevProps.boundaryElement && this.props.boundaryElement) {
          this.removeBoundaryScrollHandler();
          this.addBoundaryScrollHandler();
        }

        if (prevProps.open !== this.props.open) {
          this._throttleWait = false;

          if (this.props.open) {
            var triggerElement = this.findDOMNode(this.triggerRef);
            var zIndex = this.getZIndexForLayer(triggerElement);
            this.setState({
              zIndex: zIndex === undefined ? zIndex : zIndex + 1
            });
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.removeBoundaryScrollHandler();
      }
    }, {
      key: "boundaryScrollHandler",
      value: function boundaryScrollHandler() {
        var _this$props2 = this.props,
            open = _this$props2.open,
            on = _this$props2.on,
            closeOnScroll = _this$props2.closeOnScroll;

        if (on === 'click' && closeOnScroll) {
          if (open) {
            if (!this._throttleWait) {
              this.togglePopper('onScroll', false);
              this._throttleWait = true;
            }
          }
        }
      }
    }, {
      key: "addBoundaryScrollHandler",
      value: function addBoundaryScrollHandler() {
        if (this.props.boundaryElement) {
          this.props.boundaryElement.addEventListener('scroll', this.boundaryScrollHandler);
        }
      }
    }, {
      key: "removeBoundaryScrollHandler",
      value: function removeBoundaryScrollHandler() {
        if (this.props.boundaryElement) {
          this.props.boundaryElement.removeEventListener('scroll', this.boundaryScrollHandler);
        }
      }
    }, {
      key: "mouseMoveHandler",
      value: function mouseMoveHandler() {
        var _this2 = this;

        if (this._timer) clearTimeout(this._timer);
        this._timer = window.setTimeout(function () {
          var onToggle = _this2.props.onToggle;
          onToggle(false, 'mouseLeave');
        }, this.hoverableDelay);
      }
    }, {
      key: "handleMouseEnter",
      value: function handleMouseEnter() {
        var on = this.props.on;

        if (on === 'hover') {
          if (this._timer) clearTimeout(this._timer);
          var onToggle = this.props.onToggle;
          onToggle(true, 'mouseEnter');
        }
      }
    }, {
      key: "handleMouseLeave",
      value: function handleMouseLeave() {
        var on = this.props.on;

        if (on === 'hover') {
          var _this$props3 = this.props,
              hoverable = _this$props3.hoverable,
              onToggle = _this$props3.onToggle;

          if (hoverable) {
            this.mouseMoveHandler();
          } else {
            onToggle(false, 'mouseLeave');
          }
        }
      }
    }, {
      key: "getZIndexForLayer",
      value: function getZIndexForLayer(node) {
        if (node === null) {
          return;
        }

        var layerNode = node.closest('[data-layer]') || document.body;
        var zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);
        return zIndex === 'auto' || isNaN(zIndex) ? undefined : zIndex;
      }
    }, {
      key: "getTriggerElement",
      value: function getTriggerElement(ref) {
        var _this3 = this;

        var _this$props4 = this.props,
            trigger = _this$props4.trigger,
            on = _this$props4.on,
            triggerClass = _this$props4.triggerClass;
        var options = on === 'hover' ? {
          ref: ref,
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave
        } : {
          ref: ref,
          onClick: function onClick(ev) {
            ev.stopPropagation();

            _this3.togglePopper('onClick');
          }
        };
        var classes = classnames('PopperWrapper-trigger', triggerClass);

        var onOutsideClickHandler = function onOutsideClickHandler(event) {
          var _this3$props = _this3.props,
              open = _this3$props.open,
              closeOnBackdropClick = _this3$props.closeOnBackdropClick;

          if (open && closeOnBackdropClick) {
            if (!_this3.doesEventContainsElement(event, _this3.popupRef)) {
              _this3.togglePopper('outsideClick');
            }
          }
        };

        return /*#__PURE__*/React.createElement(OutsideClick, _extends$p({
          className: classes,
          onOutsideClick: onOutsideClickHandler
        }, options), trigger);
      }
    }, {
      key: "getPopperChildren",
      value: function getPopperChildren(_ref) {
        var ref = _ref.ref,
            style = _ref.style,
            placement = _ref.placement,
            outOfBoundaries = _ref.outOfBoundaries;
        var _this$props5 = this.props,
            offset = _this$props5.offset,
            children = _this$props5.children;
        var zIndex = this.state.zIndex;
        var newStyle = offset ? this.getUpdatedStyle(style, placement, offset) : style;
        var element = /*#__PURE__*/React.cloneElement(children, {
          ref: ref,
          style: _objectSpread2(_objectSpread2({}, newStyle), {}, {
            zIndex: zIndex
          }),
          'data-placement': placement,
          'data-hide': outOfBoundaries,
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave
        });
        return element;
      }
    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        var _this$props6 = this.props,
            placement = _this$props6.placement,
            appendToBody = _this$props6.appendToBody,
            open = _this$props6.open,
            hide = _this$props6.hide,
            boundaryElement = _this$props6.boundaryElement;
        return /*#__PURE__*/React.createElement(Manager, null, /*#__PURE__*/React.createElement(Reference, {
          innerRef: this.triggerRef
        }, function (_ref2) {
          var ref = _ref2.ref;
          return _this4.getTriggerElement(ref);
        }), open && appendToBody && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(Popper, {
          placement: placement,
          innerRef: this.popupRef,
          modifiers: {
            preventOverflow: {
              boundariesElement: boundaryElement || document.body
            },
            hide: {
              enabled: hide
            }
          }
        }, this.getPopperChildren), document.body), open && !appendToBody && /*#__PURE__*/React.createElement(Popper, {
          placement: placement,
          innerRef: this.popupRef
        }, this.getPopperChildren));
      }
    }]);

    return PopperWrapper;
  }(React.Component);

  _defineProperty$w(PopperWrapper, "defaultProps", {
    on: 'click',
    offset: 'medium',
    closeOnBackdropClick: true,
    hoverable: true,
    appendToBody: true,
    style: {}
  });

  var propsList$1 = ['appendToBody', 'trigger', 'hoverable', 'on', 'open', 'closeOnBackdropClick', 'offset', 'closeOnScroll'];
  var Popover = function Popover(props) {
    var position = props.position,
        customStyle = props.customStyle,
        dark = props.dark,
        children = props.children,
        onToggle = props.onToggle,
        className = props.className,
        hideOnReferenceEscape = props.hideOnReferenceEscape,
        boundaryElement = props.boundaryElement,
        rest = _objectWithoutProperties$a(props, ["position", "customStyle", "dark", "children", "onToggle", "className", "hideOnReferenceEscape", "boundaryElement"]);

    var _React$useState = React.useState(!!props.open),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        open = _React$useState2[0],
        setOpen = _React$useState2[1];

    var _React$useState3 = React.useState(false),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        init = _React$useState4[0],
        setInit = _React$useState4[1];

    React.useEffect(function () {
      if (props.open !== undefined) setOpen(props.open);
    }, [props.open]);
    var defaultOnToggle = React.useCallback(function (newOpen) {
      setOpen(newOpen);
    }, []);
    React.useEffect(function () {
      if (!init) {
        if ('current' in boundaryElement && boundaryElement.current) {
          setInit(true);
        }
      }
    }, [boundaryElement]);
    var classes = classnames(_defineProperty$w({
      Popover: true
    }, 'Popover--dark', dark), className);
    var PopoverWrapper = /*#__PURE__*/React.createElement("div", {
      "data-test": "DesignSystem-Popover",
      className: classes,
      "data-layer": true
    }, children);
    return /*#__PURE__*/React.createElement(PopperWrapper, _extends$p({}, rest, {
      init: init,
      boundaryElement: 'current' in boundaryElement ? boundaryElement.current : boundaryElement,
      open: open,
      hide: hideOnReferenceEscape,
      style: customStyle,
      onToggle: onToggle || defaultOnToggle,
      placement: position
    }), PopoverWrapper);
  };
  Popover.displayName = 'Popover'; // Popover.defaultProps = {
  //   ...filterProps(PopperWrapper.defaultProps, propsList, true),
  //   offset: 'large',
  //   position: 'bottom',
  //   hideOnReferenceEscape: true,
  //   customStyle: {},
  // }

  Popover.defaultProps = Object.assign({}, filterProps(PopperWrapper.defaultProps, propsList$1, true), {
    offset: 'large',
    position: 'bottom',
    hideOnReferenceEscape: true,
    customStyle: {},
    boundaryElement: document.body
  });

  var propsList = ['trigger', 'on', 'open', 'offset', 'onToggle', 'dark', 'customStyle', 'closeOnBackdropClick', 'hideOnReferenceEscape', 'closeOnScroll'];
  var Tooltip = function Tooltip(props) {
    var children = props.children,
        tooltip = props.tooltip,
        rest = _objectWithoutProperties$a(props, ["children", "tooltip"]);

    var tooltipWrapper = /*#__PURE__*/React.createElement("div", {
      className: "Tooltip"
    }, /*#__PURE__*/React.createElement(Text$1, {
      className: "Tooltip-text",
      appearance: "white"
    }, tooltip));
    return /*#__PURE__*/React.createElement(Popover, _extends$p({
      trigger: children,
      on: 'hover',
      offset: 'medium'
    }, rest), tooltipWrapper);
  }; // Tooltip.defaultProps = filterProps({
  //   ...Popover.defaultProps,
  //   hoverable: false
  // }, propsList);

  Tooltip.defaultProps = Object.assign({}, filterProps(Popover.defaultProps, propsList), {
    hoverable: false
  });

  var Dialog = function Dialog(props) {
    var dimension = props.dimension,
        primaryButtonAppearance = props.primaryButtonAppearance,
        secondaryButtonAppearance = props.secondaryButtonAppearance,
        open = props.open,
        onClose = props.onClose,
        heading = props.heading,
        title = props.title,
        description = props.description,
        primaryButtonLabel = props.primaryButtonLabel,
        primaryButtonCallback = props.primaryButtonCallback,
        secondaryButtonLabel = props.secondaryButtonLabel,
        secondaryButtonCallback = props.secondaryButtonCallback;
    var baseProps = extractBaseProps(props);
    return /*#__PURE__*/React.createElement(Modal, _extends$p({
      "data-test": "DesignSystem-Dialog"
    }, baseProps, {
      open: open,
      dimension: dimension,
      onClose: onClose,
      headerOptions: {
        heading: heading
      },
      footer: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Button, {
        "data-test": "DesignSystem-Dialog--SecondaryButton",
        appearance: secondaryButtonAppearance,
        onClick: secondaryButtonCallback
      }, secondaryButtonLabel), /*#__PURE__*/React.createElement(Button, {
        className: "ml-4",
        "data-test": "DesignSystem-Dialog--PrimaryButton",
        appearance: primaryButtonAppearance,
        onClick: primaryButtonCallback
      }, primaryButtonLabel))
    }), /*#__PURE__*/React.createElement(ModalDescription, {
      title: title,
      description: description
    }));
  };

  Dialog.displayName = 'Dialog';
  Dialog.defaultProps = {
    dimension: 'small',
    primaryButtonAppearance: 'primary',
    secondaryButtonAppearance: 'basic'
  };

  var getWrapperElement = function getWrapperElement() {
    var element = document.querySelector('.Overlay-wrapper');

    if (element === null) {
      element = document.createElement('div');
      element.classList.add('Overlay-wrapper');
      document.body.appendChild(element);
    }

    return element;
  };
  var getUpdatedZIndex = function getUpdatedZIndex(ele) {
    var containerClassName = ele.containerClassName,
        elementRef = ele.elementRef,
        element = ele.element;
    if (element === null) return;
    var elements = element.querySelectorAll(containerClassName);
    if (elements.length < 1) return;
    var siblings = Array.from(elements).filter(function (el) {
      return el !== elementRef.current;
    });
    var zIndex = -1;
    siblings.forEach(function (element) {
      var prevZIndex = parseInt(window.getComputedStyle(element).zIndex || '0', 10);
      zIndex = Math.max(zIndex, prevZIndex + 10);
    });
    return zIndex > 0 ? zIndex : undefined;
  };

  /**
   * ** NOTE: Use `headerOptions`, `footer`, `onClose` and `backdropClose`(boolean). **
   * ** Support for composition using `ModalHeader`, `ModalBody` and `ModalFooter` will be deprecated soon. **
   *
   * ** NOT RECOMMENDED: Only use composition of `ModalHeader`, `ModalBody` and `ModalFooter` **
   * ** when you are not using `headerOptions` or `footer` **
   */
  var Modal = /*#__PURE__*/function (_React$Component) {
    _inherits$o(Modal, _React$Component);

    var _super = _createSuper(Modal);

    function Modal(props) {
      var _this;

      _classCallCheck$p(this, Modal);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "modalRef", /*#__PURE__*/React.createRef());

      _defineProperty$w(_assertThisInitialized$p(_this), "element", void 0);

      _this.element = getWrapperElement();
      _this.state = {
        open: props.open,
        animate: props.open
      };
      _this.onOutsideClickHandler = _this.onOutsideClickHandler.bind(_assertThisInitialized$p(_this));
      return _this;
    }

    _createClass$p(Modal, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this2 = this;

        if (prevProps.open !== this.props.open) {
          if (this.props.open) {
            var zIndex = getUpdatedZIndex({
              element: this.element,
              containerClassName: '.Modal-container--open',
              elementRef: this.modalRef
            });
            this.setState({
              zIndex: zIndex,
              open: true,
              animate: true
            });
          } else {
            this.setState({
              animate: false
            }, function () {
              window.setTimeout(function () {
                _this2.setState({
                  open: false
                });
              }, 120);
            });
          }
        }
      }
    }, {
      key: "onOutsideClickHandler",
      value: function onOutsideClickHandler(event) {
        var _this$props = this.props,
            backdropClose = _this$props.backdropClose,
            onClose = _this$props.onClose;
        var open = this.state.open;

        if (open) {
          if (onClose) onClose(event, 'OutsideClick');else if (typeof backdropClose === 'function') backdropClose(event, 'OutsideClick');
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames;

        var _this$state = this.state,
            animate = _this$state.animate,
            open = _this$state.open,
            zIndex = _this$state.zIndex;
        var _this$props2 = this.props,
            className = _this$props2.className,
            backdropClose = _this$props2.backdropClose,
            dimension = _this$props2.dimension,
            children = _this$props2.children,
            headerOptions = _this$props2.headerOptions,
            footer = _this$props2.footer,
            _onClose = _this$props2.onClose;
        var classes = classnames({
          Modal: true,
          'Modal--open': open,
          'Modal-animation--open': animate,
          'Modal-animation--close': !animate
        }, className);
        var ContainerClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Row', true), _defineProperty$w(_classNames, 'Modal-container', true), _defineProperty$w(_classNames, 'Modal-container--open', open), _classNames));
        var baseProps = extractBaseProps(this.props);
        var sizeMap = {
          small: {
            size: '3',
            sizeL: '4',
            sizeM: '4',
            sizeXS: '10'
          },
          medium: {
            size: '4',
            sizeL: '6',
            sizeM: '6',
            sizeXS: '10'
          },
          large: {
            size: '6',
            sizeL: '8',
            sizeM: '8',
            sizeXS: '10'
          }
        };
        var ModalContainer = /*#__PURE__*/React.createElement(Row, {
          "data-test": "DesignSystem-ModalContainer",
          className: ContainerClass,
          "data-layer": true,
          style: {
            zIndex: zIndex
          }
        }, /*#__PURE__*/React.createElement(Column, _extends$p({
          "data-test": "DesignSystem-Modal"
        }, baseProps, {
          className: classes
        }, sizeMap[dimension], {
          ref: this.modalRef
        }), headerOptions && /*#__PURE__*/React.createElement(ModalHeader, _extends$p({
          onClose: function onClose(event, reason) {
            if (_onClose) _onClose(event, reason);
          }
        }, headerOptions)), children && /*#__PURE__*/React.createElement(React.Fragment, null, headerOptions || footer ? /*#__PURE__*/React.createElement(ModalBody, {
          withFooter: !!footer
        }, children) : children), footer && /*#__PURE__*/React.createElement(ModalFooter, {
          open: open
        }, footer)));
        var ModalWrapper = backdropClose ? /*#__PURE__*/React.createElement(OutsideClick, {
          "data-test": "DesignSystem-Modal--OutsideClick",
          onOutsideClick: this.onOutsideClickHandler
        }, ModalContainer) : ModalContainer;
        var WrapperElement = /*#__PURE__*/ReactDOM.createPortal(ModalWrapper, this.element);
        return /*#__PURE__*/React.createElement(React.Fragment, null, WrapperElement, /*#__PURE__*/React.createElement(Backdrop, {
          open: this.state.animate
        }));
      }
    }]);

    return Modal;
  }(React.Component);

  _defineProperty$w(Modal, "defaultProps", {
    dimension: 'medium'
  });

  var ModalHeader$1 = function ModalHeader(props) {
    var className = props.className,
        heading = props.heading,
        subHeading = props.subHeading,
        backButton = props.backButton,
        backButtonCallback = props.backButtonCallback;
    var baseProps = extractBaseProps(props);
    var classes = classnames(_defineProperty$w({
      'FullscreenModal-header': true
    }, 'FullscreenModal-header--backButton', backButton), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-ModalHeader"
    }, baseProps, {
      className: classes
    }), /*#__PURE__*/React.createElement("div", {
      className: "FullscreenModal-headerWrapper"
    }, backButton && /*#__PURE__*/React.createElement(Icon, {
      name: "keyboard_backspace",
      size: 20,
      className: "mr-5 cursor-pointer",
      onClick: backButtonCallback
    }), heading && /*#__PURE__*/React.createElement(Heading, null, heading)), subHeading && /*#__PURE__*/React.createElement(Text$1, {
      "data-test": "DesignSystem-ModalHeader--Subheading",
      appearance: "subtle",
      className: "mt-2"
    }, subHeading));
  };
  ModalHeader$1.displayName = 'ModalHeader';

  var ModalFooter$1 = function ModalFooter(props) {
    var open = props.open,
        actions = props.actions;
    var baseProps = extractBaseProps(props);
    var wrapperRef = /*#__PURE__*/React.createRef();
    React.useEffect(function () {
      if (open) {
        if (wrapperRef.current) {
          var _wrapperRef$current;

          var secondaryBtns = (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.querySelectorAll('.Button--basic');
          var secondaryBtn = secondaryBtns[secondaryBtns.length - 1];

          if (secondaryBtn) {
            window.requestAnimationFrame(function () {
              return secondaryBtn.focus({
                preventScroll: true
              });
            });
          }
        }
      }
    }, [open]);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      ref: wrapperRef
    }, baseProps, {
      className: "d-flex"
    }), actions.map(function (_ref, index) {
      _ref.label;
          var options = _objectWithoutProperties$a(_ref, ["label"]);

      return /*#__PURE__*/React.createElement(Button, _extends$p({}, options, {
        key: index
      }));
    }));
  };
  ModalFooter$1.defaultProps = {
    actions: []
  };
  ModalFooter$1.displayName = 'ModalFooter';

  var FullscreenModal = /*#__PURE__*/function (_React$Component) {
    _inherits$o(FullscreenModal, _React$Component);

    var _super = _createSuper(FullscreenModal);

    function FullscreenModal(props) {
      var _this;

      _classCallCheck$p(this, FullscreenModal);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "modalRef", /*#__PURE__*/React.createRef());

      _defineProperty$w(_assertThisInitialized$p(_this), "element", void 0);

      _this.element = getWrapperElement();
      _this.state = {
        open: props.open,
        animate: props.open
      };
      return _this;
    }

    _createClass$p(FullscreenModal, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this2 = this;

        if (prevProps.open !== this.props.open) {
          if (this.props.open) {
            var zIndex = getUpdatedZIndex({
              element: this.element,
              containerClassName: '.FullscreenModal-container--open',
              elementRef: this.modalRef
            });
            this.setState({
              zIndex: zIndex,
              open: true,
              animate: true
            });
          } else {
            this.setState({
              animate: false
            }, function () {
              window.setTimeout(function () {
                _this2.setState({
                  open: false
                });
              }, 120);
            });
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames;

        var _this$state = this.state,
            animate = _this$state.animate,
            open = _this$state.open,
            zIndex = _this$state.zIndex;
        var _this$props = this.props,
            className = _this$props.className,
            dimension = _this$props.dimension,
            children = _this$props.children,
            header = _this$props.header,
            headerOptions = _this$props.headerOptions,
            footer = _this$props.footer,
            footerOptions = _this$props.footerOptions,
            onClose = _this$props.onClose;
        var classes = classnames({
          FullscreenModal: true,
          'FullscreenModal--open': open,
          'FullscreenModal-animation--open': animate,
          'FullscreenModal-animation--close': !animate
        }, className);
        var ContainerClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'FullscreenModal-container', true), _defineProperty$w(_classNames, 'FullscreenModal-container--open', open), _classNames));
        var baseProps = extractBaseProps(this.props);
        var sizeMap = {
          medium: {
            size: '4',
            sizeL: '6',
            sizeM: '6',
            sizeXS: '12'
          },
          large: {
            size: '6',
            sizeL: '8',
            sizeM: '8',
            sizeXS: '12'
          }
        };
        var ModalContainer = /*#__PURE__*/React.createElement("div", {
          "data-test": "DesignSystem-FullscreenModalContainer",
          className: ContainerClass,
          "data-layer": true,
          style: {
            zIndex: zIndex
          }
        }, /*#__PURE__*/React.createElement("div", _extends$p({
          "data-test": "DesignSystem-FullscreenModal"
        }, baseProps, {
          className: classes,
          ref: this.modalRef
        }), /*#__PURE__*/React.createElement(Row, {
          className: "justify-content-center"
        }, /*#__PURE__*/React.createElement(Column, sizeMap[dimension], /*#__PURE__*/React.createElement(Row, {
          className: "justify-content-between pt-6 pr-6 pb-5 pl-7"
        }, /*#__PURE__*/React.createElement(Column, {
          size: "auto"
        }, !header && /*#__PURE__*/React.createElement(ModalHeader$1, headerOptions), !!header && header), /*#__PURE__*/React.createElement(Column, {
          size: "auto",
          className: "pr-2"
        }, /*#__PURE__*/React.createElement(Icon, {
          size: 20,
          name: 'close',
          className: "cursor-pointer pt-3",
          "data-test": "DesignSystem-ModalHeader--CloseIcon",
          onClick: function onClick(event) {
            if (onClose) onClose(event, 'IconClick');
          }
        }))), /*#__PURE__*/React.createElement("div", {
          "data-test": "DesignSystem-ModalBody",
          className: "FullscreenModal-body"
        }, children), (!!footer || !!footerOptions) && /*#__PURE__*/React.createElement("div", {
          "data-test": "DesignSystem-ModalFooter",
          className: "d-flex justify-content-end p-7"
        }, !footer && /*#__PURE__*/React.createElement(ModalFooter$1, _extends$p({}, footerOptions, {
          open: open
        })), !!footer && footer)))));
        var WrapperElement = /*#__PURE__*/ReactDOM.createPortal(ModalContainer, this.element);
        return /*#__PURE__*/React.createElement(React.Fragment, null, WrapperElement);
      }
    }]);

    return FullscreenModal;
  }(React.Component);

  _defineProperty$w(FullscreenModal, "defaultProps", {
    dimension: 'medium'
  });

  var sidesheetWidth = {
    regular: '6',
    large: '10'
  };

  var Sidesheet = /*#__PURE__*/function (_React$Component) {
    _inherits$o(Sidesheet, _React$Component);

    var _super = _createSuper(Sidesheet);

    function Sidesheet(props) {
      var _this;

      _classCallCheck$p(this, Sidesheet);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "sidesheetRef", /*#__PURE__*/React.createRef());

      _defineProperty$w(_assertThisInitialized$p(_this), "element", void 0);

      _this.element = getWrapperElement();
      _this.state = {
        open: props.open,
        animate: props.open
      };
      _this.onOutsideClickHandler = _this.onOutsideClickHandler.bind(_assertThisInitialized$p(_this));
      return _this;
    }

    _createClass$p(Sidesheet, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this2 = this;

        if (prevProps.open !== this.props.open) {
          if (this.props.open) {
            var zIndex = getUpdatedZIndex({
              element: this.element,
              containerClassName: '.Sidesheet-container--open',
              elementRef: this.sidesheetRef
            });
            this.setState({
              zIndex: zIndex,
              open: true,
              animate: true
            });
          } else {
            this.setState({
              animate: false
            }, function () {
              window.setTimeout(function () {
                _this2.setState({
                  open: false
                });
              }, 120);
            });
          }
        }
      }
    }, {
      key: "onOutsideClickHandler",
      value: function onOutsideClickHandler(event) {
        var onClose = this.props.onClose;
        var open = this.state.open;

        if (open) {
          if (onClose) onClose(event, 'OutsideClick');
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames;

        var _this$state = this.state,
            animate = _this$state.animate,
            open = _this$state.open,
            zIndex = _this$state.zIndex;
        var _this$props = this.props,
            className = _this$props.className,
            backdropClose = _this$props.backdropClose,
            dimension = _this$props.dimension,
            footer = _this$props.footer,
            seperator = _this$props.seperator,
            stickFooter = _this$props.stickFooter,
            headerOptions = _this$props.headerOptions,
            _onClose = _this$props.onClose;
        var classes = classnames({
          Sidesheet: true,
          'Sidesheet--open': open,
          'Sidesheet-animation--open': animate,
          'Sidesheet-animation--close': !animate
        }, className);
        var ContainerClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Sidesheet-container', true), _defineProperty$w(_classNames, 'Sidesheet-container--open', open), _classNames));
        var baseProps = extractBaseProps(this.props);

        var headerObj = _objectSpread2(_objectSpread2({}, headerOptions), {}, {
          seperator: seperator
        });

        var SidesheetContainer = /*#__PURE__*/React.createElement(Row, {
          "data-test": "DesignSystem-SidesheetContainer",
          className: ContainerClass,
          "data-layer": true,
          style: {
            zIndex: zIndex
          },
          ref: this.sidesheetRef
        }, /*#__PURE__*/React.createElement(Column, _extends$p({
          "data-test": "DesignSystem-Sidesheet"
        }, baseProps, {
          className: classes,
          size: sidesheetWidth[dimension]
        }), /*#__PURE__*/React.createElement(ModalHeader, _extends$p({
          onClose: function onClose(event, reason) {
            if (_onClose) _onClose(event, reason);
          }
        }, headerObj)), /*#__PURE__*/React.createElement(ModalBody, {
          stickFooter: stickFooter,
          withFooter: !!footer
        }, this.props.children), footer && /*#__PURE__*/React.createElement(ModalFooter, {
          inSidesheet: true,
          stickToBottom: stickFooter,
          seperator: seperator
        }, footer)));
        var SidesheetWrapper = backdropClose ? /*#__PURE__*/React.createElement(OutsideClick, {
          "data-test": "DesignSystem-Sidesheet--OutsideClick",
          onOutsideClick: this.onOutsideClickHandler
        }, SidesheetContainer) : SidesheetContainer;
        var WrapperElement = /*#__PURE__*/ReactDOM.createPortal(SidesheetWrapper, this.element);
        return /*#__PURE__*/React.createElement(React.Fragment, null, WrapperElement, /*#__PURE__*/React.createElement(Backdrop, {
          open: this.state.animate
        }));
      }
    }]);

    return Sidesheet;
  }(React.Component);

  _defineProperty$w(Sidesheet, "defaultProps", {
    dimension: 'regular',
    stickFooter: false,
    headerOptions: {}
  });

  var Status = function Status(props) {
    var type = props.type,
        time = props.time,
        className = props.className,
        _props$readText = props.readText,
        readText = _props$readText === void 0 ? 'Read' : _props$readText,
        _props$failedText = props.failedText,
        failedText = _props$failedText === void 0 ? 'Click to retry' : _props$failedText,
        _props$sendingText = props.sendingText,
        sendingText = _props$sendingText === void 0 ? 'Sending..' : _props$sendingText;
    var baseProps = extractBaseProps(props);
    var StatusClass = classnames(_defineProperty$w({}, 'd-flex align-items-center mt-3', true), className);
    var TextClass = classnames(_defineProperty$w({}, 'ChatMessage-status', true), className);

    var getTime = function getTime(t) {
      if (typeof t === 'number') {
        var d = new Date(t);
        var hours = d.getHours();
        var minutes = d.getMinutes();
        var AMPM = hours < 12 ? 'AM' : 'PM';
        var hrs = hours % 12 || 12;
        return "".concat(hrs, ":").concat(minutes, " ").concat(AMPM);
      }

      return t;
    };

    switch (type) {
      case 'failed':
        return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
          className: StatusClass
        }), /*#__PURE__*/React.createElement(Icon, {
          name: "error",
          type: "outlined",
          appearance: "destructive"
        }), /*#__PURE__*/React.createElement(Text$1, {
          appearance: "destructive",
          size: "small",
          className: "ml-1"
        }, "Failed"), /*#__PURE__*/React.createElement(MetaList, {
          list: [{
            label: failedText
          }],
          seperator: true
        }));

      case 'urgent':
        return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
          className: StatusClass
        }), /*#__PURE__*/React.createElement(Icon, {
          name: "notification_important",
          type: "outlined",
          appearance: "destructive"
        }), /*#__PURE__*/React.createElement(Text$1, {
          appearance: "destructive",
          size: "small",
          className: "ml-1"
        }, "Urgent"), time && /*#__PURE__*/React.createElement(MetaList, {
          list: [{
            label: getTime(time)
          }],
          seperator: true
        }));

      case 'read':
        return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
          className: StatusClass
        }), time && /*#__PURE__*/React.createElement(Text$1, {
          appearance: "subtle",
          size: "small"
        }, getTime(time)), /*#__PURE__*/React.createElement(MetaList, {
          list: [{
            label: readText
          }],
          seperator: true
        }));

      case 'sending':
        return /*#__PURE__*/React.createElement(Text$1, _extends$p({}, baseProps, {
          appearance: "subtle",
          size: "small",
          className: TextClass
        }), sendingText);

      case 'sent':
        return /*#__PURE__*/React.createElement(React.Fragment, null, time && /*#__PURE__*/React.createElement(Text$1, _extends$p({}, baseProps, {
          appearance: "subtle",
          size: "small",
          className: TextClass
        }), getTime(time)));

      default:
        return null;
    }
  };
  Status.displayName = 'Status';

  var Box = function Box(props) {
    var _classNames;

    var children = props.children,
        type = props.type,
        isTyping = props.isTyping,
        statusType = props.statusType,
        withStatus = props.withStatus,
        onClick = props.onClick,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var MessageClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Box', true), _defineProperty$w(_classNames, "Box--".concat(type), type), _defineProperty$w(_classNames, 'Box--typing', isTyping), _defineProperty$w(_classNames, 'Box--urgent', statusType === 'urgent'), _defineProperty$w(_classNames, "Box-".concat(type, "--withStatus"), withStatus || isTyping), _classNames), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: MessageClass,
      onClick: onClick
    }), children);
  };
  Box.displayName = 'Box';

  var MessageText = function MessageText(props) {
    var text = props.text,
        type = props.type,
        isTyping = props.isTyping,
        typingText = props.typingText,
        statusType = props.statusType,
        className = props.className;
    var baseProps = extractBaseProps(props);

    if (isTyping && type === 'incoming') {
      return /*#__PURE__*/React.createElement(Text$1, _extends$p({}, baseProps, {
        appearance: 'subtle',
        size: 'small',
        className: className
      }), typingText);
    }

    return /*#__PURE__*/React.createElement(Text$1, _extends$p({}, baseProps, {
      className: className,
      appearance: statusType === 'sending' ? 'subtle' : 'default'
    }), text);
  };
  MessageText.defaultProps = {
    text: '',
    typingText: 'Typing..'
  };
  MessageText.displayName = 'MessageText';

  var ChatMessage = function ChatMessage(props) {
    var type = props.type,
        text = props.text,
        isTyping = props.isTyping,
        typingText = props.typingText,
        statusOptions = props.statusOptions,
        onClick = props.onClick,
        className = props.className;
    var baseProps = extractBaseProps(props);

    var _ref = statusOptions || {},
        statusType = _ref.type;

    return /*#__PURE__*/React.createElement(Box, _extends$p({}, baseProps, {
      type: type,
      className: className,
      onClick: onClick,
      isTyping: isTyping,
      statusType: statusType,
      withStatus: statusOptions !== undefined
    }), /*#__PURE__*/React.createElement(MessageText, {
      type: type,
      text: text,
      typingText: typingText,
      isTyping: isTyping,
      statusType: statusType
    }), !isTyping && statusOptions && /*#__PURE__*/React.createElement(Status, statusOptions));
  };
  ChatMessage.displayName = 'ChatMessage';

  var imageHeight = {
    large: '256px',
    small: '128px'
  };
  var HeadingSize = {
    large: 'l',
    small: 'm'
  };
  var textSize = {
    large: 'large',
    small: 'regular'
  };
  var EmptyState = function EmptyState(props) {
    var _classNames2, _classNames3;

    var imageSrc = props.imageSrc,
        title = props.title,
        description = props.description,
        size = props.size,
        children = props.children,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var WrapperClass = classnames(_defineProperty$w({}, 'EmptyState', true), className);
    var HeadingClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'EmptyState-title', true), _defineProperty$w(_classNames2, "EmptyState-title--".concat(size), true), _classNames2));
    var TextClass = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'EmptyState-description', true), _defineProperty$w(_classNames3, "EmptyState-description--".concat(size), children !== undefined), _classNames3));
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: WrapperClass
    }), /*#__PURE__*/React.createElement("img", {
      src: imageSrc,
      height: imageHeight[size]
    }), /*#__PURE__*/React.createElement(Heading, {
      size: HeadingSize[size],
      className: HeadingClass
    }, title), /*#__PURE__*/React.createElement(Text$1, {
      size: textSize[size],
      className: TextClass,
      appearance: "subtle"
    }, description), children && children);
  };
  EmptyState.displayName = 'EmptyState';

  var ModalHeader = function ModalHeader(props) {
    var _classNames;

    var className = props.className,
        heading = props.heading,
        subHeading = props.subHeading,
        onClose = props.onClose,
        seperator = props.seperator,
        backIcon = props.backIcon,
        backIconCallback = props.backIconCallback;
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {
      'Modal-header': true
    }, _defineProperty$w(_classNames, 'Modal-header--backIcon', backIcon), _defineProperty$w(_classNames, 'Modal-header--seperator', seperator), _classNames), className);
    var wrapperClass = classnames(_defineProperty$w({
      'Modal-headerWrapper': true
    }, 'Modal-headerWrapper--backIcon', backIcon));
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-ModalHeader"
    }, baseProps, {
      className: classes
    }), /*#__PURE__*/React.createElement("div", {
      className: wrapperClass
    }, backIcon && /*#__PURE__*/React.createElement(Icon, {
      name: "keyboard_backspace",
      size: 20,
      className: "ml-3 mr-5 my-3 px-2 py-2 cursor-pointer",
      onClick: backIconCallback
    }), /*#__PURE__*/React.createElement("div", {
      className: "Modal-headerHeading"
    }, /*#__PURE__*/React.createElement(Heading, null, heading), /*#__PURE__*/React.createElement(Icon, {
      size: 20,
      name: 'close',
      className: 'mx-2 cursor-pointer',
      "data-test": "DesignSystem-ModalHeader--CloseIcon",
      onClick: function onClick(event) {
        return onClose(event, 'IconClick');
      }
    }))), subHeading && /*#__PURE__*/React.createElement(Text$1, {
      "data-test": "DesignSystem-ModalHeader--Subheading",
      appearance: "subtle",
      className: "mt-2 ml-7"
    }, subHeading));
  };
  ModalHeader.displayName = 'ModalHeader';

  var ModalFooter = function ModalFooter(props) {
    var _classNames;

    var open = props.open,
        children = props.children,
        className = props.className,
        stickToBottom = props.stickToBottom,
        seperator = props.seperator,
        inSidesheet = props.inSidesheet;
    var baseProps = extractBaseProps(props);
    var classes = classnames((_classNames = {
      'Modal-footer': true
    }, _defineProperty$w(_classNames, 'Modal-footer--inModal', !inSidesheet), _defineProperty$w(_classNames, 'Modal-footer--seperator', seperator), _defineProperty$w(_classNames, 'Modal-footer--stickToBottom', stickToBottom), _classNames), className);
    var wrapperRef = /*#__PURE__*/React.createRef();
    React.useEffect(function () {
      if (open) {
        if (wrapperRef.current) {
          var _wrapperRef$current;

          var secondaryBtns = (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.querySelectorAll('.Button--basic');
          var secondaryBtn = secondaryBtns[secondaryBtns.length - 1];

          if (secondaryBtn) {
            window.requestAnimationFrame(function () {
              return secondaryBtn.focus({
                preventScroll: true
              });
            });
          }
        }
      }
    }, [open]);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-ModalFooter",
      ref: wrapperRef
    }, baseProps, {
      className: classes
    }), children);
  };
  ModalFooter.defaultProps = {
    stickToBottom: true,
    inSidesheet: false
  };
  ModalFooter.displayName = 'ModalFooter';

  var ModalBody = function ModalBody(props) {
    var children = props.children,
        className = props.className,
        stickFooter = props.stickFooter,
        withFooter = props.withFooter;
    var baseProps = extractBaseProps(props);
    var classes = classnames(_defineProperty$w({
      'Modal-body': true
    }, 'Modal-body--stickFooter', withFooter && stickFooter), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-ModalBody"
    }, baseProps, {
      className: classes
    }), children);
  };
  ModalBody.defaultProps = {
    stickFooter: true,
    withFooter: true
  };
  ModalBody.displayName = 'ModalBody';

  var ModalDescription = function ModalDescription(props) {
    var title = props.title,
        description = props.description,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var classes = classnames({
      'Modal-description': true
    }, className);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-ModalDescription"
    }, baseProps, {
      className: classes
    }), title && /*#__PURE__*/React.createElement(Text$1, {
      weight: "strong",
      "data-test": "DesignSystem-ModalDescription--Title"
    }, title), title && description && /*#__PURE__*/React.createElement("br", null), description && /*#__PURE__*/React.createElement(Text$1, {
      "data-test": "DesignSystem-ModalDescription--Description"
    }, description));
  };
  ModalDescription.displayName = 'ModalDescription';

  var Pagination = function Pagination(props) {
    var _classNames, _classNames2, _classNames3;

    var type = props.type,
        totalPages = props.totalPages,
        onPageChange = props.onPageChange,
        className = props.className;
    var baseProps = extractBaseProps(props);

    var _React$useState = React.useState(props.page),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        page = _React$useState2[0],
        setPage = _React$useState2[1];

    var _React$useState3 = React.useState(false),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        init = _React$useState4[0],
        setInit = _React$useState4[1];

    React.useEffect(function () {
      setPage(props.page);
    }, [props.page]);
    var wrapperClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Pagination', true), _defineProperty$w(_classNames, "Pagination--".concat(type), type), _classNames), className);
    var nextButtonWrapperClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Pagination-buttonWrapper', true), _defineProperty$w(_classNames2, 'Pagination-buttonWrapper--next', true), _classNames2));
    var prevButtonWrapperClass = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'Pagination-buttonWrapper', true), _defineProperty$w(_classNames3, 'Pagination-buttonWrapper--previous', true), _classNames3));
    React.useEffect(function () {
      if (init) {
        if (page >= 1 && page <= totalPages) onPageChange(page);
      }
    }, [page]);

    var inputChangeHandler = function inputChangeHandler(e) {
      e.preventDefault();
      var val = +e.target.value.trim();

      if (val >= 0 && val <= totalPages) {
        if (!init) setInit(true);
        setPage(val);
      }
    };

    var onClickHandler = function onClickHandler(buttonType) {
      setInit(true);

      switch (buttonType) {
        case 'first':
          setPage(1);
          break;

        case 'last':
          setPage(totalPages);
          break;

        case 'prev':
          if (page > 1) setPage(page - 1);
          break;

        case 'next':
          if (page < totalPages) setPage(page + 1);
          break;
      }
    };

    var buttonHelper = [];
    if (type === 'basic') buttonHelper.push('mx-3');else buttonHelper.push('mx-4');
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-Pagination"
    }, baseProps, {
      className: wrapperClass
    }), /*#__PURE__*/React.createElement("div", {
      className: prevButtonWrapperClass
    }, /*#__PURE__*/React.createElement(Button, {
      onClick: function onClick() {
        return onClickHandler('first');
      },
      disabled: page <= 1,
      appearance: "transparent",
      size: "large",
      icon: "first_page",
      "data-test": "DesignSystem-Pagination--FirstButton"
    }), /*#__PURE__*/React.createElement("div", {
      "data-test": "DesignSystem-Pagination--Prev",
      className: ['ml-4'].concat(buttonHelper).join(' ')
    }, /*#__PURE__*/React.createElement(Button, {
      onClick: function onClick() {
        return onClickHandler('prev');
      },
      disabled: page <= 1,
      size: "large",
      icon: "navigate_before",
      "data-test": "DesignSystem-Pagination--PrevButton"
    }))), type === 'jump' && /*#__PURE__*/React.createElement("div", {
      className: "Pagination-pageIndex"
    }, /*#__PURE__*/React.createElement(Input, {
      name: "page",
      type: "number",
      size: "large",
      onChange: inputChangeHandler,
      value: "".concat(page === 0 ? '' : page),
      "data-test": "DesignSystem-Pagination--Input"
    }), /*#__PURE__*/React.createElement(Text$1, null, " of ".concat(totalPages, " pages"))), /*#__PURE__*/React.createElement("div", {
      className: nextButtonWrapperClass
    }, /*#__PURE__*/React.createElement("div", {
      className: ['mr-4'].concat(buttonHelper).join(' ')
    }, /*#__PURE__*/React.createElement(Button, {
      onClick: function onClick() {
        return onClickHandler('next');
      },
      disabled: page >= totalPages,
      size: "large",
      icon: "navigate_next",
      "data-test": "DesignSystem-Pagination--NextButton"
    })), /*#__PURE__*/React.createElement(Button, {
      onClick: function onClick() {
        return onClickHandler('last');
      },
      disabled: page >= totalPages,
      appearance: "transparent",
      size: "large",
      icon: "last_page",
      "data-test": "DesignSystem-Pagination--LastButton"
    })));
  };
  Pagination.displayName = 'Pagination';
  Pagination.defaultProps = {
    type: 'basic',
    page: 1,
    totalPages: 1
  };

  var EditableInput = function EditableInput(props) {
    var _classNames2, _classNames4;

    var value = props.value,
        error = props.error,
        size = props.size,
        errorMessage = props.errorMessage,
        placeholder = props.placeholder,
        inputOptions = props.inputOptions,
        disableSaveAction = props.disableSaveAction,
        onChange = props.onChange,
        className = props.className;

    var onInputChange = inputOptions.onChange,
        rest = _objectWithoutProperties$a(inputOptions, ["onChange"]);

    var _React$useState = React.useState(value),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        inputValue = _React$useState2[0],
        setInputValue = _React$useState2[1];

    var _React$useState3 = React.useState(false),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        editing = _React$useState4[0],
        setEditing = _React$useState4[1];

    var _React$useState5 = React.useState(false),
        _React$useState6 = _slicedToArray$6(_React$useState5, 2),
        showComponent = _React$useState6[0],
        setShowComponent = _React$useState6[1];

    var inputRef = /*#__PURE__*/React.createRef();
    var baseProps = extractBaseProps(props);
    var EditableInputClass = classnames(_defineProperty$w({}, 'EditableInput', true), className);
    var EditableDefaultClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'EditableInput-default', true), _defineProperty$w(_classNames2, "EditableInput-default--".concat(size), size), _classNames2));
    var InputClass = classnames(_defineProperty$w({}, 'EditableInput-Input--tiny', size === 'tiny'));
    var ActionClass = classnames((_classNames4 = {}, _defineProperty$w(_classNames4, 'EditableInput-actions', true), _defineProperty$w(_classNames4, "EditableInput-actions--".concat(size), size), _classNames4));
    React.useEffect(function () {
      setDefaultComponent();
    }, [value]);

    var setDefaultComponent = function setDefaultComponent() {
      setInputValue(value);
      setEditing(false);
      setShowComponent(false);
    };

    var onSaveChanges = function onSaveChanges() {
      if (onChange) onChange(inputValue);
    };

    var onInputChangeHandler = function onInputChangeHandler(e) {
      setInputValue(e.target.value);
      if (onInputChange) onInputChange(e);
    };

    var onChangeHandler = function onChangeHandler(eventType) {
      var _inputRef$current;

      switch (eventType) {
        case 'edit':
          (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
          setEditing(true);

        case 'hover':
          setShowComponent(true);
          return;

        case 'default':
          setShowComponent(false);
      }
    };

    var inputComponent = /*#__PURE__*/React.createElement(Input, _extends$p({
      defaultValue: inputValue,
      placeholder: placeholder,
      className: InputClass,
      autoFocus: editing,
      size: size,
      onChange: onInputChangeHandler,
      error: error && editing,
      ref: inputRef,
      "data-test": "DesignSystem-EditableInput--Input"
    }, rest));

    var onKeyDown = function onKeyDown(event) {
      if (document.activeElement === inputRef.current) {
        switch (event.key) {
          case 'Enter':
            onSaveChanges();
            break;

          case 'Escape':
            setDefaultComponent();
            break;
        }
      }
    };

    var renderChildren = function renderChildren() {
      if (showComponent) {
        return error && errorMessage && editing ? /*#__PURE__*/React.createElement(Popover, {
          trigger: inputComponent,
          position: "right",
          className: "px-6 py-6 d-flex align-items-center",
          on: "hover"
        }, /*#__PURE__*/React.createElement(Icon, {
          name: "error",
          appearance: 'alert',
          className: "mr-4"
        }), /*#__PURE__*/React.createElement(Text$1, {
          "data-test": "DesignSystem-EditableInput--ErrorPopper",
          appearance: "destructive",
          weight: "medium"
        }, errorMessage)) : inputComponent;
      }

      return /*#__PURE__*/React.createElement("div", {
        className: EditableDefaultClass,
        "data-test": "DesignSystem-EditableInput--Default"
      }, value || placeholder);
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-EditableInput"
    }, baseProps, {
      className: EditableInputClass,
      onKeyDown: onKeyDown
    }), /*#__PURE__*/React.createElement(Editable, {
      onChange: onChangeHandler,
      editing: editing
    }, renderChildren()), editing && /*#__PURE__*/React.createElement("div", {
      className: ActionClass,
      "data-test": "DesignSystem-EditableInput--Actions"
    }, /*#__PURE__*/React.createElement(Button, {
      icon: "clear",
      className: "mr-3",
      size: "tiny",
      onClick: setDefaultComponent,
      "data-test": "DesignSystem-EditableInput--Discard"
    }), /*#__PURE__*/React.createElement(Button, {
      icon: "check",
      appearance: "primary",
      size: "tiny",
      disabled: disableSaveAction,
      onClick: onSaveChanges,
      "data-test": "DesignSystem-EditableInput--Save"
    })));
  };
  EditableInput.defaultProps = {
    size: 'regular',
    placeholder: '',
    value: '',
    inputOptions: {}
  };

  var ProgressRing = function ProgressRing(props) {
    var size = props.size,
        max = props.max,
        value = props.value,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var radius = 20;
    var circumference = 2 * Math.PI * radius;
    var ProgressRingClass = classnames(_defineProperty$w({
      Ring: true
    }, "Ring--".concat(size), size), className);
    var svgProps = {
      viewBox: '0 0 50 50'
    };
    var updatedValue = value > 0 ? Math.min(value, max) * 100 / max : 0;
    var circleProps = {
      cx: 25,
      cy: 25,
      r: radius,
      fill: 'none',
      strokeWidth: '8',
      strokeDasharray: "".concat(circumference, " ").concat(circumference)
    };
    return /*#__PURE__*/React.createElement("svg", _extends$p({
      "data-test": "DesignSystem-ProgressRing"
    }, baseProps, {
      className: ProgressRingClass
    }, svgProps), /*#__PURE__*/React.createElement("circle", _extends$p({
      className: "Ring-background"
    }, circleProps)), /*#__PURE__*/React.createElement("circle", _extends$p({
      className: "Ring-indicator",
      strokeDashoffset: circumference - updatedValue / 100 * circumference
    }, circleProps, {
      "data-test": "DesignSystem-ProgressRing--Circle"
    })));
  };
  ProgressRing.displayName = 'ProgressRing';
  ProgressRing.defaultProps = {
    size: 'regular',
    max: 100
  };

  var Step = function Step(props) {
    var _classNames;

    var label = props.label,
        value = props.value,
        disabled = props.disabled,
        active = props.active,
        completed = props.completed,
        onChange = props.onChange;
    var StepClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Step', true), _defineProperty$w(_classNames, 'Step--active', active), _defineProperty$w(_classNames, 'Step--disabled', disabled), _classNames));

    var onClickHandle = function onClickHandle() {
      if (disabled) return;
      if (onChange) onChange(label, value);
    };

    var iconAppearance = completed ? 'info' : disabled ? 'disabled' : 'default';
    return /*#__PURE__*/React.createElement("div", {
      "data-test": "DesignSystem-Step",
      className: StepClass,
      onClick: onClickHandle
    }, /*#__PURE__*/React.createElement(Icon, {
      "data-test": "DesignSystem-StepIcon",
      name: completed ? 'check_circle' : 'radio_button_unchecked',
      appearance: iconAppearance,
      className: "mr-3 my-4"
    }), label && /*#__PURE__*/React.createElement(Text$1, {
      weight: "medium",
      appearance: disabled ? 'disabled' : 'default'
    }, label));
  };
  Step.displayName = 'Step';

  var Stepper = function Stepper(props) {
    var steps = props.steps,
        active = props.active,
        completed = props.completed,
        onChange = props.onChange,
        className = props.className;
    var baseProps = extractBaseProps(props);

    var onChangeHandler = function onChangeHandler(index, stepLabel, stepValue) {
      if (onChange) onChange(index, completed, stepLabel, stepValue);
    };

    var StepperClass = classnames(_defineProperty$w({}, 'Stepper', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-Stepper"
    }, baseProps, {
      className: StepperClass
    }), steps.map(function (step, index) {
      var label = step.label,
          value = step.value;
      var activeStep = active === index;
      var completedStep = completed >= index;
      var disabled = completed + 1 < index;
      return /*#__PURE__*/React.createElement(Step, {
        key: index,
        label: label,
        value: value,
        active: activeStep,
        completed: completedStep,
        disabled: disabled,
        onChange: function onChange(steplabel, stepvalue) {
          return onChangeHandler(index, steplabel, stepvalue);
        }
      });
    }));
  };
  Stepper.displayName = 'Stepper';
  Stepper.defaultProps = {
    completed: -1,
    active: 0
  };

  var Trigger = function Trigger(props) {
    var inputFormat = props.inputFormat,
        startInputOptions = props.startInputOptions,
        endInputOptions = props.endInputOptions,
        validators = props.validators,
        state = props.state,
        setState = props.setState;
    var init = state.init,
        startDate = state.startDate,
        endDate = state.endDate,
        startError = state.startError,
        endError = state.endError;

    var updateNav = function updateNav(type) {
      if (type === 'start') {
        var _getDateInfo = getDateInfo(startDate),
            year = _getDateInfo.year,
            month = _getDateInfo.month;

        setState({
          yearNav: year,
          monthNav: month
        });
      }

      if (type === 'end') {
        var _getDateInfo2 = getDateInfo(endDate),
            _year = _getDateInfo2.year,
            _month = _getDateInfo2.month;

        setState({
          yearNav: _year,
          monthNav: _month
        });
      }
    };

    var onChangeHandler = function onChangeHandler(_e, val, type) {
      setState({
        open: true
      });

      if (type === 'start') {
        var placeholderChar = startInputOptions.placeholderChar || '_';

        if (val && !val.includes(placeholderChar)) {
          var d = translateToDate(inputFormat, val, validators);

          if (d) {
            setState({
              startDate: d
            });

            if (endDate) {
              var _getDateInfo3 = getDateInfo(endDate),
                  eYear = _getDateInfo3.year,
                  eMonth = _getDateInfo3.month,
                  eDate = _getDateInfo3.date;

              if (compareDate(startDate, 'more', eYear, eMonth, eDate)) {
                setState({
                  endDate: undefined
                });
              }
            }
          }
        }
      }

      if (type === 'end') {
        var _placeholderChar = endInputOptions.placeholderChar ? endInputOptions.placeholderChar : '_';

        if (val && !val.includes(_placeholderChar)) {
          var _d = translateToDate(inputFormat, val, validators);

          if (_d) setState({
            endDate: _d
          });
        }
      }
    };

    var onBlurHandler = function onBlurHandler(_e, val, type) {
      setState({
        init: true
      });

      if (type === 'start') {
        var _startInputOptions$pl = startInputOptions.placeholderChar,
            placeholderChar = _startInputOptions$pl === void 0 ? '_' : _startInputOptions$pl;
        if (!val || val.includes(placeholderChar)) setState({
          startDate: undefined
        });
      }

      if (type === 'end') {
        var _endInputOptions$plac = endInputOptions.placeholderChar,
            _placeholderChar2 = _endInputOptions$plac === void 0 ? '_' : _endInputOptions$plac;

        if (!val || val.includes(_placeholderChar2)) setState({
          endDate: undefined
        });
      }
    };

    var onClearHandler = function onClearHandler(type) {
      setState({
        init: true
      });

      if (type === 'start') {
        setState({
          startDate: undefined
        });
        updateNav('end');
      }

      if (type === 'end') {
        setState({
          endDate: undefined
        });
        updateNav('start');
      }
    };

    var onClickHandler = function onClickHandler(type) {
      var open = state.open;

      if (!open) {
        updateNav(type);
      }
    };

    var mask = date$2[inputFormat];
    var startPlaceholderChar = startInputOptions.placeholderChar || '_';
    var endPlaceholderChar = endInputOptions.placeholderChar || '_';
    var showStartError = startInputOptions.error || startInputOptions.required && startError && init;
    var showEndError = endInputOptions.error || endInputOptions.required && endError && init;
    var startErrorMessage = startInputOptions.caption === undefined ? 'Invalid value' : startInputOptions.caption;
    var endErrorMessage = endInputOptions.caption === undefined ? 'Invalid value' : endInputOptions.caption;
    var startLabel = startInputOptions.label;
    var endLabel = endInputOptions.label;

    var inputValidator = function inputValidator(val) {
      return isValid(validators, val, inputFormat);
    };

    return /*#__PURE__*/React.createElement(Row, null, /*#__PURE__*/React.createElement(Column, {
      size: '6',
      sizeXS: '12',
      className: "DateRangePicker-input DateRangePicker-input--startDate"
    }, startLabel && /*#__PURE__*/React.createElement(Label, {
      required: startInputOptions.required,
      withInput: true
    }, startLabel), /*#__PURE__*/React.createElement(InputMask, _extends$p({
      icon: "events",
      placeholder: inputFormat
    }, startInputOptions, {
      mask: mask,
      value: startDate ? translateToString(inputFormat, startDate) // @ts-ignore
      : init ? InputMask.utils.getDefaultValue(mask, startPlaceholderChar) : '',
      onChange: function onChange(e, val) {
        onChangeHandler(e, val || '', 'start');
      },
      onBlur: function onBlur(e, val) {
        onBlurHandler(e, val || '', 'start');
      },
      onClear: function onClear() {
        return onClearHandler('start');
      },
      onClick: function onClick() {
        return onClickHandler('start');
      },
      error: showStartError,
      caption: showStartError ? startErrorMessage : '',
      validators: [inputValidator],
      clearOnEmptyBlur: false
    }))), /*#__PURE__*/React.createElement(Column, {
      size: '6',
      sizeXS: '12',
      className: "DateRangePicker-input DateRangePicker-input--endDate"
    }, endLabel && /*#__PURE__*/React.createElement(Label, {
      required: endInputOptions.required,
      withInput: true
    }, endLabel), /*#__PURE__*/React.createElement(InputMask, _extends$p({
      icon: "events",
      placeholder: inputFormat
    }, endInputOptions, {
      mask: mask,
      value: endDate ? translateToString(inputFormat, endDate) // @ts-ignore
      : init ? InputMask.utils.getDefaultValue(mask, endPlaceholderChar) : '',
      onChange: function onChange(e, val) {
        onChangeHandler(e, val || '', 'end');
      },
      onBlur: function onBlur(e, val) {
        onBlurHandler(e, val || '', 'end');
      },
      onClear: function onClear() {
        return onClearHandler('end');
      },
      onClick: function onClick() {
        return onClickHandler('end');
      },
      error: showEndError,
      caption: showEndError ? endErrorMessage : '',
      validators: [inputValidator],
      clearOnEmptyBlur: false
    }))));
  };

  var SingleInputTrigger = function SingleInputTrigger(props) {
    var inputFormat = props.inputFormat,
        inputOptions = props.inputOptions,
        validators = props.validators,
        state = props.state,
        setState = props.setState;
    var init = state.init,
        startDate = state.startDate,
        endDate = state.endDate,
        startValue = state.startValue,
        endValue = state.endValue,
        startError = state.startError,
        endError = state.endError;
    var mask = rangeDate[inputFormat];
    var showError = inputOptions.error || inputOptions.required && (startError || endError) && init;
    var errorMessage = inputOptions.caption === undefined ? 'Invalid value' : inputOptions.caption;
    var label = inputOptions.label;
    var _inputOptions$placeho = inputOptions.placeholderChar,
        placeholderChar = _inputOptions$placeho === void 0 ? '_' : _inputOptions$placeho; // @ts-ignore

    var defaultValue = InputMask.utils.getDefaultValue(mask, placeholderChar).split(' - ');
    var sValue = startValue || defaultValue[0];
    var eValue = endValue || defaultValue[1];

    var inputValidator = function inputValidator(val) {
      var _val$split = val.split(' - '),
          _val$split2 = _slicedToArray$6(_val$split, 2),
          startVal = _val$split2[0],
          endVal = _val$split2[1];

      return isValid(validators, startVal, inputFormat) && isValid(validators, endVal, inputFormat);
    };

    var onChangeHandler = function onChangeHandler(_e, val) {
      var date = val.split(' - ');
      var startVal = date[0];
      var endVal = date[1];

      if (startValue !== startVal && startVal && !startVal.includes(placeholderChar)) {
        var startD = translateToDate(inputFormat, startVal, validators);

        if (startD) {
          var isEndDateValid = endValue && !endValue.includes(placeholderChar);
          setState({
            startDate: startD,
            endDate: isEndDateValid ? endDate : undefined
          });

          if (endDate) {
            var _getDateInfo = getDateInfo(endDate),
                eYear = _getDateInfo.year,
                eMonth = _getDateInfo.month,
                eDate = _getDateInfo.date;

            if (compareDate(startDate, 'more', eYear, eMonth, eDate)) {
              setState({
                endDate: undefined
              });
            }
          }
        }
      }

      if (endValue !== endVal && endVal && !endVal.includes(placeholderChar)) {
        var endD = translateToDate(inputFormat, endVal, validators);
        var isStartDateValid = startValue && !startValue.includes(placeholderChar);

        if (endD) {
          setState({
            endDate: endD,
            startDate: isStartDateValid ? startDate : undefined
          });
        }
      }

      setState({
        startValue: startVal,
        endValue: endVal
      });
    };

    var onBlurHandler = function onBlurHandler(_e, val) {
      setState({
        init: true
      });
      var date = val.split(' - ');
      var startVal = date[0];
      var endVal = date[1];
      if (!startVal || startVal.includes(placeholderChar)) setState({
        startDate: undefined
      });
      if (!endVal || endVal.includes(placeholderChar)) setState({
        endDate: undefined
      });
    };

    var onClearHandler = function onClearHandler() {
      setState({
        init: true,
        startDate: undefined,
        endDate: undefined,
        yearNav: undefined,
        monthNav: undefined
      });
    };

    return /*#__PURE__*/React.createElement(Row, null, /*#__PURE__*/React.createElement(Column, null, label && /*#__PURE__*/React.createElement(Label, {
      required: inputOptions.required,
      withInput: true
    }, label), /*#__PURE__*/React.createElement(InputMask, _extends$p({
      icon: "events",
      placeholder: "".concat(inputFormat, " - ").concat(inputFormat)
    }, inputOptions, {
      mask: mask,
      value: !startDate && !endDate && !init ? undefined : "".concat(sValue, " - ").concat(eValue),
      onChange: function onChange(e, val) {
        onChangeHandler(e, val || '');
      },
      onBlur: function onBlur(e, val) {
        onBlurHandler(e, val || '');
      },
      onClear: onClearHandler,
      error: showError,
      caption: showError ? errorMessage : '',
      validators: [inputValidator],
      clearOnEmptyBlur: false
    }))));
  };

  var setDate = function setDate(date) {
    var d = new Date();
    return new Date(d.setDate(date));
  };

  var getCurrentYear = function getCurrentYear() {
    var current = new Date();
    var currentYear = current.getFullYear();
    return currentYear;
  };
  var getCurrentMonth = function getCurrentMonth() {
    var current = new Date();
    var currentMonth = current.getMonth();
    return currentMonth;
  };
  var getCurrentWeek = function getCurrentWeek() {
    var current = new Date();
    var currentDate = current.getDate();
    var currentDay = current.getDay();
    return {
      startDate: setDate(currentDate - currentDay + 1),
      endDate: setDate(currentDate - currentDay + 7)
    };
  };
  var getPreviousWeek = function getPreviousWeek() {
    var current = new Date();
    var currentDate = current.getDate();
    var currentDay = current.getDay();
    return {
      startDate: setDate(currentDate - currentDay - 6),
      endDate: setDate(currentDate - currentDay)
    };
  };
  var getPreviousMonth = function getPreviousMonth() {
    var current = new Date();
    var currentYear = current.getFullYear();
    var currentMonth = current.getMonth();
    return {
      endDate: new Date(currentYear, currentMonth, 0),
      startDate: new Date(currentYear - +(currentMonth < 0), (currentMonth + 11) % 12, 1)
    };
  };
  var getPrevious90Days = function getPrevious90Days() {
    var current = new Date();
    var currentDate = current.getDate();
    return {
      startDate: setDate(currentDate - 90),
      endDate: setDate(currentDate)
    };
  };
  var getCustomDates = function getCustomDates() {
    var current = new Date();
    var currentDate = current.getDate();
    return {
      startDate: setDate(currentDate),
      endDate: setDate(currentDate)
    };
  };

  var DateRangePicker = /*#__PURE__*/function (_React$Component) {
    _inherits$o(DateRangePicker, _React$Component);

    var _super = _createSuper(DateRangePicker);

    function DateRangePicker(props) {
      var _this;

      _classCallCheck$p(this, DateRangePicker);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "monthsInView", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "getDate", function (startDate, endDate) {
        var inputFormat = _this.props.inputFormat;
        var startVal = startDate ? translateToString(inputFormat, startDate) : '';
        var endVal = endDate ? translateToString(inputFormat, endDate) : '';
        return {
          startValue: startVal,
          endValue: endVal
        };
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getErrors", function (startDate, endDate) {
        var isError = function isError(date) {
          var _this$props = _this.props,
              disabledBefore = _this$props.disabledBefore,
              disabledAfter = _this$props.disabledAfter;

          var _getDateInfo = getDateInfo(disabledBefore),
              dbYear = _getDateInfo.year,
              dbMonth = _getDateInfo.month,
              dbDate = _getDateInfo.date;

          var _getDateInfo2 = getDateInfo(disabledAfter),
              daYear = _getDateInfo2.year,
              daMonth = _getDateInfo2.month,
              daDate = _getDateInfo2.date;

          return !date ? true : compareDate(date, 'less', dbYear, dbMonth, dbDate) || compareDate(date, 'more', daYear, daMonth, daDate);
        };

        var startError = isError(startDate);
        var endError = isError(endDate);

        var _getDateInfo3 = getDateInfo(endDate),
            eYear = _getDateInfo3.year,
            eMonth = _getDateInfo3.month,
            eDate = _getDateInfo3.date;

        if (compareDate(startDate, 'more', eYear, eMonth, eDate)) {
          startError = true;
          endError = true;
        }

        return {
          startError: startError,
          endError: endError
        };
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "getInRangeError", function () {
        var rangeLimit = _this.props.rangeLimit;

        if (rangeLimit) {
          var _this$state = _this.state,
              _startDate2 = _this$state.startDate,
              _endDate2 = _this$state.endDate;

          var _getDateInfo4 = getDateInfo(_startDate2),
              sYear = _getDateInfo4.year,
              sMonth = _getDateInfo4.month,
              sDate = _getDateInfo4.date;

          var _getDateInfo5 = getDateInfo(_endDate2),
              eYear = _getDateInfo5.year,
              eMonth = _getDateInfo5.month,
              eDate = _getDateInfo5.date;

          var limitDate;

          if (_startDate2) {
            limitDate = new Date(_startDate2);
            limitDate.setDate(sDate + rangeLimit);
            return compareDate(limitDate, 'less', eYear, eMonth, eDate + 1);
          }

          if (_endDate2) {
            limitDate = new Date(_endDate2);
            limitDate.setDate(eDate - rangeLimit);
            return compareDate(limitDate, 'more', sYear, sMonth, sDate - 1);
          }
        }

        return false;
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onRangeChangeHandler", function (sDate, eDate) {
        _this.setState({
          init: true,
          startDate: sDate,
          endDate: eDate,
          startValue: sDate ? translateToString(_this.props.inputFormat, sDate) : '',
          endValue: eDate ? translateToString(_this.props.inputFormat, eDate) : ''
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onToggleHandler", function (o, type) {
        switch (type) {
          case 'outsideClick':
            _this.setState({
              open: o
            });

            break;

          case 'onClick':
            _this.setState({
              open: true
            });

            break;
        }
      });

      var _inputFormat = props.inputFormat,
          validators = props.validators;

      var _startDate = convertToDate(props.startDate, _inputFormat, validators);

      var _endDate = convertToDate(props.endDate, _inputFormat, validators);

      var _this$getDate = _this.getDate(_startDate, _endDate),
          startValue = _this$getDate.startValue,
          endValue = _this$getDate.endValue;

      var _this$getErrors = _this.getErrors(_startDate, _endDate),
          _startError = _this$getErrors.startError,
          _endError = _this$getErrors.endError;

      _this.state = {
        startDate: _startDate,
        endDate: _endDate,
        startValue: startValue,
        endValue: endValue,
        startError: _startError,
        endError: _endError,
        init: false,
        open: props.open || false,
        yearNav: props.yearNav,
        monthNav: props.monthNav
      };
      _this.monthsInView = props.monthsInView || (props.withInput ? 2 : 1);
      return _this;
    }

    _createClass$p(DateRangePicker, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (prevProps.startDate !== this.props.startDate) {
          var _this$props2 = this.props,
              inputFormat = _this$props2.inputFormat,
              validators = _this$props2.validators;
          var d = convertToDate(this.props.startDate, inputFormat, validators);
          var val = translateToString(inputFormat, d);
          this.setState({
            startDate: d,
            startValue: val
          });
        }

        if (prevProps.endDate !== this.props.endDate) {
          var _this$props3 = this.props,
              _inputFormat2 = _this$props3.inputFormat,
              _validators = _this$props3.validators;

          var _d = convertToDate(this.props.endDate, _inputFormat2, _validators);

          var _val = translateToString(_inputFormat2, _d);

          this.setState({
            endDate: _d,
            endValue: _val
          });
        }

        if (prevProps.open !== this.props.open) {
          this.setState({
            open: this.props.open || false
          });
        }

        if (prevProps.yearNav !== this.props.yearNav) {
          this.setState({
            yearNav: this.props.yearNav
          });
        }

        if (prevProps.monthNav !== this.props.monthNav) {
          this.setState({
            monthNav: this.props.monthNav
          });
        }

        if (prevState.startDate !== this.state.startDate || prevState.endDate !== this.state.endDate) {
          var _this$props4 = this.props,
              onRangeChange = _this$props4.onRangeChange,
              outputFormat = _this$props4.outputFormat;
          var _this$state2 = this.state,
              _startDate3 = _this$state2.startDate,
              _endDate3 = _this$state2.endDate;

          var _this$getErrors2 = this.getErrors(_startDate3, _endDate3),
              startError = _this$getErrors2.startError,
              endError = _this$getErrors2.endError;

          this.setState({
            startError: startError,
            endError: endError
          });

          if (onRangeChange) {
            var inRangeError = this.getInRangeError();
            var sValue = translateToString(outputFormat, _startDate3);
            var eValue = translateToString(outputFormat, _endDate3);

            if (!inRangeError && !startError && !endError) {
              onRangeChange(_startDate3, _endDate3, sValue, eValue);
            } else {
              if (!startError) onRangeChange(_startDate3, undefined, sValue, eValue);else if (!endError) onRangeChange(undefined, _endDate3, sValue, eValue);else onRangeChange(undefined, undefined, sValue, eValue);
            }
          }
        }
      }
    }, {
      key: "renderCalendar",
      value: function renderCalendar() {
        var _this$props5 = this.props;
            _this$props5.startDate;
            _this$props5.endDate;
            _this$props5.yearNav;
            _this$props5.monthNav;
            _this$props5.open;
            var inputFormat = _this$props5.inputFormat;
            _this$props5.outputFormat;
            _this$props5.startInputOptions;
            _this$props5.endInputOptions;
            var validators = _this$props5.validators;
            _this$props5.withInput;
            _this$props5.position;
            var disabledBefore = _this$props5.disabledBefore,
            disabledAfter = _this$props5.disabledAfter;
            _this$props5.onRangeChange;
            var rangeLimit = _this$props5.rangeLimit,
            rest = _objectWithoutProperties$a(_this$props5, ["startDate", "endDate", "yearNav", "monthNav", "open", "inputFormat", "outputFormat", "startInputOptions", "endInputOptions", "validators", "withInput", "position", "disabledBefore", "disabledAfter", "onRangeChange", "rangeLimit"]);

        var _this$state3 = this.state,
            startDate = _this$state3.startDate,
            endDate = _this$state3.endDate,
            yearNav = _this$state3.yearNav,
            monthNav = _this$state3.monthNav;
        return /*#__PURE__*/React.createElement(Calendar, _extends$p({}, rest, {
          monthsInView: this.monthsInView,
          rangePicker: true,
          startDate: convertToDate(startDate, inputFormat, validators),
          endDate: convertToDate(endDate, inputFormat, validators),
          disabledBefore: convertToDate(disabledBefore, inputFormat, validators),
          disabledAfter: convertToDate(disabledAfter, inputFormat, validators),
          onRangeChange: this.onRangeChangeHandler,
          yearNav: yearNav,
          monthNav: monthNav,
          rangeLimit: rangeLimit
        }));
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames;

        var _this$props6 = this.props,
            withInput = _this$props6.withInput,
            startInputOptions = _this$props6.startInputOptions,
            endInputOptions = _this$props6.endInputOptions,
            inputOptions = _this$props6.inputOptions,
            inputFormat = _this$props6.inputFormat,
            position = _this$props6.position,
            validators = _this$props6.validators,
            singleInput = _this$props6.singleInput,
            contentAlign = _this$props6.contentAlign,
            children = _this$props6.children;
        var open = this.state.open;
        var RangePickerClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'DateRangePicker', true), _defineProperty$w(_classNames, "DateRangePicker--".concat(contentAlign), contentAlign), _classNames));

        if (withInput) {
          var trigger = singleInput ? /*#__PURE__*/React.createElement(SingleInputTrigger, {
            inputFormat: inputFormat,
            inputOptions: inputOptions,
            validators: validators,
            state: this.state,
            setState: this.setState.bind(this)
          }) : /*#__PURE__*/React.createElement(Trigger, {
            inputFormat: inputFormat,
            startInputOptions: startInputOptions,
            endInputOptions: endInputOptions,
            validators: validators,
            state: this.state,
            setState: this.setState.bind(this)
          });
          return /*#__PURE__*/React.createElement(Popover, {
            trigger: trigger,
            triggerClass: "w-100",
            className: RangePickerClass,
            position: position,
            appendToBody: true,
            open: open,
            onToggle: this.onToggleHandler
          }, children, this.renderCalendar());
        }

        return this.renderCalendar();
      }
    }]);

    return DateRangePicker;
  }(React.Component); // @ts-ignore

  _defineProperty$w(DateRangePicker, "defaultProps", _objectSpread2(_objectSpread2({}, Calendar.defaultProps), {}, {
    children: /*#__PURE__*/React.createElement(React.Fragment, null),
    contentAlign: 'left',
    monthsInView: undefined,
    position: 'bottom-start',
    inputFormat: 'mm/dd/yyyy',
    outputFormat: 'mm/dd/yyyy',
    validators: [date$3],
    inputOptions: {
      label: 'Date'
    },
    startInputOptions: {
      label: 'Start Date'
    },
    endInputOptions: {
      label: 'End Date'
    }
  }));

  DateRangePicker.utils = {
    getCurrentWeek: getCurrentWeek,
    getPreviousWeek: getPreviousWeek,
    getPreviousMonth: getPreviousMonth,
    getPrevious90Days: getPrevious90Days,
    getCustomDates: getCustomDates,
    getCurrentYear: getCurrentYear,
    getCurrentMonth: getCurrentMonth
  };

  var TabsWrapper = function TabsWrapper(props) {
    var children = props.children,
        onTabChange = props.onTabChange,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var tabs = Array.isArray(children) ? children : [children];
    var totalTabs = tabs.length;

    var _React$useState = React.useState(props.active && props.active < totalTabs ? props.active : 0),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        active = _React$useState2[0],
        setActiveTab = _React$useState2[1];

    React.useEffect(function () {
      setActiveTab(props.active && props.active < totalTabs ? props.active : 0);
    }, [props.active]);
    var wrapperClass = classnames(_defineProperty$w({}, 'TabsWrapper', true), className);

    var tabClickHandler = function tabClickHandler(tabIndex) {
      setActiveTab(tabIndex);
      if (onTabChange) onTabChange(tabIndex);
    };

    var TabsHeader = tabs.map(function (child, index) {
      var _classNames2;

      var _child$props = child.props,
          label = _child$props.label,
          disabled = _child$props.disabled;
      var tabHeaderClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Tab', true), _defineProperty$w(_classNames2, 'Tab--disabled', disabled), _defineProperty$w(_classNames2, 'Tab--active', !disabled && active === index), _classNames2));
      return /*#__PURE__*/React.createElement("div", {
        "data-test": "DesignSystem-Tabs--Header",
        key: index,
        className: tabHeaderClass,
        onClick: function onClick() {
          return !disabled && tabClickHandler(index);
        }
      }, label);
    });
    return /*#__PURE__*/React.createElement("div", _extends$p({
      "data-test": "DesignSystem-TabsWrapper"
    }, baseProps, {
      className: wrapperClass
    }), /*#__PURE__*/React.createElement("div", {
      className: "TabsWrapper-header"
    }, TabsHeader), /*#__PURE__*/React.createElement("div", {
      className: "TabsWrapper-content",
      "data-test": "DesignSystem-Tabs--Content"
    }, tabs[active]));
  };
  TabsWrapper.displayName = 'TabsWrapper';

  var Tab = function Tab(props) {
    var children = props.children;
    return /*#__PURE__*/React.createElement(React.Fragment, null, children);
  };
  Tab.displayName = 'Tab';

  var accepts = function accepts(file, acceptedFiles) {
    if (file && acceptedFiles) {
      var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(',');
      var fileName = file.name || '';
      var mimeType = (file.type || '').toLowerCase();
      var baseMimeType = mimeType.replace(/\/.*$/, '');
      return acceptedFilesArray.some(function (type) {
        var validType = type.trim().toLowerCase();

        if (validType.charAt(0) === '.') {
          return fileName.toLowerCase().endsWith(validType);
        }

        if (validType.endsWith('/*')) {
          return baseMimeType === validType.replace(/\/.*$/, '');
        }

        return mimeType === validType;
      });
    }

    return true;
  };
  var isPropagationStopped = function isPropagationStopped(event) {
    if (typeof event.isPropagationStopped === 'function') {
      return event.isPropagationStopped();
    }

    if (typeof event.cancelBubble !== 'undefined') {
      return event.cancelBubble;
    }

    return false;
  };
  var isEvtWithFiles = function isEvtWithFiles(event) {
    if (!event.dataTransfer) {
      return !!event.target && !!event.target.files;
    }

    return Array.prototype.some.call(event.dataTransfer.types, function (type) {
      return type === 'Files' || type === 'application/x-moz-file';
    });
  };
  var onDocumentDragOver = function onDocumentDragOver(event) {
    event.preventDefault();
  };
  var composeEventHandlers = function composeEventHandlers() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }

    return function (event) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return fns.some(function (fn) {
        if (!isPropagationStopped(event) && fn) {
          fn.apply(void 0, [event].concat(args));
        }

        return isPropagationStopped(event);
      });
    };
  };
  var reducer = function reducer(state, action) {
    switch (action.type) {
      case 'focus':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          isFocused: true
        });

      case 'blur':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          isFocused: false
        });

      case 'openDialog':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          isFileDialogActive: true
        });

      case 'closeDialog':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          isFileDialogActive: false
        });

      case 'setDraggedFiles':
        /* eslint no-case-declarations: 0 */
        var isDragActive = action.isDragActive,
            draggedFiles = action.draggedFiles;
        return _objectSpread2(_objectSpread2({}, state), {}, {
          draggedFiles: draggedFiles,
          isDragActive: isDragActive
        });

      case 'setFiles':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          acceptedFiles: action.acceptedFiles,
          fileRejections: action.fileRejections
        });

      case 'reset':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          isFileDialogActive: false,
          isDragActive: false,
          draggedFiles: [],
          acceptedFiles: [],
          fileRejections: []
        });

      default:
        return state;
    }
  };

  var fileErrorMessages = {
    FILE_INVALID_TYPE: 'File format not accepted',
    FILE_TOO_LARGE: 'File is too large',
    FILE_TOO_SMALL: 'File is too small',
    TOO_MANY_FILES: 'Multiple files are not accepted'
  };

  var isDefined = function isDefined(value) {
    return value !== undefined && value !== null;
  };

  var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr(accept) {
    var updatedAccept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
    var messageSuffix = Array.isArray(updatedAccept) ? "one of ".concat(updatedAccept.join(', ')) : updatedAccept;
    return {
      type: 'FILE_INVALID_TYPE',
      message: "File type must be ".concat(messageSuffix)
    };
  };
  var getTooLargeRejectionErr = function getTooLargeRejectionErr(maxSize) {
    return {
      type: 'FILE_TOO_LARGE',
      message: "File is larger than ".concat(maxSize, " bytes")
    };
  };
  var getTooSmallRejectionErr = function getTooSmallRejectionErr(minSize) {
    return {
      type: 'FILE_TOO_SMALL',
      message: "File is smaller than ".concat(minSize, " bytes")
    };
  };
  var fileAccepted = function fileAccepted(file, accept) {
    var isAcceptable = file.type === 'application/x-moz-file' || accepts(file, accept);
    return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
  };
  var fileMatchSize = function fileMatchSize(file, minSize, maxSize) {
    if (isDefined(file.size)) {
      if (isDefined(minSize) && isDefined(maxSize)) {
        if (file.size > maxSize) return [false, getTooLargeRejectionErr(maxSize)];
        if (file.size < minSize) return [false, getTooSmallRejectionErr(minSize)];
      } else if (isDefined(minSize) && file.size < minSize) {
        return [false, getTooSmallRejectionErr(minSize)];
      } else if (isDefined(maxSize) && file.size > maxSize) {
        return [false, getTooLargeRejectionErr(maxSize)];
      }
    }

    return [true, null];
  };
  var getFileError = function getFileError(options) {
    var files = options.files,
        accept = options.accept,
        minSize = options.minSize,
        maxSize = options.maxSize,
        multiple = options.multiple;

    if (!multiple && files.length > 1) {
      return 'TOO_MANY_FILES';
    }

    var typeError = files.every(function (file) {
      var _fileAccepted = fileAccepted(file, accept),
          _fileAccepted2 = _slicedToArray$6(_fileAccepted, 1),
          accepted = _fileAccepted2[0];

      return !accepted;
    });
    var sizeError = files.every(function (file) {
      var _fileMatchSize = fileMatchSize(file, minSize, maxSize),
          _fileMatchSize2 = _slicedToArray$6(_fileMatchSize, 1),
          sizeMatch = _fileMatchSize2[0];

      return !sizeMatch;
    });
    return typeError ? 'FILE_INVALID_TYPE' : sizeError ? 'FILE_TOO_LARGE' : '';
  };
  var allFilesAccepted = function allFilesAccepted(options) {
    var files = options.files,
        accept = options.accept,
        minSize = options.minSize,
        maxSize = options.maxSize,
        multiple = options.multiple;

    if (!multiple && files.length > 1) {
      return false;
    }

    return files.every(function (file) {
      var _fileAccepted3 = fileAccepted(file, accept),
          _fileAccepted4 = _slicedToArray$6(_fileAccepted3, 1),
          accepted = _fileAccepted4[0];

      var _fileMatchSize3 = fileMatchSize(file, minSize, maxSize),
          _fileMatchSize4 = _slicedToArray$6(_fileMatchSize3, 1),
          sizeMatch = _fileMatchSize4[0];

      return accepted && sizeMatch;
    });
  };

  var COMMON_MIME_TYPES = new Map([['avi', 'video/avi'], ['gif', 'image/gif'], ['ico', 'image/x-icon'], ['jpeg', 'image/jpeg'], ['jpg', 'image/jpeg'], ['mkv', 'video/x-matroska'], ['mov', 'video/quicktime'], ['mp4', 'video/mp4'], ['pdf', 'application/pdf'], ['png', 'image/png'], ['zip', 'application/zip'], ['doc', 'application/msword'], ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']]);
  var FILES_TO_IGNORE = ['.DS_Store', 'Thumbs.db'];
  function fromEvent(_x) {
    return _fromEvent.apply(this, arguments);
  }

  function _fromEvent() {
    _fromEvent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(evt) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", isDragEvt(evt) && evt.dataTransfer ? getDataTransferFiles(evt.dataTransfer, evt.type) : getInputFiles(evt));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _fromEvent.apply(this, arguments);
  }

  function isDragEvt(value) {
    return !!value.dataTransfer;
  }

  function toFileWithPath(file, path) {
    var f = withMimeType(file);

    if (typeof f.path !== 'string') {
      var _ref = file,
          webkitRelativePath = _ref.webkitRelativePath;
      Object.defineProperty(f, 'path', {
        value: typeof path === 'string' ? path : typeof webkitRelativePath === 'string' && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
        writable: false,
        configurable: false,
        enumerable: true
      });
    }

    return f;
  }

  function withMimeType(file) {
    var name = file.name;
    var hasExtension = name && name.lastIndexOf('.') !== -1;

    if (hasExtension && !file.type) {
      var ext = name.split('.').pop().toLowerCase();
      var type = COMMON_MIME_TYPES.get(ext);

      if (type) {
        Object.defineProperty(file, 'type', {
          value: type,
          writable: false,
          configurable: false,
          enumerable: true
        });
      }
    }

    return file;
  }

  function getInputFiles(evt) {
    var files = isInput(evt.target) ? evt.target.files ? fromList(evt.target.files) : [] : [];
    return files.map(function (file) {
      return toFileWithPath(file);
    });
  }

  function isInput(value) {
    return value !== null;
  }

  function getDataTransferFiles(_x2, _x3) {
    return _getDataTransferFiles.apply(this, arguments);
  }

  function _getDataTransferFiles() {
    _getDataTransferFiles = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(dt, type) {
      var items, files;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!dt.items) {
                _context3.next = 8;
                break;
              }

              items = fromList(dt.items).filter(function (item) {
                return item.kind === 'file';
              });

              if (!(type !== 'drop')) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt("return", items);

            case 4:
              _context3.next = 6;
              return Promise.all(items.map(toFilePromises));

            case 6:
              files = _context3.sent;
              return _context3.abrupt("return", noIgnoredFiles(flatten(files)));

            case 8:
              return _context3.abrupt("return", noIgnoredFiles(fromList(dt.files).map(function (file) {
                return toFileWithPath(file);
              })));

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _getDataTransferFiles.apply(this, arguments);
  }

  function noIgnoredFiles(files) {
    return files.filter(function (file) {
      return FILES_TO_IGNORE.indexOf(file.name) === -1;
    });
  }

  function fromList(items) {
    var files = []; // tslint:disable: prefer-for-of

    for (var i = 0; i < items.length; i++) {
      var file = items[i];
      files.push(file);
    }

    return files;
  }

  function toFilePromises(item) {
    if (typeof item.webkitGetAsEntry !== 'function') {
      return fromDataTransferItem(item);
    }

    var entry = item.webkitGetAsEntry();

    if (entry && entry.isDirectory) {
      return fromDirEntry(entry);
    }

    return fromDataTransferItem(item);
  }

  function flatten(items) {
    return items.reduce(function (acc, files) {
      return [].concat(_toConsumableArray$9(acc), _toConsumableArray$9(Array.isArray(files) ? flatten(files) : [files]));
    }, []);
  }

  function fromDataTransferItem(item) {
    var file = item.getAsFile();

    if (!file) {
      return Promise.reject("".concat(item, " is not a File"));
    }

    var fwp = toFileWithPath(file);
    return Promise.resolve(fwp);
  }

  function fromEntry(_x4) {
    return _fromEntry.apply(this, arguments);
  }

  function _fromEntry() {
    _fromEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(entry) {
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _fromEntry.apply(this, arguments);
  }

  function fromDirEntry(entry) {
    var reader = entry.createReader();
    return new Promise(function (resolve, reject) {
      var entries = [];

      function readEntries() {
        reader.readEntries( /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(batch) {
            var files, items;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (batch.length) {
                      _context.next = 13;
                      break;
                    }

                    _context.prev = 1;
                    _context.next = 4;
                    return Promise.all(entries);

                  case 4:
                    files = _context.sent;
                    resolve(files);
                    _context.next = 11;
                    break;

                  case 8:
                    _context.prev = 8;
                    _context.t0 = _context["catch"](1);
                    reject(_context.t0);

                  case 11:
                    _context.next = 16;
                    break;

                  case 13:
                    items = Promise.all(batch.map(fromEntry));
                    entries.push(items); // Continue reading

                    readEntries();

                  case 16:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[1, 8]]);
          }));

          return function (_x5) {
            return _ref2.apply(this, arguments);
          };
        }(), function (err) {
          reject(err);
        });
      }

      readEntries();
    });
  }

  function fromFileEntry(_x6) {
    return _fromFileEntry.apply(this, arguments);
  }

  function _fromFileEntry() {
    _fromFileEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(entry) {
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", new Promise(function (resolve, reject) {
                entry.file(function (file) {
                  var fwp = toFileWithPath(file, entry.fullPath);
                  resolve(fwp);
                }, function (err) {
                  reject(err);
                });
              }));

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _fromFileEntry.apply(this, arguments);
  }

  var initialState = {
    isFocused: false,
    isFileDialogActive: false,
    isDragActive: false,
    isDragAccept: false,
    isDragReject: false,
    draggedFiles: [],
    acceptedFiles: [],
    fileRejections: []
  };
  var DropzoneBase = function DropzoneBase(props) {
    var accept = props.accept,
        disabled = props.disabled,
        maxSize = props.maxSize,
        minSize = props.minSize,
        multiple = props.multiple,
        onDragEnter = props.onDragEnter,
        onDragLeave = props.onDragLeave,
        onDragOver = props.onDragOver,
        onDrop = props.onDrop,
        onDropAccepted = props.onDropAccepted,
        onDropRejected = props.onDropRejected,
        onFileDialogCancel = props.onFileDialogCancel,
        getFilesFromEvent = props.getFilesFromEvent,
        preventDropOnDocument = props.preventDropOnDocument,
        validator = props.validator;
    var rootRef = React.useRef(null);
    var inputRef = React.useRef(null);

    var _useReducer = React.useReducer(reducer, initialState),
        _useReducer2 = _slicedToArray$6(_useReducer, 2),
        state = _useReducer2[0],
        dispatch = _useReducer2[1];

    var isFocused = state.isFocused,
        isFileDialogActive = state.isFileDialogActive,
        draggedFiles = state.draggedFiles;
    var openFileDialog = React.useCallback(function () {
      if (inputRef.current) {
        dispatch({
          type: 'openDialog'
        }); // @ts-ignore

        inputRef.current.value = null; // @ts-ignore

        inputRef.current.click();
      }
    }, [dispatch]);

    var onWindowFocus = function onWindowFocus() {
      if (isFileDialogActive) {
        setTimeout(function () {
          if (inputRef.current) {
            // @ts-ignore
            var _files = inputRef.current.files;

            if (!_files.length) {
              dispatch({
                type: 'closeDialog'
              });

              if (typeof onFileDialogCancel === 'function') {
                onFileDialogCancel();
              }
            }
          }
        }, 300);
      }
    };

    React.useEffect(function () {
      window.addEventListener('focus', onWindowFocus, false);
      return function () {
        window.removeEventListener('focus', onWindowFocus, false);
      };
    }, [inputRef, isFileDialogActive, onFileDialogCancel]); // Cb to open the file dialog when SPACE/ENTER occurs on the dropzone

    var onKeyDownCb = React.useCallback(function (event) {
      // @ts-ignore
      if (!rootRef.current || !rootRef.current.isEqualNode(event.target)) {
        return;
      }

      if (event.keyCode === 32 || event.keyCode === 13) {
        event.preventDefault();
        openFileDialog();
      }
    }, [rootRef, inputRef]); // Update focus state for the dropzone

    var onFocusCb = React.useCallback(function () {
      dispatch({
        type: 'focus'
      });
    }, []);
    var onBlurCb = React.useCallback(function () {
      dispatch({
        type: 'blur'
      });
    }, []);
    var dragTargetsRef = React.useRef([]);

    var onDocumentDrop = function onDocumentDrop(event) {
      // @ts-ignore
      if (rootRef.current && rootRef.current.contains(event.target)) {
        return;
      }

      event.preventDefault();
      dragTargetsRef.current = [];
    };

    React.useEffect(function () {
      if (preventDropOnDocument) {
        document.addEventListener('dragover', onDocumentDragOver, false);
        document.addEventListener('drop', onDocumentDrop, false);
      }

      return function () {
        if (preventDropOnDocument) {
          document.removeEventListener('dragover', onDocumentDragOver);
          document.removeEventListener('drop', onDocumentDrop);
        }
      };
    }, [rootRef, preventDropOnDocument]);
    var onDragEnterCb = React.useCallback(function (event) {
      event.preventDefault();
      event.persist(); // @ts-ignore

      dragTargetsRef.current = [].concat(_toConsumableArray$9(dragTargetsRef.current), [event.target]);

      if (isEvtWithFiles(event)) {
        Promise.resolve(getFilesFromEvent(event)).then(function (files) {
          if (isPropagationStopped(event)) {
            return;
          }

          dispatch({
            draggedFiles: files,
            isDragActive: true,
            type: 'setDraggedFiles'
          });

          if (onDragEnter) {
            onDragEnter(event);
          }
        });
      }
    }, [getFilesFromEvent, onDragEnter]);
    var onDragOverCb = React.useCallback(function (event) {
      event.preventDefault();
      event.persist();

      if (event.dataTransfer) {
        try {
          event.dataTransfer.dropEffect = 'copy';
        } catch (_unused) {}
        /* eslint-disable-line no-empty */

      }

      if (isEvtWithFiles(event) && onDragOver) {
        onDragOver(event);
      }

      return false;
    }, [onDragOver]);
    var onDragLeaveCb = React.useCallback(function (event) {
      event.preventDefault();
      event.persist();
      var targets = dragTargetsRef.current.filter( // @ts-ignore
      function (target) {
        return rootRef.current && rootRef.current.contains(target);
      }); // @ts-ignore

      var targetIdx = targets.indexOf(event.target);

      if (targetIdx !== -1) {
        targets.splice(targetIdx, 1);
      }

      dragTargetsRef.current = targets;

      if (targets.length > 0) {
        return;
      }

      dispatch({
        isDragActive: false,
        type: 'setDraggedFiles',
        draggedFiles: []
      });

      if (isEvtWithFiles(event) && onDragLeave) {
        onDragLeave(event);
      }
    }, [rootRef, onDragLeave]);
    var onDropCb = React.useCallback(function (event) {
      event.preventDefault(); // Persist here because we need the event later after getFilesFromEvent() is done

      event.persist();
      dragTargetsRef.current = [];

      if (isEvtWithFiles(event)) {
        Promise.resolve(getFilesFromEvent(event)).then(function (files) {
          if (isPropagationStopped(event)) {
            return;
          }

          var acceptedFiles = [];
          var fileRejections = [];
          files.forEach(function (file) {
            var _fileAccepted = fileAccepted(file, accept),
                _fileAccepted2 = _slicedToArray$6(_fileAccepted, 2),
                accepted = _fileAccepted2[0],
                acceptError = _fileAccepted2[1];

            var _fileMatchSize = fileMatchSize(file, minSize, maxSize),
                _fileMatchSize2 = _slicedToArray$6(_fileMatchSize, 2),
                sizeMatch = _fileMatchSize2[0],
                sizeError = _fileMatchSize2[1];

            var customErrors = validator ? validator(file) : null;

            if (accepted && sizeMatch && !customErrors) {
              acceptedFiles.push(file);
            } else {
              var errors = [acceptError, sizeError];

              if (customErrors) {
                errors = errors.concat(customErrors);
              }

              fileRejections.push({
                file: file,
                errors: errors.filter(function (e) {
                  return e;
                })
              });
            }
          });
          dispatch({
            acceptedFiles: acceptedFiles,
            fileRejections: fileRejections,
            type: 'setFiles'
          });

          if (onDrop) {
            onDrop(event, acceptedFiles, fileRejections);
          }

          if (fileRejections.length > 0 && onDropRejected) {
            onDropRejected(event, fileRejections);
          }

          if (acceptedFiles.length > 0 && onDropAccepted) {
            onDropAccepted(event, acceptedFiles);
          }
        });
      }

      dispatch({
        type: 'reset'
      });
    }, [multiple, accept, minSize, maxSize, getFilesFromEvent, onDrop, onDropAccepted, onDropRejected]);

    var composeHandler = function composeHandler(fn) {
      return disabled ? null : fn;
    };

    var composeKeyboardHandler = function composeKeyboardHandler(_fn) {
      return null;
    };

    var composeDragHandler = function composeDragHandler(fn) {
      return composeHandler(fn);
    };

    var getRootProps = React.useMemo(function () {
      return function () {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$refKey = _ref.refKey,
            refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
            onKeyDown = _ref.onKeyDown,
            onFocus = _ref.onFocus,
            onBlur = _ref.onBlur;
            _ref.onClick;
            var onDragEnterCallback = _ref.onDragEnterCallback,
            onDragOverCallback = _ref.onDragOverCallback,
            onDragLeaveCallback = _ref.onDragLeaveCallback,
            onDropCallback = _ref.onDropCallback,
            rest = _objectWithoutProperties$a(_ref, ["refKey", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnterCallback", "onDragOverCallback", "onDragLeaveCallback", "onDropCallback"]);

        return _objectSpread2(_defineProperty$w({
          onKeyDown: composeKeyboardHandler(composeEventHandlers(onKeyDown, onKeyDownCb)),
          onFocus: composeKeyboardHandler(composeEventHandlers(onFocus, onFocusCb)),
          onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)),
          // onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
          onDragEnter: composeDragHandler(composeEventHandlers(onDragEnterCallback, onDragEnterCb)),
          onDragOver: composeDragHandler(composeEventHandlers(onDragOverCallback, onDragOverCb)),
          onDragLeave: composeDragHandler(composeEventHandlers(onDragLeaveCallback, onDragLeaveCb)),
          onDrop: composeDragHandler(composeEventHandlers(onDropCallback, onDropCb))
        }, refKey, rootRef), rest);
      };
    }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, disabled]);
    var onInputElementClick = React.useCallback(function (event) {
      event.stopPropagation();
    }, []);
    var getInputProps = React.useMemo(function () {
      return function () {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$refKey = _ref2.refKey,
            refKey = _ref2$refKey === void 0 ? 'ref' : _ref2$refKey,
            onChange = _ref2.onChange,
            onClick = _ref2.onClick,
            rest = _objectWithoutProperties$a(_ref2, ["refKey", "onChange", "onClick"]);

        var inputProps = _defineProperty$w({
          accept: accept,
          multiple: multiple,
          type: 'file',
          style: {
            display: 'none'
          },
          onChange: composeHandler(composeEventHandlers(onChange, onDropCb)),
          onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
          autoComplete: 'off',
          tabIndex: -1
        }, refKey, inputRef);

        return _objectSpread2(_objectSpread2({}, inputProps), rest);
      };
    }, [inputRef, accept, multiple, onDropCb, disabled]);
    var fileCount = draggedFiles.length;
    var isDragAccept = fileCount > 0 && allFilesAccepted({
      accept: accept,
      minSize: minSize,
      maxSize: maxSize,
      multiple: multiple,
      files: draggedFiles
    });
    var isDragReject = fileCount > 0 && !isDragAccept;
    var fileError = isDragReject ? getFileError({
      accept: accept,
      minSize: minSize,
      maxSize: maxSize,
      multiple: multiple,
      files: draggedFiles
    }) : '';
    return _objectSpread2(_objectSpread2({}, state), {}, {
      isDragAccept: isDragAccept,
      isDragReject: isDragReject,
      getRootProps: getRootProps,
      getInputProps: getInputProps,
      rootRef: rootRef,
      inputRef: inputRef,
      draggedFiles: draggedFiles,
      fileError: fileError,
      isFocused: isFocused && !disabled,
      open: composeHandler(openFileDialog)
    });
  };
  DropzoneBase.displayName = 'DropzoneBase';
  DropzoneBase.defaultProps = {
    disabled: false,
    getFilesFromEvent: fromEvent,
    maxSize: Infinity,
    minSize: 0,
    multiple: true,
    preventDropOnDocument: true,
    validator: function validator() {
      return null;
    }
  };

  var DropzoneActive = function DropzoneActive(props) {
    var _classNames;

    var type = props.type;
    var IconClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Dropzone-stateIcon', true), _defineProperty$w(_classNames, "Dropzone-stateIcon--".concat(type), type), _classNames));
    return /*#__PURE__*/React.createElement(React.Fragment, null, type !== 'tight' && /*#__PURE__*/React.createElement(Icon, {
      name: "archive",
      size: 64,
      appearance: "info",
      className: IconClass
    }), /*#__PURE__*/React.createElement(Text$1, {
      appearance: "link",
      size: "large",
      weight: "strong"
    }, "Drop your files here"));
  };
  DropzoneActive.displayName = 'DropzoneActive';

  var DropzoneError = function DropzoneError(props) {
    var _classNames;

    var type = props.type,
        error = props.error;
    var IconClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Dropzone-stateIcon', true), _defineProperty$w(_classNames, "Dropzone-stateIcon--".concat(type), type), _classNames));
    return /*#__PURE__*/React.createElement(React.Fragment, null, type !== 'tight' && /*#__PURE__*/React.createElement(Icon, {
      name: "error",
      size: 64,
      appearance: "alert",
      className: IconClass
    }), /*#__PURE__*/React.createElement(Text$1, {
      appearance: "destructive",
      size: "large",
      weight: "strong"
    }, error));
  };
  DropzoneError.displayName = 'DropzoneError';

  var Dropzone = function Dropzone(props) {
    var _classNames, _classNames2, _classNames3;

    var type = props.type,
        sizeLabel = props.sizeLabel,
        className = props.className,
        formatLabel = props.formatLabel,
        sampleFileLink = props.sampleFileLink,
        disabled = props.disabled;

    var _DropzoneBase = DropzoneBase(props),
        open = _DropzoneBase.open,
        getRootProps = _DropzoneBase.getRootProps,
        getInputProps = _DropzoneBase.getInputProps,
        isDragActive = _DropzoneBase.isDragActive,
        isDragReject = _DropzoneBase.isDragReject,
        fileError = _DropzoneBase.fileError;

    var baseProps = extractBaseProps(props);
    var DropzoneClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'Dropzone', true), _defineProperty$w(_classNames, "Dropzone--".concat(type), type), _defineProperty$w(_classNames, 'Dropzone--disabled', disabled), _defineProperty$w(_classNames, 'Dropzone--active', isDragActive), _defineProperty$w(_classNames, 'Dropzone--error', isDragReject), _classNames), className);
    var IconClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'Dropzone-icon', true), _defineProperty$w(_classNames2, "Dropzone-icon--".concat(type), true), _defineProperty$w(_classNames2, 'Dropzone-icon--disabled', disabled), _classNames2));
    var WrapperClass = classnames((_classNames3 = {}, _defineProperty$w(_classNames3, 'DropzoneWrapper', true), _defineProperty$w(_classNames3, "DropzoneWrapper--".concat(type), true), _classNames3));

    if (isDragReject) {
      return /*#__PURE__*/React__default['default'].createElement("div", _extends$p({}, getRootProps(), baseProps, {
        className: DropzoneClass
      }), /*#__PURE__*/React__default['default'].createElement(DropzoneError, {
        type: type,
        error: fileErrorMessages[fileError]
      }));
    }

    if (isDragActive) {
      return /*#__PURE__*/React__default['default'].createElement("div", _extends$p({}, getRootProps(), baseProps, {
        className: DropzoneClass
      }), /*#__PURE__*/React__default['default'].createElement(DropzoneActive, {
        type: type
      }));
    }

    var renderDropzone = function renderDropzone() {
      if (isDragReject) return /*#__PURE__*/React__default['default'].createElement(DropzoneError, {
        type: type,
        error: fileErrorMessages[fileError]
      });
      if (isDragActive) return /*#__PURE__*/React__default['default'].createElement(DropzoneActive, {
        type: type
      });
      return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, type !== 'tight' && /*#__PURE__*/React__default['default'].createElement(Icon, {
        name: "backup",
        size: 64,
        className: IconClass
      }), /*#__PURE__*/React__default['default'].createElement("div", {
        className: WrapperClass
      }, /*#__PURE__*/React__default['default'].createElement("span", null, /*#__PURE__*/React__default['default'].createElement(Text$1, {
        size: "large",
        weight: "strong",
        className: "mr-2",
        appearance: disabled ? 'disabled' : 'default'
      }, "Drag your files here or"), /*#__PURE__*/React__default['default'].createElement("span", {
        className: "cursor-pointer",
        onClick: open
      }, /*#__PURE__*/React__default['default'].createElement(Text$1, {
        size: "large",
        weight: "strong",
        appearance: disabled ? 'disabled' : 'link'
      }, " browse files")), /*#__PURE__*/React__default['default'].createElement("input", getInputProps())), formatLabel && /*#__PURE__*/React__default['default'].createElement(Text$1, {
        appearance: disabled ? 'disabled' : 'subtle'
      }, formatLabel), sizeLabel && /*#__PURE__*/React__default['default'].createElement(Text$1, {
        appearance: disabled ? 'disabled' : 'subtle'
      }, sizeLabel), sampleFileLink && /*#__PURE__*/React__default['default'].createElement("div", {
        className: "mt-5"
      }, sampleFileLink)));
    };

    return /*#__PURE__*/React__default['default'].createElement("div", _extends$p({}, getRootProps(), baseProps, {
      className: DropzoneClass
    }), renderDropzone());
  };
  Dropzone.displayName = 'Dropzone';
  Dropzone.defaultProps = _objectSpread2(_objectSpread2({}, DropzoneBase.defaultProps), {}, {
    type: 'standard'
  });

  var FileUploaderFormat = function FileUploaderFormat(props) {
    var formatLabel = props.formatLabel;

    if (formatLabel) {
      return /*#__PURE__*/React.createElement(Text$1, {
        size: "small",
        appearance: "subtle",
        className: "mt-4"
      }, formatLabel);
    }

    return null;
  };
  FileUploaderFormat.displayName = 'FileUploaderFormat';

  var FileUploaderButton = function FileUploaderButton(props) {
    var accept = props.accept,
        multiple = props.multiple,
        uploadButtonLabel = props.uploadButtonLabel,
        disabled = props.disabled,
        name = props.name,
        className = props.className,
        id = props.id,
        _onChange = props.onChange;
    var baseProps = extractBaseProps(props);
    var FileUploaderButtonClass = classnames(_defineProperty$w({}, 'FileUploaderButton', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: FileUploaderButtonClass
    }), /*#__PURE__*/React.createElement(Button, {
      disabled: disabled,
      icon: "backup"
    }, uploadButtonLabel), /*#__PURE__*/React.createElement("input", {
      name: name,
      id: id,
      accept: accept && accept.join(', '),
      multiple: multiple,
      disabled: disabled,
      type: "file",
      tabIndex: -1,
      className: "FileUploaderButton-input",
      onChange: function onChange(event) {
        var fileList = event.target.files ? Array.from(event.target.files) : [];
        if (_onChange) _onChange(fileList, event);
      }
    }));
  };
  FileUploaderButton.defaultProps = {
    uploadButtonLabel: 'Upload files',
    disabled: false,
    multiple: false
  };
  FileUploaderButton.displayName = 'FileUploaderButton';

  var FileUploader = function FileUploader(props) {
    var accept = props.accept,
        multiple = props.multiple,
        disabled = props.disabled,
        title = props.title,
        uploadButtonLabel = props.uploadButtonLabel,
        sizeLabel = props.sizeLabel,
        formatLabel = props.formatLabel,
        sampleFileLink = props.sampleFileLink,
        className = props.className,
        id = props.id,
        name = props.name,
        onChange = props.onChange;
    var baseProps = extractBaseProps(props);
    var FileUploaderClass = classnames(_defineProperty$w({}, 'FileUploader', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: FileUploaderClass
    }), /*#__PURE__*/React.createElement(Text$1, {
      weight: "medium"
    }, title), /*#__PURE__*/React.createElement(FileUploaderFormat, {
      formatLabel: formatLabel
    }), /*#__PURE__*/React.createElement(Text$1, {
      size: "small",
      appearance: "subtle",
      className: !formatLabel ? 'mt-4' : ''
    }, sizeLabel), sampleFileLink && /*#__PURE__*/React.createElement("div", {
      className: "mt-4"
    }, sampleFileLink), /*#__PURE__*/React.createElement(FileUploaderButton, {
      id: id,
      name: name,
      accept: accept,
      multiple: multiple,
      disabled: disabled,
      uploadButtonLabel: uploadButtonLabel,
      onChange: onChange,
      className: "mt-5"
    }));
  };
  FileUploader.defaultProps = Object.assign({}, FileUploaderButton.defaultProps, {
    title: 'Upload files',
    sizeLabel: 'Maximum size: 25 MB'
  });
  FileUploader.displayName = 'FileUploader';

  var FileUploaderStatus = function FileUploaderStatus(props) {
    var progress = props.progress,
        status = props.status,
        onRetry = props.onRetry;

    switch (status) {
      case 'uploading':
        return /*#__PURE__*/React.createElement(ProgressRing, {
          size: "small",
          value: progress,
          className: "mr-4"
        });

      case 'error':
        return /*#__PURE__*/React.createElement(Icon, {
          name: "refresh",
          size: 20,
          onClick: onRetry,
          className: "mr-4 cursor-pointer"
        });

      default:
        return null;
    }
  };
  FileUploaderStatus.displayName = 'FileUploaderStatus';
  FileUploaderStatus.defaultProps = {
    status: 'completed',
    progress: 0
  };

  var FileUploaderItem = function FileUploaderItem(props) {
    var file = props.file,
        id = props.id,
        status = props.status,
        errorMessage = props.errorMessage,
        progress = props.progress,
        _onClick = props.onClick,
        onDelete = props.onDelete,
        _onRetry = props.onRetry,
        className = props.className;
    var name = file.name;
    var baseProps = extractBaseProps(props);
    var FileItemClass = classnames(_defineProperty$w({}, 'FileUploaderItem', true), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: FileItemClass,
      onClick: function onClick() {
        return _onClick && _onClick(file, id);
      }
    }), /*#__PURE__*/React.createElement("div", {
      className: "FileUploaderItem-file"
    }, /*#__PURE__*/React.createElement(Text$1, {
      className: "FileUploaderItem-text",
      appearance: status === 'completed' ? 'default' : 'subtle'
    }, name), /*#__PURE__*/React.createElement("div", {
      className: "d-flex align-items-center"
    }, /*#__PURE__*/React.createElement(FileUploaderStatus, {
      file: file,
      id: id,
      status: status,
      progress: progress,
      onRetry: function onRetry() {
        return _onRetry && _onRetry(file, id);
      }
    }), /*#__PURE__*/React.createElement(Icon, {
      name: "close",
      size: 20,
      onClick: function onClick() {
        return onDelete && onDelete(file, id);
      },
      className: "py-2 px-2 my-3 mx-3 cursor-pointer"
    }))), status === 'error' && /*#__PURE__*/React.createElement(Caption, {
      error: true
    }, errorMessage));
  };
  FileUploaderItem.defaultProps = {
    status: 'completed',
    progress: 0,
    errorMessage: 'Network Error'
  };
  FileUploaderItem.displayName = 'FileUploaderItem';

  var FileUploaderList = function FileUploaderList(props) {
    var fileList = props.fileList,
        onClick = props.onClick,
        onDelete = props.onDelete,
        onRetry = props.onRetry,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var FileListClass = classnames(_defineProperty$w({}, 'FileUploaderList', true), className);
    if (fileList.length === 0) return null;
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: FileListClass
    }), fileList.map(function (fileName, i) {
      return /*#__PURE__*/React.createElement(FileUploaderItem, _extends$p({
        key: i,
        onDelete: onDelete,
        onRetry: onRetry,
        onClick: onClick
      }, fileName));
    }));
  };
  FileUploaderList.defaultProps = {
    fileList: []
  };
  FileUploaderList.displayName = 'FileUploaderList';

  var resizeCol = function resizeCol(_this, name, el) {
    var elX = el === null || el === void 0 ? void 0 : el.getBoundingClientRect().x;

    function resizable(ev) {
      ev.preventDefault();

      if (elX) {
        _this.updateColumnSchema(name, {
          width: ev.pageX - elX
        });
      }
    }

    window.addEventListener('mousemove', resizable);
    window.addEventListener('mouseup', function () {
      window.removeEventListener('mousemove', resizable);
    });
  };
  function sortColumn(name, type) {
    var sortingList = _toConsumableArray$9(this.props.sortingList);

    var index = sortingList.findIndex(function (l) {
      return l.name === name;
    });

    if (index !== -1) {
      sortingList = [].concat(_toConsumableArray$9(sortingList.slice(0, index)), _toConsumableArray$9(sortingList.slice(index + 1)));
    }

    if (type !== 'unsort') sortingList.push({
      name: name,
      type: type
    });
    this.updateSortingList(sortingList);
  }
  function pinColumn(name, type) {
    var schemaUpdate = {
      pinned: type !== 'unpin' ? type : undefined
    };
    this.updateColumnSchema(name, schemaUpdate);
  }
  function hideColumn(name, value) {
    var schemaUpdate = {
      hidden: value
    };
    this.updateColumnSchema(name, schemaUpdate);
  }
  function getWidth(width) {
    var isPercent = typeof width === 'string' && width.slice(-1) === '%';

    if (isPercent) {
      if (this.state.init) {
        var checkboxCell = this.gridRef.querySelector('.Grid-cell--checkbox');
        var checkboxWidth = checkboxCell ? checkboxCell.clientWidth : 0;
        var gridWidth = this.gridRef.clientWidth - checkboxWidth;
        return gridWidth * (+width.slice(0, -1) / 100);
      }

      return 0;
    }

    return width;
  }
  function getCellSize(cellType) {
    var sizes = {
      AVATAR: {
        minWidth: 48
      },
      AVATAR_WITH_TEXT: {
        width: 256
      },
      AVATAR_WITH_META_LIST: {
        width: 256
      },
      ICON: {
        minWdth: 48
      },
      STATUS_HINT: {
        width: 96
      },
      WITH_META_LIST: {
        width: 176
      },
      DEFAULT: {
        width: 176
      }
    };
    return sizes[cellType];
  }

  var updateBatchData = function updateBatchData(data, rowIndexes, dataUpdate) {
    var updatedData = _toConsumableArray$9(data);

    var _iterator = _createForOfIteratorHelper(rowIndexes),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var rowIndex = _step.value;
        updatedData[rowIndex] = _objectSpread2(_objectSpread2({}, updatedData[rowIndex]), dataUpdate);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return updatedData;
  };
  function translateData(schema, data) {
    var newData = _objectSpread2({}, data);

    if (schema.translate) {
      var translatedData = schema.translate(data);
      newData[schema.name] = translatedData !== null && _typeof$p(translatedData) === 'object' ? _objectSpread2(_objectSpread2({}, newData[schema.name]), translatedData) : translatedData;
    }

    if (newData[schema.name] === null || _typeof$p(newData[schema.name]) !== 'object') {
      newData[schema.name] = {
        title: newData[schema.name]
      };
    }

    return newData;
  }
  var filterData = function filterData() {
    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var filterList = arguments.length > 2 ? arguments[2] : undefined;
    var filteredData = data;

    if (filterList) {
      Object.keys(filterList).forEach(function (schemaName) {
        var filters = filterList[schemaName];
        var sIndex = schema.findIndex(function (s) {
          return s.name === schemaName;
        });
        var onFilterChange = schema[sIndex].onFilterChange;

        if (filters.length && onFilterChange) {
          filteredData = filteredData.filter(function (d) {
            return onFilterChange(d, filters);
          });
        }
      });
    }

    return filteredData;
  };
  var sortData = function sortData() {
    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var sortingList = arguments.length > 2 ? arguments[2] : undefined;

    var sortedData = _toConsumableArray$9(data);

    sortingList === null || sortingList === void 0 ? void 0 : sortingList.forEach(function (l) {
      var sIndex = schema.findIndex(function (s) {
        return s.name === l.name;
      });

      if (sIndex !== -1) {
        var defaultComparator = function defaultComparator(a, b) {
          var aData = translateData(schema[sIndex], a);
          var bData = translateData(schema[sIndex], b);
          return aData[l.name].title.localeCompare(bData[l.name].title);
        };

        var _schema$sIndex$compar = schema[sIndex].comparator,
            comparator = _schema$sIndex$compar === void 0 ? defaultComparator : _schema$sIndex$compar;
        sortedData.sort(comparator);
        if (l.type === 'desc') sortedData.reverse();
      }
    });
    return sortedData;
  };
  var paginateData = function paginateData() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var page = arguments.length > 1 ? arguments[1] : undefined;
    var pageSize = arguments.length > 2 ? arguments[2] : undefined;
    var start = (page - 1) * pageSize;
    var end = start + pageSize;
    var paginatedData = data.slice(start, end);
    return paginatedData;
  };

  var moveToIndex = function moveToIndex(arr, from, to) {
    if (from === to) return arr;
    var newArr = arr;

    if (from < to) {
      newArr = [].concat(_toConsumableArray$9(arr.slice(0, from)), _toConsumableArray$9(arr.slice(from + 1, to + 1)), [arr[from]], _toConsumableArray$9(arr.slice(to + 1)));
    } else {
      newArr = [].concat(_toConsumableArray$9(arr.slice(0, to)), [arr[from]], _toConsumableArray$9(arr.slice(to, from)), _toConsumableArray$9(arr.slice(from + 1)));
    }

    return newArr;
  };
  var getTotalPages = function getTotalPages(totalRecords, pageSize) {
    return Math.ceil(totalRecords / pageSize);
  };
  var getSelectAll = function getSelectAll(data) {
    if (data.length) {
      var anyUnSelected = data.some(function (d) {
        return !d._selected;
      });
      var allUnSelected = data.every(function (d) {
        return !d._selected;
      });
      var indeterminate = data.length >= 0 && anyUnSelected && !allUnSelected;
      var checked = !indeterminate && !allUnSelected;
      return {
        indeterminate: indeterminate,
        checked: checked
      };
    }

    return {
      indeterminate: false,
      checked: false
    };
  };
  var getInit = function getInit(schema) {
    return schema && !!schema.length;
  };
  var getSchema = function getSchema(_this) {
    var _this$props = _this.props,
        loading = _this$props.loading,
        loaderSchema = _this$props.loaderSchema;
    var schema = _this.props.schema;
    var init = getInit(schema);

    if (!init && loading) {
      schema = loaderSchema;
    }

    return schema;
  };

  // import * as React from 'react';
  var GridNestedRow = function GridNestedRow(props) {
    var _this = props._this,
        data = props.data,
        rowIndex = props.rowIndex;
    var _this$props = _this.props,
        schema = _this$props.schema,
        loading = _this$props.loading,
        nestedRowRenderer = _this$props.nestedRowRenderer;
    if (nestedRowRenderer) return nestedRowRenderer({
      data: data,
      schema: schema,
      loading: loading,
      rowIndex: rowIndex
    }); // return (
    //   <Text>{JSON.stringify(data)}</Text>
    // )
    // const {
    //   schema: propSchema
    // } = _this.props;
    // if (data._expanded) {
    //   const showHead = data._expanded.showHead;
    //   const schema = data._expanded.schema || propSchema;
    //   let gridData = data._expanded.data;
    //   if (!gridData) {
    //     const {
    //       _uid,
    //       _expanded,
    //       ...rest
    //     } = data;
    //     gridData = [rest];
    //   }
    //   return (
    //     <div className="Grid-expandedRow">
    //       <Grid
    //         key={'expanedRow'}
    //         showHead={showHead}
    //         data={gridData}
    //         schema={schema}
    //         totalRecords={gridData.length}
    //       />
    //     </div>
    //   );
    // }

    return null;
  };

  var HeaderCell = function HeaderCell(props) {
    var _this = props._this,
        schema = props.schema,
        draggable = props.draggable;
    var _this$props = _this.props,
        schemaProp = _this$props.schema,
        loading = _this$props.loading,
        showMenu = _this$props.showMenu,
        sortingList = _this$props.sortingList,
        filterList = _this$props.filterList,
        headCellTooltip = _this$props.headCellTooltip,
        showFilters = _this$props.showFilters;
    var _schema$sorting = schema.sorting,
        sorting = _schema$sorting === void 0 ? true : _schema$sorting,
        name = schema.name,
        filters = schema.filters,
        pinned = schema.pinned;
    var init = getInit(schemaProp);
    var listIndex = sortingList.findIndex(function (l) {
      return l.name === name;
    });
    var sorted = listIndex !== -1 ? sortingList[listIndex].type : null;
    var el = /*#__PURE__*/React.createRef();
    var sortOptions = [{
      label: 'Sort Ascending',
      value: 'sortAsc',
      icon: 'arrow_downward'
    }, {
      label: 'Sort Descending',
      value: 'sortDesc',
      icon: 'arrow_upward'
    }];
    var pinOptions = [{
      label: 'Pin Left',
      value: 'pinLeft',
      icon: 'skip_previous'
    }, {
      label: 'Pin Right',
      value: 'pinRight',
      icon: 'skip_next'
    }];
    var unpinOption = {
      label: 'Unpin',
      value: 'unpin',
      icon: 'replay'
    };
    if (pinned === 'left') pinOptions[0] = unpinOption;
    if (pinned === 'right') pinOptions[1] = unpinOption;
    var hideOptions = [{
      label: 'Hide Column',
      value: 'hide',
      icon: 'cancel'
    }];
    var unsortOption = {
      label: 'Unsort',
      value: 'unsort',
      icon: 'unfold_more'
    };
    if (sorted === 'asc') sortOptions[0] = unsortOption;
    if (sorted === 'desc') sortOptions[1] = unsortOption;
    var options = [].concat(pinOptions, hideOptions);
    if (sorting) options = [].concat(sortOptions, _toConsumableArray$9(options));
    var classes = classnames({
      'Grid-headCell': true,
      'Grid-headCell--draggable': draggable
    });
    var filterOptions = filters ? filters.map(function (f) {
      return _objectSpread2(_objectSpread2({}, f), {}, {
        selected: filterList[name] && filterList[name].findIndex(function (fl) {
          return fl === f.value;
        }) !== -1
      });
    }) : [];

    var renderLabel = function renderLabel() {
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Text$1, {
        weight: "strong",
        className: "ellipsis--noWrap"
      }, schema.displayName), sorting && /*#__PURE__*/React.createElement("div", {
        className: "Grid-sortingIcons"
      }, sorted ? sorted === 'asc' ? /*#__PURE__*/React.createElement(Icon, {
        name: "arrow_downward"
      }) : /*#__PURE__*/React.createElement(Icon, {
        name: "arrow_upward"
      }) : /*#__PURE__*/React.createElement(Icon, {
        name: "unfold_more"
      })));
    };

    return /*#__PURE__*/React.createElement("div", {
      key: name,
      className: classes,
      ref: el
    }, /*#__PURE__*/React.createElement("div", {
      className: "Grid-cellContent",
      onClick: function onClick() {
        if (!loading && sorting) {
          if (sorted === 'asc') _this.onMenuChange(name, 'sortDesc');
          if (sorted === 'desc') _this.onMenuChange(name, 'unsort');
          if (!sorted) _this.onMenuChange(name, 'sortAsc');
        }
      }
    }, loading && !init ? /*#__PURE__*/React.createElement(Placeholder, {
      withImage: false
    }, /*#__PURE__*/React.createElement(PlaceholderParagraph, {
      length: "medium"
    })) : /*#__PURE__*/React.createElement(React.Fragment, null, headCellTooltip ? /*#__PURE__*/React.createElement(Tooltip, {
      position: "top-start",
      triggerClass: "w-100 overflow-hidden",
      tooltip: schema.displayName
    }, renderLabel()) : renderLabel())), showFilters && filters && /*#__PURE__*/React.createElement(React.Fragment, null, loading && !init ? /*#__PURE__*/React.createElement("span", null, /*#__PURE__*/React.createElement(Placeholder, null)) : /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Dropdown, {
      menu: true,
      showApplyButton: true,
      withCheckbox: true,
      triggerOptions: {
        customTrigger: function customTrigger() {
          return /*#__PURE__*/React.createElement(Button, {
            icon: "filter_list",
            appearance: "transparent"
          });
        }
      },
      options: filterOptions,
      align: 'left',
      onChange: function onChange(selected) {
        return _this.onFilterChange(name, selected);
      },
      minWidth: 176
    }))), showMenu && /*#__PURE__*/React.createElement(React.Fragment, null, loading && !init ? /*#__PURE__*/React.createElement("span", {
      className: "ml-4"
    }, /*#__PURE__*/React.createElement(Placeholder, null)) : /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Dropdown, {
      key: "".concat(name, "-").concat(sorted, "-").concat(pinned),
      menu: true,
      optionType: "WITH_ICON",
      triggerOptions: {
        customTrigger: function customTrigger() {
          return /*#__PURE__*/React.createElement(Button, {
            icon: "more_vert_filled",
            appearance: "transparent"
          });
        }
      },
      options: options,
      align: 'left',
      onChange: function onChange(selected) {
        return _this.onMenuChange(name, selected);
      },
      minWidth: 176
    }))), schema.resizable && /*#__PURE__*/React.createElement("span", {
      className: "Grid-cellResize",
      onMouseDown: function onMouseDown() {
        resizeCol(_this, name, el.current);
      }
    }));
  };

  var BodyCell = function BodyCell(props) {
    var _this = props._this,
        data = props.data,
        schema = props.schema,
        expandedState = props.expandedState,
        rowIndex = props.rowIndex,
        colIndex = props.colIndex;
    var _this$props2 = _this.props,
        size = _this$props2.size,
        loading = _this$props2.loading,
        nestedRows = _this$props2.nestedRows;

    var _expandedState = _slicedToArray$6(expandedState, 2),
        expanded = _expandedState[0],
        setExpanded = _expandedState[1];

    var cellProps = {
      rowIndex: rowIndex,
      colIndex: colIndex,
      size: size,
      schema: schema,
      data: data,
      loading: loading,
      expanded: expanded
    };
    var nestedProps = {
      _this: _this,
      data: data,
      rowIndex: rowIndex
    };
    var isNestedRowDisabled = !GridNestedRow(nestedProps);
    return /*#__PURE__*/React.createElement("div", {
      className: "Grid-cellContent"
    }, colIndex === 0 && nestedRows && /*#__PURE__*/React.createElement(React.Fragment, null, !isNestedRowDisabled ? /*#__PURE__*/React.createElement(Icon, {
      className: 'Grid-nestedRowTrigger',
      name: expanded ? 'keyboard_arrow_up' : 'keyboard_arrow_down',
      size: 20,
      appearance: 'default',
      onClick: function onClick(e) {
        if (!isNestedRowDisabled) {
          e.stopPropagation();
          setExpanded(!expanded);
        }
      }
    }) : /*#__PURE__*/React.createElement("span", {
      className: "Grid-nestedRowPlaceholder"
    })), schema.cellRenderer ? schema.cellRenderer(cellProps) : /*#__PURE__*/React.createElement(GridCell, _extends$p({
      key: "".concat(rowIndex, "-").concat(colIndex)
    }, cellProps)));
  };

  var Cell = function Cell(props) {
    var _this = props._this,
        head = props.head,
        colIndex = props.colIndex,
        firstCell = props.firstCell,
        schema = props.schema,
        expandedState = props.expandedState,
        draggable = props.draggable,
        data = props.data,
        rowIndex = props.rowIndex;
    var _this$props3 = _this.props,
        separator = _this$props3.separator,
        nestedRows = _this$props3.nestedRows;
    var init = _this.state.init;
    var name = schema.name,
        hidden = schema.hidden,
        pinned = schema.pinned,
        _schema$cellType = schema.cellType,
        cellType = _schema$cellType === void 0 ? 'DEFAULT' : _schema$cellType;

    var _getCellSize = getCellSize(cellType),
        width = _getCellSize.width,
        _getCellSize$minWidth = _getCellSize.minWidth,
        minWidth = _getCellSize$minWidth === void 0 ? 96 : _getCellSize$minWidth,
        _getCellSize$maxWidth = _getCellSize.maxWidth,
        maxWidth = _getCellSize$maxWidth === void 0 ? 800 : _getCellSize$maxWidth;

    var cellClass = classnames({
      'Grid-cell': true,
      'Grid-cell--head': head,
      'Grid-cell--body': !head,
      'Grid-cell--separator': !firstCell && (schema.separator !== undefined ? schema.separator : separator),
      'Grid-cell--nestedRow': !head && colIndex === 0 && nestedRows
    });
    if (hidden) return null;
    return /*#__PURE__*/React.createElement("div", {
      key: "".concat(rowIndex, "-").concat(colIndex),
      className: cellClass,
      draggable: head && draggable,
      onDragStart: function onDragStart(e) {
        if (draggable) {
          e.dataTransfer.setData('name', name);
          if (pinned) e.dataTransfer.setData('type', pinned);
        }
      },
      onDragOver: function onDragOver(e) {
        return e.preventDefault();
      },
      onDrop: function onDrop(e) {
        if (draggable) {
          var from = {
            name: e.dataTransfer.getData('name'),
            type: e.dataTransfer.getData('type')
          };
          var to = {
            name: name,
            type: pinned || ''
          };
          if (from.type === to.type) _this.reorderCol(from.name, to.name);
        }
      },
      style: {
        visibility: !init ? 'hidden' : 'visible',
        width: getWidth.call(_this, schema.width || width),
        minWidth: getWidth.call(_this, schema.minWidth || minWidth),
        maxWidth: getWidth.call(_this, schema.maxWidth || maxWidth)
      }
    }, head ? /*#__PURE__*/React.createElement(HeaderCell, {
      _this: _this,
      draggable: draggable,
      colIndex: colIndex,
      schema: schema
    }) : /*#__PURE__*/React.createElement(BodyCell, {
      _this: _this,
      rowIndex: rowIndex,
      colIndex: colIndex,
      data: data,
      schema: schema,
      expandedState: expandedState
    }));
  };

  var GridHead = function GridHead(props) {
    var _this = props._this,
        _props$draggable = props.draggable,
        draggable = _props$draggable === void 0 ? false : _props$draggable,
        withCheckbox = props.withCheckbox;
    var _this$props = _this.props,
        loading = _this$props.loading,
        selectAll = _this$props.selectAll;
    var schema = getSchema(_this);
    var pinnedSchema = schema.filter(function (s) {
      return !s.hidden && s.pinned;
    });
    var leftPinnedSchema = pinnedSchema.filter(function (s) {
      return !s.hidden && s.pinned === 'left';
    });
    var rightPinnedSchema = pinnedSchema.filter(function (s) {
      return !s.hidden && s.pinned === 'right';
    });
    var unpinnedSchema = schema.filter(function (s) {
      return !s.hidden && !s.pinned;
    });

    var renderCheckbox = function renderCheckbox(show) {
      if (!show || !withCheckbox) return null;
      return /*#__PURE__*/React.createElement("div", {
        className: "Grid-cell Grid-cell--head Grid-cell--checkbox"
      }, loading ? /*#__PURE__*/React.createElement(Placeholder, null) : /*#__PURE__*/React.createElement(Checkbox, _extends$p({}, selectAll, {
        onChange: _this.onSelectAll
      })));
    };

    var renderSchema = function renderSchema(currSchema, shouldRenderCheckbox, pinned) {
      if (currSchema.length) {
        var _classNames;

        var classes = classnames((_classNames = {
          'Grid-cellGroup': true,
          'Grid-cellGroup--pinned': pinned
        }, _defineProperty$w(_classNames, "Grid-cellGroup--pinned-".concat(pinned), pinned), _defineProperty$w(_classNames, 'Grid-cellGroup--main', !pinned), _classNames));
        return /*#__PURE__*/React.createElement("div", {
          className: classes
        }, renderCheckbox(shouldRenderCheckbox), currSchema.map(function (s, index) {
          var cI = pinned === 'left' ? index : leftPinnedSchema.length + index;
          if (pinned === 'right') cI += unpinnedSchema.length;
          return /*#__PURE__*/React.createElement(Cell, {
            key: "".concat(cI),
            _this: _this,
            head: true,
            draggable: draggable,
            schema: s,
            colIndex: cI,
            firstCell: !index
          });
        }));
      }

      return null;
    };

    return /*#__PURE__*/React.createElement("div", {
      className: "Grid-head"
    }, /*#__PURE__*/React.createElement("div", {
      className: "Grid-row Grid-row--head"
    }, renderSchema(leftPinnedSchema, !!leftPinnedSchema.length, 'left'), renderSchema(unpinnedSchema, !leftPinnedSchema.length && !!unpinnedSchema.length), renderSchema(rightPinnedSchema, false, 'right')));
  };

  var GridRow = function GridRow(props) {
    var _this = props._this,
        schema = props.schema,
        data = props.data,
        withCheckbox = props.withCheckbox,
        rI = props.rowIndex;
    var rowRef = React.useRef(null);

    var _React$useState = React.useState(false),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        expanded = _React$useState2[0],
        setExpanded = _React$useState2[1];

    var rowClasses = classnames('Grid-row', 'Grid-row--body', {
      'Grid-row--selected': data._selected
    });

    var onClickHandler = function onClickHandler() {
      var type = _this.props.type;

      if (type === 'resource' && !loading) {
        var onRowClick = _this.props.onRowClick;

        if (onRowClick) {
          onRowClick(data, rI);
        }
      }
    };

    var _this$props = _this.props,
        loading = _this$props.loading,
        nestedRows = _this$props.nestedRows;
    var pinnedSchema = schema.filter(function (s) {
      return !s.hidden && s.pinned;
    });
    var leftPinnedSchema = pinnedSchema.filter(function (s) {
      return !s.hidden && s.pinned === 'left';
    });
    var rightPinnedSchema = pinnedSchema.filter(function (s) {
      return !s.hidden && s.pinned === 'right';
    });
    var unpinnedSchema = schema.filter(function (s) {
      return !s.hidden && !s.pinned;
    });

    var renderCheckbox = function renderCheckbox(show) {
      if (!show || !withCheckbox) return null;
      return /*#__PURE__*/React.createElement("div", {
        className: "Grid-cell Grid-cell--body Grid-cell--checkbox",
        onClick: function onClick(e) {
          return e.stopPropagation();
        }
      }, loading ? /*#__PURE__*/React.createElement(Placeholder, null) : /*#__PURE__*/React.createElement(Checkbox, {
        checked: !!data._selected,
        onChange: function onChange(event) {
          _this.onSelect(rI, event.target.checked);
        }
      }));
    };

    var renderSchema = function renderSchema(currSchema, shouldRenderCheckbox, pinned) {
      if (currSchema.length) {
        var _classNames;

        var classes = classnames((_classNames = {
          'Grid-cellGroup': true,
          'Grid-cellGroup--pinned': pinned
        }, _defineProperty$w(_classNames, "Grid-cellGroup--pinned-".concat(pinned), pinned), _defineProperty$w(_classNames, 'Grid-cellGroup--main', !pinned), _classNames));
        return /*#__PURE__*/React.createElement("div", {
          className: classes
        }, renderCheckbox(shouldRenderCheckbox), currSchema.map(function (s, index) {
          var cI = pinned === 'left' ? index : leftPinnedSchema.length + index;
          if (pinned === 'right') cI += unpinnedSchema.length;
          return /*#__PURE__*/React.createElement(Cell, {
            key: "".concat(rI, "-").concat(cI),
            _this: _this,
            rowIndex: rI,
            colIndex: cI,
            firstCell: !index,
            schema: s,
            data: data,
            expandedState: [expanded, setExpanded]
          });
        }));
      }

      return null;
    };

    return /*#__PURE__*/React.createElement("div", {
      className: "Grid-rowWrapper"
    }, /*#__PURE__*/React.createElement("div", {
      className: rowClasses,
      onClick: onClickHandler,
      ref: rowRef
    }, renderSchema(leftPinnedSchema, !!leftPinnedSchema.length, 'left'), renderSchema(unpinnedSchema, !leftPinnedSchema.length && !!unpinnedSchema.length), renderSchema(rightPinnedSchema, false, 'right')), nestedRows && expanded && /*#__PURE__*/React.createElement("div", {
      style: {
        width: rowRef.current ? rowRef.current.clientWidth : 0
      }
    }, /*#__PURE__*/React.createElement(GridNestedRow, {
      _this: _this,
      data: data,
      rowIndex: rI
    })));
  };

  var GridBody = function GridBody(props) {
    var _this = props._this,
        schema = props.schema,
        data = props.data,
        withCheckbox = props.withCheckbox,
        offset = props.offset,
        inView = props.inView,
        avgRowHeight = props.avgRowHeight;
    var buffer = 50;
    var _this$props = _this.props,
        loading = _this$props.loading,
        error = _this$props.error,
        withPagination = _this$props.withPagination,
        page = _this$props.page,
        pageSize = _this$props.pageSize,
        totalRecords = _this$props.totalRecords,
        errorTemplate = _this$props.errorTemplate;

    if (!loading && error) {
      return errorTemplate ? typeof errorTemplate === 'function' ? errorTemplate({}) : errorTemplate : null;
    }

    var totalPages = Math.ceil(totalRecords / pageSize);
    var dummyRows = withPagination && page === totalPages ? totalRecords - (page - 1) * pageSize : pageSize;
    var rows = loading ? Array.from({
      length: dummyRows
    }, function () {
      return {};
    }) : data.slice(offset, offset + buffer);
    var topPadding = Math.max(0, offset * avgRowHeight);
    var bottomPadding = Math.max(0, ((withPagination ? dummyRows : data.length) - inView - offset - 1) * avgRowHeight);
    return /*#__PURE__*/React.createElement("div", {
      className: "Grid-body"
    }, !loading && /*#__PURE__*/React.createElement("div", {
      className: "GridBody-padding",
      style: {
        height: topPadding
      }
    }), rows.map(function (d, rI) {
      return /*#__PURE__*/React.createElement(GridRow, {
        key: offset + rI,
        _this: _this,
        rowIndex: offset + rI,
        data: d,
        schema: schema,
        withCheckbox: withCheckbox
      });
    }), !loading && /*#__PURE__*/React.createElement("div", {
      className: "GridBody-padding",
      style: {
        height: bottomPadding
      }
    }));
  };

  var MainGrid = function MainGrid(props) {
    var _classNames;

    var _this = props._this,
        schema = props.schema,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var _this$props = _this.props,
        loading = _this$props.loading,
        error = _this$props.error,
        type = _this$props.type,
        size = _this$props.size,
        showHead = _this$props.showHead,
        draggable = _this$props.draggable,
        withCheckbox = _this$props.withCheckbox,
        data = _this$props.data;
    var init = _this.state.init;
    var classes = classnames((_classNames = {
      Grid: 'true'
    }, _defineProperty$w(_classNames, "Grid--".concat(type), type), _defineProperty$w(_classNames, "Grid--".concat(size), size), _classNames), className);
    var minRowHeight = {
      comfortable: 40,
      standard: 40,
      compressed: 32,
      tight: 24
    };
    var initialState = {
      offset: 0,
      avgRowHeight: minRowHeight[size],
      inView: 20
    };

    var _React$useState = React.useState(initialState),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        state = _React$useState2[0],
        setState = _React$useState2[1];

    React.useEffect(function () {
      if (init) {
        setState({
          offset: offset,
          avgRowHeight: avgRowHeight,
          inView: _this.gridRef.scrollHeight / avgRowHeight
        });
      }
    }, [init]);
    React.useEffect(function () {
      setState(initialState);

      var el = _this.gridRef.querySelector('.Grid');

      if (el) el.scrollTop = 0;
    }, [loading, error]);
    var offset = state.offset,
        avgRowHeight = state.avgRowHeight,
        inView = state.inView;

    var onScrollHandler = function onScrollHandler() {
      if (!loading) {
        if (_this.gridRef && _this.gridRef) {
          var el = _this.gridRef.querySelector('.Grid');

          if (el) {
            var scrollTop = el.scrollTop;
            var items = el.querySelectorAll('.Grid-body .Grid-row');
            var newScroll = Math.floor(scrollTop - offset * avgRowHeight);
            var newInView = 0;
            var currScroll = 0;
            var i = 0;

            while (i < items.length && currScroll + items[i].clientHeight <= el.clientHeight) {
              var rowHeight = items[i].clientHeight;
              currScroll += rowHeight;
              newInView++;
              i++;
            }

            if (newScroll > 0) {
              currScroll = newScroll;
              var newOffset = offset;
              var newAvgHeight = avgRowHeight;
              i = 0;

              while (i < items.length && currScroll >= items[i].clientHeight) {
                var _rowHeight = items[i].clientHeight;
                currScroll -= _rowHeight;
                newAvgHeight = (newOffset * newAvgHeight + _rowHeight) / (newOffset + 1);
                newOffset++;
                i++;
              }

              newOffset = newOffset < data.length - inView ? newOffset : data.length - inView - 1;

              if (newOffset > offset) {
                setState(_objectSpread2(_objectSpread2({}, state), {}, {
                  inView: newInView,
                  offset: newOffset,
                  avgRowHeight: newAvgHeight
                }));
              }
            } else {
              if (avgRowHeight) {
                var diff = Math.floor(newScroll / avgRowHeight) || -1;

                var _newOffset = offset + diff;

                if (_newOffset < offset) {
                  setState(_objectSpread2(_objectSpread2({}, state), {}, {
                    inView: newInView,
                    offset: _newOffset < 0 ? 0 : _newOffset
                  }));
                }
              }
            }
          }
        }
      }
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: classes,
      onScroll: onScrollHandler
    }), showHead && /*#__PURE__*/React.createElement(GridHead, {
      key: 'GridHead',
      _this: _this,
      schema: schema,
      draggable: draggable,
      withCheckbox: withCheckbox
    }), /*#__PURE__*/React.createElement(GridBody, {
      key: 'GridBody',
      _this: _this,
      schema: schema,
      data: data,
      withCheckbox: withCheckbox,
      offset: offset,
      inView: inView,
      avgRowHeight: avgRowHeight
    }));
  };

  var Grid = /*#__PURE__*/function (_React$Component) {
    _inherits$o(Grid, _React$Component);

    var _super = _createSuper(Grid);

    function Grid(props) {
      var _this;

      _classCallCheck$p(this, Grid);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "gridRef", null);

      _defineProperty$w(_assertThisInitialized$p(_this), "updateRenderedSchema", function (newSchema) {
        var updateSchema = _this.props.updateSchema;

        if (updateSchema) {
          updateSchema(newSchema);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateColumnSchema", function (name, schemaUpdate) {
        var schema = _this.props.schema;

        var newSchema = _toConsumableArray$9(schema);

        var ind = newSchema.findIndex(function (s) {
          return s.name === name;
        });
        newSchema[ind] = _objectSpread2(_objectSpread2({}, newSchema[ind]), schemaUpdate);

        _this.updateRenderedSchema(newSchema);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "reorderCol", function (from, to) {
        var schema = _this.props.schema;
        var fromInd = schema.findIndex(function (s) {
          return s.name === from;
        });
        var toInd = schema.findIndex(function (s) {
          return s.name === to;
        });
        var newSchema = moveToIndex(schema, fromInd, toInd);

        _this.updateRenderedSchema(newSchema);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateSortingList", function (sortingList) {
        var updateSortingList = _this.props.updateSortingList;

        if (updateSortingList) {
          updateSortingList(sortingList);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateFilterList", function (filterList) {
        var updateFilterList = _this.props.updateFilterList;

        if (updateFilterList) {
          updateFilterList(filterList);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onMenuChange", function (name, selected) {
        switch (selected) {
          case 'sortAsc':
            sortColumn.call(_assertThisInitialized$p(_this), name, 'asc');
            break;

          case 'sortDesc':
            sortColumn.call(_assertThisInitialized$p(_this), name, 'desc');
            break;

          case 'unsort':
            sortColumn.call(_assertThisInitialized$p(_this), name, 'unsort');
            break;

          case 'pinLeft':
            pinColumn.call(_assertThisInitialized$p(_this), name, 'left');
            break;

          case 'pinRight':
            pinColumn.call(_assertThisInitialized$p(_this), name, 'right');
            break;

          case 'unpin':
            pinColumn.call(_assertThisInitialized$p(_this), name, 'unpin');
            break;

          case 'hide':
            hideColumn.call(_assertThisInitialized$p(_this), name, true);
            break;
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onFilterChange", function (name, selected) {
        var filterList = _this.props.filterList;

        var newFilterList = _objectSpread2(_objectSpread2({}, filterList), {}, _defineProperty$w({}, name, selected));

        _this.updateFilterList(newFilterList);
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onSelect", function (rowIndex, selected) {
        var onSelect = _this.props.onSelect;

        if (onSelect) {
          onSelect(rowIndex, selected);
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onSelectAll", function (event) {
        var onSelectAll = _this.props.onSelectAll;

        if (onSelectAll) {
          onSelectAll(event.target.checked);
        }
      });

      _this.state = {
        init: false
      };
      return _this;
    }

    _createClass$p(Grid, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var baseProps = extractBaseProps(this.props);
        var schema = getSchema(this);
        return /*#__PURE__*/React.createElement("div", {
          className: "Grid-wrapper",
          ref: function ref(el) {
            _this2.gridRef = el;

            if (el && !_this2.state.init) {
              _this2.setState({
                init: true
              });
            }
          }
        }, /*#__PURE__*/React.createElement(MainGrid, _extends$p({}, baseProps, {
          _this: this,
          schema: schema
        })));
      }
    }]);

    return Grid;
  }(React.Component);

  _defineProperty$w(Grid, "defaultProps", {
    showHead: true,
    loaderSchema: [],
    schema: [],
    data: [],
    type: 'data',
    size: 'standard',
    page: 1,
    pageSize: 15,
    loading: false,
    error: false,
    sortingList: [],
    filterList: {},
    showFilters: true
  });

  var renderTitle = function renderTitle(props) {
    var tooltip = props.tooltip,
        cellData = props.cellData;
    var children = cellData.title;

    if (children !== undefined && children !== null) {
      if (tooltip) {
        return /*#__PURE__*/React.createElement(Tooltip, {
          tooltip: children,
          position: 'top-start',
          triggerClass: "w-100 overflow-hidden"
        }, /*#__PURE__*/React.createElement(Text$1, {
          className: "w-100 ellipsis"
        }, children));
      }

      return /*#__PURE__*/React.createElement(Text$1, {
        className: "w-100 ellipsis"
      }, children);
    }

    return null;
  };

  var renderMetaList = function renderMetaList(props) {
    var cellData = props.cellData;
    var metaList = cellData.metaList;

    if (metaList) {
      return /*#__PURE__*/React.createElement("div", {
        className: "GridCell-metaList"
      }, metaList.map(function (list, index) {
        return /*#__PURE__*/React.createElement(Text$1, {
          key: index,
          className: "ellipsis",
          appearance: 'subtle',
          size: "small"
        }, list);
      }));
    }

    return null;
  };

  var renderAvatar = function renderAvatar(props) {
    var cellData = props.cellData;
    var firstName = cellData.firstName,
        lastName = cellData.lastName,
        title = cellData.title;

    if (firstName || lastName) {
      return /*#__PURE__*/React.createElement(Avatar, {
        className: "mr-5",
        firstName: firstName,
        lastName: lastName
      });
    }

    if (title) {
      return /*#__PURE__*/React.createElement(Avatar, {
        className: "mr-5"
      }, title);
    }

    return null;
  };

  var renderIcon = function renderIcon(props) {
    var cellData = props.cellData;
    var icon = cellData.icon;

    if (icon) {
      return /*#__PURE__*/React.createElement(Icon, {
        name: icon
      });
    }

    return null;
  };

  var renderStatusHint = function renderStatusHint(props) {
    var cellData = props.cellData;
    var statusAppearance = cellData.statusAppearance;
    var children = cellData.title;

    if (children) {
      return /*#__PURE__*/React.createElement(StatusHint, {
        appearance: statusAppearance
      }, children);
    }

    return null;
  };

  var GridCell = function GridCell(props) {
    var size = props.size,
        schema = props.schema,
        loading = props.loading;
    var data = !loading ? translateData(schema, props.data) : {};
    var name = schema.name,
        _schema$cellType = schema.cellType,
        cellType = _schema$cellType === void 0 ? 'DEFAULT' : _schema$cellType,
        _schema$align = schema.align,
        align = _schema$align === void 0 ? 'left' : _schema$align,
        tooltip = schema.tooltip;
    var cellData = data[name];
    var cellClass = classnames(_defineProperty$w({}, 'GridCell', true));

    switch (cellType) {
      case 'DEFAULT':
        return /*#__PURE__*/React.createElement("div", {
          className: "".concat(cellClass, " GridCell--align-").concat(align, " GridCell--default")
        }, loading ? /*#__PURE__*/React.createElement(PlaceholderParagraph, {
          length: "medium"
        }) : renderTitle({
          tooltip: tooltip,
          cellData: cellData
        }));

      case 'WITH_META_LIST':
        return /*#__PURE__*/React.createElement("div", {
          className: "".concat(cellClass, " GridCell--metaList")
        }, loading ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(PlaceholderParagraph, {
          length: "medium"
        }), /*#__PURE__*/React.createElement(PlaceholderParagraph, {
          length: "large",
          size: "xxs"
        })) : /*#__PURE__*/React.createElement(React.Fragment, null, renderTitle({
          tooltip: tooltip,
          cellData: cellData
        }), renderMetaList({
          cellData: cellData
        })));

      case 'AVATAR':
        if (loading) {
          return /*#__PURE__*/React.createElement(Placeholder, {
            className: "GridCell--align-".concat(align),
            imageSize: 'medium',
            round: true
          });
        }

        return /*#__PURE__*/React.createElement("div", {
          className: "".concat(cellClass, " GridCell--align-").concat(align, " GridCell--avatar")
        }, size !== 'tight' && renderAvatar({
          cellData: cellData
        }));

      case 'AVATAR_WITH_TEXT':
        if (loading) {
          return /*#__PURE__*/React.createElement(Placeholder, {
            imageSize: 'medium',
            round: true
          }, /*#__PURE__*/React.createElement(PlaceholderParagraph, {
            className: "ml-3",
            length: "medium"
          }));
        }

        return /*#__PURE__*/React.createElement("div", {
          className: "".concat(cellClass, " GridCell--avatarWithText")
        }, size !== 'tight' && renderAvatar({
          cellData: cellData
        }), renderTitle({
          tooltip: tooltip,
          cellData: cellData
        }));

      case 'AVATAR_WITH_META_LIST':
        if (loading) {
          return /*#__PURE__*/React.createElement(Placeholder, {
            imageSize: 'medium',
            round: true
          }, /*#__PURE__*/React.createElement(PlaceholderParagraph, {
            className: "ml-3",
            length: "medium"
          }), /*#__PURE__*/React.createElement(PlaceholderParagraph, {
            className: "ml-3",
            length: "large"
          }));
        }

        return /*#__PURE__*/React.createElement("div", {
          className: "".concat(cellClass, " GridCell--avatarWithText")
        }, size !== 'tight' && renderAvatar({
          cellData: cellData
        }), /*#__PURE__*/React.createElement("div", {
          className: "GridCell-metaListWrapper"
        }, renderTitle({
          tooltip: tooltip,
          cellData: cellData
        }), renderMetaList({
          cellData: cellData
        })));

      case 'ICON':
        if (loading) {
          return /*#__PURE__*/React.createElement(Placeholder, {
            className: "GridCell--align-".concat(align),
            imageSize: 'small',
            round: true
          });
        }

        return /*#__PURE__*/React.createElement("div", {
          className: "".concat(cellClass, " GridCell--align-").concat(align, " GridCell--icon")
        }, renderIcon({
          cellData: cellData
        }));

      case 'STATUS_HINT':
        return /*#__PURE__*/React.createElement("div", {
          className: "".concat(cellClass, " GridCell--align-").concat(align, " GridCell--statusHint")
        }, loading ? /*#__PURE__*/React.createElement(Placeholder, {
          className: "w-75 flex-grow-0",
          imageSize: 'small',
          round: true
        }, /*#__PURE__*/React.createElement(PlaceholderParagraph, {
          length: "large"
        })) : renderStatusHint({
          cellData: cellData
        }));
    }

    return null;
  };
  GridCell.displayName = 'GridCell';

  var DraggableDropdown = function DraggableDropdown(props) {
    var options = props.options,
        onChange = props.onChange;

    var _React$useState = React.useState(false),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        open = _React$useState2[0],
        setOpen = _React$useState2[1];

    var _React$useState3 = React.useState(options),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        tempOptions = _React$useState4[0],
        setTempOptions = _React$useState4[1];

    var _React$useState5 = React.useState('var(--spacing-8)'),
        _React$useState6 = _slicedToArray$6(_React$useState5, 2),
        triggerWidth = _React$useState6[0],
        setTriggerWidth = _React$useState6[1];

    React.useEffect(function () {
      setTempOptions(options);
    }, [open]);

    var handleParentChange = function handleParentChange(e) {
      setTempOptions(tempOptions.map(function (option) {
        return _objectSpread2(_objectSpread2({}, option), {}, {
          selected: e.target.checked
        });
      }));
    };

    var handleChildChange = function handleChildChange(e, index) {
      var newOptions = _toConsumableArray$9(tempOptions);

      newOptions[index] = _objectSpread2(_objectSpread2({}, newOptions[index]), {}, {
        selected: e.target.checked
      });
      setTempOptions(newOptions);
    };

    var onToggleHandler = function onToggleHandler(newOpen) {
      setOpen(newOpen);
    };

    var onCancelHandler = function onCancelHandler() {
      setOpen(false);
    };

    var onApplyHandler = function onApplyHandler() {
      setOpen(false);
      if (onChange) onChange(tempOptions);
    };

    return /*#__PURE__*/React.createElement("div", {
      className: "Dropdown"
    }, /*#__PURE__*/React.createElement(Popover, {
      open: open,
      onToggle: onToggleHandler,
      trigger: /*#__PURE__*/React.createElement(Button, {
        ref: function ref(el) {
          setTriggerWidth("".concat(el === null || el === void 0 ? void 0 : el.clientWidth, "px"));
        },
        size: "tiny",
        appearance: "transparent",
        icon: "keyboard_arrow_down_filled",
        iconAlign: "right"
      }, "Showing ".concat(options.filter(function (option) {
        return option.selected;
      }).length, " of ").concat(options.length, " columns")),
      triggerClass: "w-100",
      customStyle: {
        width: triggerWidth
      },
      className: "Header-draggableDropdown"
    }, /*#__PURE__*/React.createElement("div", {
      className: "Dropdown-wrapper"
    }, /*#__PURE__*/React.createElement("div", {
      className: "OptionWrapper"
    }, /*#__PURE__*/React.createElement(Checkbox, {
      className: "OptionCheckbox",
      label: "Select All",
      checked: tempOptions.every(function (option) {
        return option.selected;
      }),
      indeterminate: tempOptions.some(function (option) {
        return option.selected;
      }) && tempOptions.some(function (option) {
        return !option.selected;
      }),
      onChange: handleParentChange
    })), tempOptions.map(function (option, index) {
      return /*#__PURE__*/React.createElement("div", {
        key: option.value,
        className: "OptionWrapper d-flex flex-space-between align-items-center cursor-pointer",
        draggable: true,
        onDragStart: function onDragStart(e) {
          e.dataTransfer.setData('index', "".concat(index));
        },
        onDragOver: function onDragOver(e) {
          return e.preventDefault();
        },
        onDrop: function onDrop(e) {
          var from = +e.dataTransfer.getData('index');
          var to = index;
          if (from !== to) setTempOptions(moveToIndex(tempOptions, from, to));
        }
      }, /*#__PURE__*/React.createElement(Checkbox, {
        className: "OptionCheckbox",
        name: option.value,
        label: option.label,
        checked: tempOptions[index].selected,
        onChange: function onChange(e) {
          return handleChildChange(e, index);
        }
      }), /*#__PURE__*/React.createElement(Icon, {
        name: "drag_handle",
        className: "mr-4"
      }));
    })), /*#__PURE__*/React.createElement("div", {
      className: "Dropdown-buttonWrapper"
    }, /*#__PURE__*/React.createElement(Button, {
      className: "mr-4",
      size: "tiny",
      onClick: onCancelHandler
    }, "Cancel"), /*#__PURE__*/React.createElement(Button, {
      appearance: "primary",
      size: "tiny",
      onClick: onApplyHandler
    }, "Apply"))));
  };

  var Header = function Header(props) {
    var loading = props.loading,
        error = props.error,
        data = props.data,
        schema = props.schema,
        withSearch = props.withSearch,
        showHead = props.showHead,
        withPagination = props.withPagination,
        withCheckbox = props.withCheckbox,
        children = props.children,
        updateSchema = props.updateSchema,
        _props$filterList = props.filterList,
        filterList = _props$filterList === void 0 ? {} : _props$filterList,
        updateFilterList = props.updateFilterList,
        _props$totalRecords = props.totalRecords,
        totalRecords = _props$totalRecords === void 0 ? 0 : _props$totalRecords,
        onSelectAll = props.onSelectAll,
        searchPlaceholder = props.searchPlaceholder,
        selectAll = props.selectAll,
        searchTerm = props.searchTerm,
        updateSearchTerm = props.updateSearchTerm,
        dynamicColumn = props.dynamicColumn,
        allowSelectAll = props.allowSelectAll,
        showFilters = props.showFilters;

    var _React$useState = React.useState(false),
        _React$useState2 = _slicedToArray$6(_React$useState, 2),
        selectAllRecords = _React$useState2[0],
        setSelectAllRecords = _React$useState2[1];

    var _React$useState3 = React.useState(true),
        _React$useState4 = _slicedToArray$6(_React$useState3, 2),
        flag = _React$useState4[0],
        setFlag = _React$useState4[1];

    React.useEffect(function () {
      setFlag(!flag);
    }, [schema]);
    React.useEffect(function () {
      if (selectAll && selectAll.checked) {
        if (onSelectAll) onSelectAll(true, selectAllRecords);
      }
    }, [selectAllRecords]);
    React.useEffect(function () {
      if (selectAll && !selectAll.checked) setSelectAllRecords(false);
    }, [selectAll]);
    var filterSchema = schema.filter(function (s) {
      return s.filters;
    });

    var onSearchChange = function onSearchChange(e) {
      var value = e.target.value;

      if (updateSearchTerm) {
        updateSearchTerm(value);
      }
    };

    var onFilterChange = function onFilterChange(name, filters) {
      var newFilterList = _objectSpread2(_objectSpread2({}, filterList), {}, _defineProperty$w({}, name, filters));

      if (updateFilterList) {
        updateFilterList(newFilterList);
      }
    };

    var columnOptions = schema.map(function (s) {
      return {
        label: s.displayName,
        value: s.name,
        selected: !s.hidden
      };
    });

    var onDynamicColumnUpdate = function onDynamicColumnUpdate(options) {
      var newSchema = options.map(function (option) {
        return _objectSpread2(_objectSpread2({}, schema.find(function (colSchema) {
          return colSchema.name === option.value;
        })), {}, {
          hidden: !option.selected
          /* tslint:disable:no-object-literal-type-assertion */

        });
      });
      /* tslint:enable:no-object-literal-type-assertion */

      if (updateSchema) updateSchema(newSchema);
    };

    var selectedCount = data.filter(function (d) {
      return d._selected;
    }).length;
    var label = withCheckbox && selectedCount ? selectAllRecords ? "Selected all ".concat(totalRecords, " items") : "Selected ".concat(selectedCount, " items on this page") : "Showing ".concat(!error ? totalRecords : 0, " items");
    return /*#__PURE__*/React.createElement("div", {
      className: "Header"
    }, /*#__PURE__*/React.createElement("div", {
      className: "Header-content Header-content--top"
    }, withSearch && /*#__PURE__*/React.createElement("div", {
      className: "Header-search"
    }, /*#__PURE__*/React.createElement(Input, {
      name: "GridHeader-search",
      icon: "search",
      placeholder: searchPlaceholder,
      onChange: onSearchChange,
      value: searchTerm,
      onClear: function onClear() {
        return updateSearchTerm && updateSearchTerm('');
      },
      disabled: loading && !getInit(schema)
    })), showFilters && filterSchema.length > 0 && /*#__PURE__*/React.createElement("div", {
      className: "Header-dropdown"
    }, /*#__PURE__*/React.createElement("div", {
      className: "Header-filters"
    }, filterSchema.map(function (s) {
      var name = s.name,
          displayName = s.displayName,
          filters = s.filters;
      var filterOptions = filters ? filters.map(function (f) {
        return _objectSpread2(_objectSpread2({}, f), {}, {
          selected: filterList[name] && filterList[name].findIndex(function (fl) {
            return fl === f.value;
          }) !== -1
        });
      }) : [];
      return /*#__PURE__*/React.createElement(Dropdown, {
        key: name,
        withCheckbox: true,
        showApplyButton: true,
        inlineLabel: displayName,
        icon: 'filter_list',
        options: filterOptions,
        onChange: function onChange(selected) {
          return onFilterChange(name, selected);
        }
      });
    }))), children && /*#__PURE__*/React.createElement("div", {
      className: "Header-actions"
    }, children)), /*#__PURE__*/React.createElement("div", {
      className: "Header-content Header-content--bottom"
    }, /*#__PURE__*/React.createElement("div", {
      className: "Header-label"
    }, !showHead && withCheckbox && !loading && /*#__PURE__*/React.createElement(Checkbox, _extends$p({}, selectAll, {
      onChange: function onChange(event) {
        if (onSelectAll) onSelectAll(event.target.checked);
      }
    })), loading ? /*#__PURE__*/React.createElement(Placeholder, {
      withImage: !showHead && withCheckbox
    }, /*#__PURE__*/React.createElement(PlaceholderParagraph, {
      length: 'small',
      size: 's'
    })) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Label, null, label), withPagination && (selectAll === null || selectAll === void 0 ? void 0 : selectAll.checked) && allowSelectAll && /*#__PURE__*/React.createElement("div", {
      className: "ml-4"
    }, !selectAllRecords ? /*#__PURE__*/React.createElement(Button, {
      size: "tiny",
      onClick: function onClick() {
        return setSelectAllRecords(true);
      }
    }, "Select all ".concat(totalRecords, " items")) : /*#__PURE__*/React.createElement(Button, {
      size: "tiny",
      onClick: function onClick() {
        return setSelectAllRecords(false);
      }
    }, "Clear Selection")))), dynamicColumn && /*#__PURE__*/React.createElement("div", {
      className: "Header-hideColumns"
    }, /*#__PURE__*/React.createElement(DraggableDropdown, {
      options: columnOptions,
      onChange: onDynamicColumnUpdate
    }))));
  };
  Header.defaultProps = {
    schema: [],
    data: [],
    searchPlaceholder: 'Search',
    dynamicColumn: true,
    showFilters: true
  };

  var defaultErrorTemplate = function defaultErrorTemplate(props) {
    var _props$errorType = props.errorType,
        errorType = _props$errorType === void 0 ? 'DEFAULT' : _props$errorType;
    var errorMessages = {
      FAILED_TO_FETCH: 'Failed to fetch data',
      NO_RECORDS_FOUND: 'No results found',
      DEFAULT: 'No results found'
    };
    return /*#__PURE__*/React.createElement(Heading, null, errorMessages[errorType]);
  };

  var defaultProps = {
    type: 'data',
    size: 'standard',
    showHead: true,
    showMenu: true,
    multipleSorting: true,
    headerOptions: {},
    withPagination: true,
    paginationType: 'jump',
    page: 1,
    pageSize: 15,
    draggable: true,
    data: [],
    schema: [],
    loading: false,
    error: false,
    loaderSchema: [],
    sortingList: [],
    filterList: {},
    filterPosition: 'GRID',
    searchDebounceDuration: 750,
    errorTemplate: defaultErrorTemplate
  };
  /**
   * ###Note:
   * 1. Sync Table:
   *  - Manually toggle loading/error state to update data, schema.
   * 2. Async Table:
   *  - fetchData return:
   *    - Promise resolve with no records:
   *      error: true, errorType: 'NO\_RECORDS\_FOUND'
   *    - Promise reject:
   *      error: true, errorType: 'FAILED\_TO\_FETCH'
   * 3. Default errorTemplate:
   * <pre class="DocPage-codeBlock">
   * (props) => {
   *      const { errorType = 'DEFAULT' } = props;
   *      const errorMessages = {
   *        'FAILED\_TO\_FETCH': 'Failed to fetch data',
   *        'NO\_RECORDS\_FOUND': 'No results found',
   *        'DEFAULT': 'No results found'
   *      }
   *      return(
   *        \<Heading>{errorMessages[errorType]}\</Heading>
   *      );
   * }
   * </pre>
   */

  var Table = /*#__PURE__*/function (_React$Component) {
    _inherits$o(Table, _React$Component);

    var _super = _createSuper(Table);

    function Table(props) {
      var _this;

      _classCallCheck$p(this, Table);

      _this = _super.call(this, props);

      _defineProperty$w(_assertThisInitialized$p(_this), "debounceUpdate", void 0);

      _defineProperty$w(_assertThisInitialized$p(_this), "updateData", function (searchUpdate) {
        if (_this.state.async) {
          _this.setState({
            loading: true
          });
        }

        if (searchUpdate) {
          _this.debounceUpdate();
        } else {
          _this.updateDataFn();
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateDataFn", function () {
        var _this$props = _this.props,
            fetchData = _this$props.fetchData,
            pageSize = _this$props.pageSize,
            withPagination = _this$props.withPagination,
            dataProp = _this$props.data,
            onSearch = _this$props.onSearch;
        var _this$state = _this.state,
            async = _this$state.async,
            page = _this$state.page,
            sortingList = _this$state.sortingList,
            filterList = _this$state.filterList,
            searchTerm = _this$state.searchTerm;

        _this.onSelect(-1, false);

        var opts = {
          page: page,
          pageSize: pageSize,
          sortingList: sortingList,
          filterList: filterList,
          searchTerm: searchTerm
        };

        if (!_this.props.withPagination) {
          delete opts.page;
          delete opts.pageSize;
        }

        if (async) {
          if (fetchData) {
            fetchData(opts).then(function (res) {
              var data = res.data;
              var schema = _this.state.schema.length ? _this.state.schema : res.schema;

              _this.setState({
                data: data,
                schema: schema,
                selectAll: getSelectAll(data),
                totalRecords: res.count,
                loading: false,
                error: !data.length,
                errorType: 'NO_RECORDS_FOUND'
              });
            })["catch"](function () {
              _this.setState({
                loading: false,
                error: true,
                errorType: 'FAILED_TO_FETCH'
              });
            });
          }
        } else {
          var schema = _this.state.schema;
          var filteredData = filterData(schema, dataProp, filterList);
          var searchedData = onSearch && opts.searchTerm !== undefined ? onSearch(filteredData, opts.searchTerm) : filteredData;
          var sortedData = sortData(schema, searchedData, sortingList);
          var renderedData = sortedData;
          var totalRecords = sortedData.length;

          if (withPagination && page && pageSize) {
            renderedData = paginateData(renderedData, page, pageSize);
          }

          var renderedSchema = _this.state.schema.length ? _this.state.schema : schema;

          _this.setState({
            totalRecords: totalRecords,
            error: !renderedData.length,
            errorType: 'NO_RECORDS_FOUND',
            selectAll: getSelectAll(renderedData),
            schema: renderedSchema,
            data: renderedData
          });
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onSelect", function (rowIndexes, selected) {
        var data = _this.state.data;
        var onSelect = _this.props.onSelect;
        var indexes = [rowIndexes];
        var newData = data;

        if (rowIndexes >= 0) {
          newData = updateBatchData(data, indexes, {
            _selected: selected
          });

          _this.setState({
            data: newData,
            selectAll: getSelectAll(newData)
          });
        }

        if (onSelect) {
          onSelect(indexes, selected, rowIndexes === -1 ? [] : newData.filter(function (d) {
            return d._selected;
          }));
        }
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onSelectAll", function (selected, selectAll) {
        var onSelect = _this.props.onSelect;
        var data = _this.state.data;
        var indexes = Array.from({
          length: data.length
        }, function (_, i) {
          return i;
        });
        var newData = updateBatchData(data, indexes, {
          _selected: selected
        });

        if (onSelect) {
          onSelect(indexes, selected, newData.filter(function (d) {
            return d._selected;
          }), selectAll);
        }

        _this.setState({
          data: newData,
          selectAll: getSelectAll(newData)
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "onPageChange", function (newPage) {
        _this.setState({
          page: newPage
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateSchema", function (newSchema) {
        _this.setState({
          schema: newSchema
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateSortingList", function (newSortingList) {
        var multipleSorting = _this.props.multipleSorting;

        _this.setState({
          sortingList: multipleSorting ? _toConsumableArray$9(newSortingList) : newSortingList.slice(-1),
          page: 1
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateFilterList", function (newFilterList) {
        _this.setState({
          filterList: newFilterList,
          page: 1
        });
      });

      _defineProperty$w(_assertThisInitialized$p(_this), "updateSearchTerm", function (newSearchTerm) {
        _this.setState({
          searchTerm: newSearchTerm,
          page: 1
        });
      });

      var _async = ('fetchData' in _this.props);

      var _data = props.data || [];

      var _schema = props.schema || [];

      _this.state = {
        async: _async,
        data: !_async ? _data : [],
        schema: !_async ? _schema : [],
        page: props.page,
        sortingList: props.sortingList,
        filterList: props.filterList,
        totalRecords: !_async ? _data.length : 0,
        loading: !_async ? props.loading : true,
        error: !_async ? props.error : false,
        errorType: props.errorType,
        selectAll: getSelectAll([]),
        searchTerm: undefined
      };
      _this.debounceUpdate = debounce$4(props.searchDebounceDuration, _this.updateDataFn);
      return _this;
    }

    _createClass$p(Table, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateData();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        var _this2 = this;

        if (!this.state.async) {
          if (prevProps.loading !== this.props.loading || prevProps.error !== this.props.error) {
            var _this$props2 = this.props,
                _this$props2$data = _this$props2.data,
                _data2 = _this$props2$data === void 0 ? [] : _this$props2$data,
                _this$props2$schema = _this$props2.schema,
                schema = _this$props2$schema === void 0 ? [] : _this$props2$schema;

            this.setState({
              data: _data2,
              schema: schema,
              loading: this.props.loading || false,
              error: this.props.error || false,
              errorType: this.props.errorType,
              page: 1,
              totalRecords: _data2.length || 0,
              selectAll: getSelectAll([])
            }, function () {
              _this2.updateData();
            });
          }
        }

        if (prevState.page !== this.state.page) {
          var onPageChange = this.props.onPageChange;
          if (onPageChange) onPageChange(this.state.page);
        }

        if (prevState.page !== this.state.page || prevState.filterList !== this.state.filterList || prevState.sortingList !== this.state.sortingList || prevState.searchTerm !== this.state.searchTerm) {
          if (!this.props.loading) {
            // let errorType = "";
            // let errorCount = 0;
            // if(prevState.page !== this.state.page) errorType = "ON_PAGE_CHANGE", errorCount++;
            // if(prevState.filterList !== this.state.filterList) errorType = "ON_FILTER_CHANGE", errorCount++;
            // if(prevState.sortingList !== this.state.sortingList) errorType = "ON_SORTING_CHANGE", errorCount++;
            // if(prevState.searchTerm !== this.state.searchTerm) errorType = "ON_SEARCH_CHANGE", errorCount++;
            // this.setState({
            //   errorType: errorCount > 1 ? "FAILED_TO_FETCH" : errorType
            // });
            var searchUpdate = prevState.searchTerm !== this.state.searchTerm;
            this.updateData(searchUpdate);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props3 = this.props,
            showHead = _this$props3.showHead,
            type = _this$props3.type,
            size = _this$props3.size,
            headCellTooltip = _this$props3.headCellTooltip,
            separator = _this$props3.separator,
            draggable = _this$props3.draggable,
            nestedRows = _this$props3.nestedRows,
            nestedRowRenderer = _this$props3.nestedRowRenderer,
            withHeader = _this$props3.withHeader,
            headerOptions = _this$props3.headerOptions,
            withCheckbox = _this$props3.withCheckbox,
            showMenu = _this$props3.showMenu,
            withPagination = _this$props3.withPagination,
            paginationType = _this$props3.paginationType,
            pageSize = _this$props3.pageSize,
            onRowClick = _this$props3.onRowClick,
            loaderSchema = _this$props3.loaderSchema,
            errorTemplate = _this$props3.errorTemplate,
            className = _this$props3.className,
            filterPosition = _this$props3.filterPosition;
        var baseProps = extractBaseProps(this.props);

        var _ref = headerOptions,
            headerChildren = _ref.children,
            headerAttr = _objectWithoutProperties$a(_ref, ["children"]);

        var classes = className ? " ".concat(className) : '';
        var totalRecords = this.state.totalRecords;
        var totalPages = getTotalPages(totalRecords, pageSize);
        return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
          className: "Table".concat(classes)
        }), withHeader && /*#__PURE__*/React.createElement("div", {
          className: "Table-header"
        }, /*#__PURE__*/React.createElement(Header, _extends$p({}, this.state, {
          // updateData={updateData}
          updateSchema: this.updateSchema // updateSortingList={updateSortingList}
          ,
          updateFilterList: this.updateFilterList,
          updateSearchTerm: this.updateSearchTerm,
          showHead: showHead,
          onSelectAll: this.onSelectAll,
          withCheckbox: withCheckbox,
          withPagination: withPagination,
          showFilters: filterPosition === 'HEADER'
        }, headerAttr), headerChildren)), /*#__PURE__*/React.createElement("div", {
          className: "Table-grid"
        }, /*#__PURE__*/React.createElement(Grid, _extends$p({}, this.state, {
          updateData: this.updateData,
          updateSchema: this.updateSchema,
          updateSortingList: this.updateSortingList,
          updateFilterList: this.updateFilterList,
          withCheckbox: withCheckbox,
          onSelect: this.onSelect,
          onSelectAll: this.onSelectAll,
          showMenu: showMenu,
          showHead: showHead,
          type: type,
          size: size,
          headCellTooltip: headCellTooltip,
          separator: separator,
          draggable: draggable,
          nestedRows: nestedRows,
          nestedRowRenderer: nestedRowRenderer,
          withPagination: withPagination && totalPages > 1,
          pageSize: pageSize,
          loaderSchema: loaderSchema,
          errorTemplate: errorTemplate && errorTemplate({
            errorType: this.state.errorType
          }),
          onRowClick: onRowClick,
          showFilters: filterPosition === 'GRID'
        }))), withPagination && !this.state.loading && !this.state.error && totalPages > 1 && /*#__PURE__*/React.createElement("div", {
          className: "Table-pagination"
        }, /*#__PURE__*/React.createElement(Pagination, {
          page: this.state.page,
          totalPages: getTotalPages(totalRecords, pageSize),
          type: paginationType,
          onPageChange: this.onPageChange
        })));
      }
    }]);

    return Table;
  }(React.Component);

  _defineProperty$w(Table, "defaultProps", defaultProps);

  /**
   * **`List` is a pattern of `Table` with no Head Cells.**
   *
   * Please refer to stories of Table for examples. Simply replace `Table` with `List` to use it.
   */
  var List = function List(props) {
    return /*#__PURE__*/React.createElement(Table, _extends$p({}, props, {
      showHead: false,
      filterPosition: 'HEADER'
    }));
  };
  List.defaultProps = defaultProps;

  var useState$1 = React.useState;

  /**
   * ####NOTE: Navigation(vertical) sets first subMenu(if present) active if the Navigation is collapsed.
   */
  var Navigation = function Navigation(props) {
    var _classNames5;

    var type = props.type,
        align = props.align,
        menus = props.menus,
        active = props.active,
        onClick = props.onClick,
        expanded = props.expanded,
        rounded = props.rounded,
        onToggle = props.onToggle,
        footer = props.footer,
        autoCollapse = props.autoCollapse,
        className = props.className;
    var baseProps = extractBaseProps(props);

    var _useState = useState$1({}),
        _useState2 = _slicedToArray$6(_useState, 2),
        menuState = _useState2[0],
        setMenuState = _useState2[1];

    React.useEffect(function () {
      if (props.active) {
        var currMenu = getMenu(props.active);
        if (currMenu) updateMenuState(currMenu, true);
      }
    }, [props.active]);

    var getMenu = function getMenu(menu) {
      var _iterator = _createForOfIteratorHelper(menus),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var m = _step.value;

          if (menu.name && m.name === menu.name || menu.link && m.link === menu.link) {
            return m;
          }

          if (m.subMenu) {
            var activeMenu = m.subMenu.find(function (sm) {
              return menu.name && sm.name === menu.name || menu.link && sm.link === menu.link;
            });
            if (activeMenu) return activeMenu;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return null;
    };

    var updateMenuState = function updateMenuState(menu, val) {
      var currMenu = getMenu(menu);

      if (currMenu) {
        var nameSplit = currMenu.name.split('.');

        if (nameSplit.length > 1 || currMenu.subMenu) {
          var name = nameSplit[0];

          if (autoCollapse) {
            setMenuState(_defineProperty$w({}, name, val || !menuState[name]));
          } else {
            var menuData = _objectSpread2({}, menuState);

            menuData[name] = val !== undefined ? val : !menuData[name];
            setMenuState(menuData);
          }
        } else {
          if (autoCollapse) {
            if (!expanded) setMenuState({});
          }
        }
      }
    };

    var onClickHandler = function onClickHandler(menu) {
      if (!menu.disabled) {
        if (menu.subMenu) {
          if (!expanded) {
            if (onClick) onClick(menu.subMenu[0]);
          } else {
            updateMenuState(menu);
          }
        } else {
          if (onClick) onClick(menu);
        }
      }
    };

    var isActive = function isActive(menu) {
      if (active) {
        var currMenu = getMenu(active);
        return !!currMenu && (currMenu === menu || currMenu.name.split('.')[0] === menu.name || currMenu.name === menu.name || !!currMenu.link && currMenu.link === menu.link);
      }

      return false;
    };

    var getTextAppearance = function getTextAppearance(isMenuActive, disabled) {
      return disabled ? 'subtle' : isMenuActive ? 'link' : 'default';
    };

    var getIconAppearance = function getIconAppearance(isMenuActive, disabled) {
      return disabled ? 'subtle' : isMenuActive ? 'info' : 'default';
    };

    var getHorizontalMenu = function getHorizontalMenu(menuData) {
      var list = menuData.map(function (menu, index) {
        var _classNames;

        var isMenuActive = isActive(menu);
        var menuClasses = classnames((_classNames = {
          'Navigation-menu': true
        }, _defineProperty$w(_classNames, "Navigation-menu--".concat(type), type), _defineProperty$w(_classNames, 'Navigation-menu--active', isMenuActive), _classNames));
        return /*#__PURE__*/React.createElement("div", {
          key: index,
          className: menuClasses,
          onClick: function onClick() {
            return onClickHandler(menu);
          }
        }, menu.icon && /*#__PURE__*/React.createElement(Icon, {
          className: "mr-3",
          name: menu.icon,
          appearance: getIconAppearance(isMenuActive, menu.disabled)
        }), /*#__PURE__*/React.createElement(Text$1, {
          appearance: getTextAppearance(isMenuActive, menu.disabled)
        }, menu.label));
      });
      return list;
    };

    var getVerticalMenu = function getVerticalMenu() {
      var list = menus.map(function (menu, index) {
        var _classNames2;

        var activeMenu = expanded && !menuState[menu.name] && isActive(menu);
        var activeMenuIcon = !expanded && isActive(menu) || activeMenu;
        var menuClasses = classnames((_classNames2 = {
          'Navigation-menu': true
        }, _defineProperty$w(_classNames2, "Navigation-menu--".concat(type), type), _defineProperty$w(_classNames2, 'Navigation-menu--active', activeMenu), _defineProperty$w(_classNames2, 'Navigation-menu--rounded', type === 'vertical' && expanded && rounded), _classNames2));
        var menuIconClasses = classnames({
          'Navigation-menuIcon': true,
          'Navigation-menuIcon--active': activeMenuIcon
        });
        return /*#__PURE__*/React.createElement("div", {
          key: index
        }, /*#__PURE__*/React.createElement("div", {
          className: menuClasses,
          onClick: function onClick() {
            return onClickHandler(menu);
          }
        }, menu.icon && /*#__PURE__*/React.createElement(Icon, {
          className: menuIconClasses,
          name: menu.icon,
          appearance: getIconAppearance(activeMenuIcon, menu.disabled)
        }), expanded && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
          className: "Navigation-menuLabel"
        }, /*#__PURE__*/React.createElement(Text$1, {
          appearance: getTextAppearance(activeMenu, menu.disabled)
        }, menu.label)), menu.subMenu && menu.subMenu.length > 0 && /*#__PURE__*/React.createElement(Icon, {
          className: "mx-4",
          name: menuState[menu.name] ? 'keyboard_arrow_up' : 'keyboard_arrow_down',
          appearance: "subtle"
        }))), /*#__PURE__*/React.createElement("div", {
          className: "Navigation-subMenu"
        }, menuState[menu.name] && menu.subMenu && expanded && menu.subMenu.map(function (subMenu, ind) {
          var _classNames3;

          var isMenuActive = isActive(subMenu);
          var subMenuClasses = classnames(menuClasses, (_classNames3 = {}, _defineProperty$w(_classNames3, 'Navigation-menu--subMenu', type), _defineProperty$w(_classNames3, 'Navigation-menu--active', isMenuActive), _classNames3));
          return /*#__PURE__*/React.createElement("div", {
            key: ind,
            className: subMenuClasses,
            onClick: function onClick() {
              return onClickHandler(subMenu);
            }
          }, /*#__PURE__*/React.createElement(Text$1, {
            appearance: getTextAppearance(isMenuActive, subMenu.disabled)
          }, subMenu.label));
        })));
      });
      var footerClasses = classnames(_defineProperty$w({
        'Navigation-footer': true
      }, 'Navigation-footer--border', true));
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
        className: "Navigation-body"
      }, list), footer && /*#__PURE__*/React.createElement("div", {
        className: footerClasses
      }, /*#__PURE__*/React.createElement(Icon, {
        className: "Navigation-menuIcon Navigation-menuIcon--footer",
        name: "menu_open",
        size: 16,
        onClick: function onClick() {
          return onToggle && onToggle(!expanded);
        }
      })));
    };

    var classes = classnames((_classNames5 = {}, _defineProperty$w(_classNames5, 'Navigation', true), _defineProperty$w(_classNames5, "Navigation--".concat(type), type), _defineProperty$w(_classNames5, 'justify-content-center', type === 'horizontal' && align === 'center'), _defineProperty$w(_classNames5, 'justify-content-start', type === 'horizontal' && align === 'left'), _defineProperty$w(_classNames5, 'Navigation--collapsed', !expanded), _classNames5), className);
    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: classes
    }), type === 'horizontal' ? getHorizontalMenu(menus) : getVerticalMenu());
  };
  Navigation.defaultProps = {
    type: 'horizontal',
    align: 'center',
    expanded: true,
    autoCollapse: true,
    rounded: false
  };

  var PageHeader = function PageHeader(props) {
    var _classNames;

    var title = props.title,
        navigation = props.navigation,
        stepper = props.stepper,
        actions = props.actions,
        tabs = props.tabs,
        breadcrumbs = props.breadcrumbs,
        badge = props.badge,
        separator = props.separator,
        status = props.status,
        meta = props.meta,
        navigationPosition = props.navigationPosition,
        className = props.className;
    var baseProps = extractBaseProps(props);
    var wrapperClasses = classnames((_classNames = {
      'PageHeader-wrapper': true
    }, _defineProperty$w(_classNames, 'PageHeader-wrapper--separator', separator), _defineProperty$w(_classNames, 'PageHeader-wrapper--withTabs', tabs), _classNames), className);
    var classes = classnames({
      PageHeader: true
    });

    var renderCenter = function renderCenter() {
      return navigation ? navigation : stepper;
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: wrapperClasses
    }), breadcrumbs, /*#__PURE__*/React.createElement("div", {
      className: classes
    }, /*#__PURE__*/React.createElement(Row, null, /*#__PURE__*/React.createElement(Column, {
      size: "4",
      sizeXL: "4",
      sizeM: "4"
    }, /*#__PURE__*/React.createElement("div", {
      className: "PageHeader-titleWrapper"
    }, /*#__PURE__*/React.createElement(Heading, {
      className: "PageHeader-title"
    }, title), badge)), /*#__PURE__*/React.createElement(Column, {
      size: "4",
      sizeXL: "4",
      sizeM: "4"
    }, /*#__PURE__*/React.createElement("div", {
      className: "PageHeader-navigationWrapper"
    }, (!breadcrumbs || navigationPosition === 'center') && renderCenter())), /*#__PURE__*/React.createElement(Column, {
      size: "4",
      sizeXL: "4",
      sizeM: "4"
    }, actions))), (status || meta) && /*#__PURE__*/React.createElement("div", {
      className: "PageHeader-statusWrapper"
    }, status, meta), breadcrumbs && navigationPosition === 'bottom' && /*#__PURE__*/React.createElement("div", {
      className: "PageHeader-navigationWrapper"
    }, renderCenter()), tabs && /*#__PURE__*/React.createElement("div", null, tabs));
  };
  PageHeader.defaultProps = {
    navigationPosition: 'center',
    separator: true
  };

  var useEffect = React.useEffect,
      useState = React.useState;
  var IconMapping = {
    audio: 'audiotrack',
    image: 'image',
    video: 'movie',
    application: 'insert_drive_file',
    others: 'text_snippet'
  };
  var FileIcon = function FileIcon(props) {
    var _classNames, _classNames2;

    var progress = props.progress,
        status = props.status,
        file = props.file;

    var _useState = useState(false),
        _useState2 = _slicedToArray$6(_useState, 2),
        animate = _useState2[0],
        setAnimate = _useState2[1];

    var type = file.type.split('/')[0] || 'others';
    var fileType = IconMapping[type] ? type : 'others';
    var iconClass = classnames((_classNames = {}, _defineProperty$w(_classNames, 'FileIcon', true), _defineProperty$w(_classNames, 'FileIcon--animate', animate), _defineProperty$w(_classNames, "FileIcon--".concat(fileType), true), _classNames));
    var uploadingIconClass = classnames((_classNames2 = {}, _defineProperty$w(_classNames2, 'FileIcon', true), _defineProperty$w(_classNames2, 'FileIcon--uploading', true), _classNames2));
    useEffect(function () {
      if (status === 'completed') {
        setAnimate(true);
      } else {
        setAnimate(false);
      }
    }, [status]);

    if (status === 'uploading') {
      return /*#__PURE__*/React.createElement(ProgressRing, {
        size: "small",
        value: progress || 0,
        className: uploadingIconClass
      });
    }

    return /*#__PURE__*/React.createElement(Icon, {
      name: IconMapping[fileType],
      className: iconClass
    });
  };
  FileIcon.displayName = 'FileIcon';
  FileIcon.defaultProps = {
    progress: 0,
    status: 'completed'
  };

  var FileListItem = function FileListItem(props) {
    var progress = props.progress,
        errorMessage = props.errorMessage,
        onClick = props.onClick,
        className = props.className,
        actions = props.actions,
        fileItem = props.fileItem,
        file = props.file,
        status = props.status,
        fileSize = props.fileSize;
    var name = file.name;
    var baseProps = extractBaseProps(props);
    var FileItemClass = classnames(_defineProperty$w({}, 'FileItem', true), className);

    var onClickHandler = function onClickHandler() {
      if (onClick) {
        onClick(fileItem);
      }
    };

    return /*#__PURE__*/React.createElement("div", _extends$p({}, baseProps, {
      className: FileItemClass,
      onClick: onClickHandler
    }), /*#__PURE__*/React.createElement("div", {
      className: "FileItem-file"
    }, /*#__PURE__*/React.createElement("div", {
      className: "FileItem-fileContent"
    }, /*#__PURE__*/React.createElement(FileIcon, {
      file: file,
      status: status,
      progress: progress
    }), /*#__PURE__*/React.createElement(Text$1, {
      className: "FileItem-text",
      appearance: status === 'completed' ? 'default' : 'subtle'
    }, name)), /*#__PURE__*/React.createElement("div", {
      className: "FileItem-actions"
    }, /*#__PURE__*/React.createElement(Text$1, {
      className: "FileItem-size",
      appearance: 'subtle'
    }, fileSize || file.size), !!actions && actions)), status === 'error' && /*#__PURE__*/React.createElement(Caption, {
      className: 'FileItem-error',
      error: true
    }, errorMessage));
  };
  FileListItem.defaultProps = {
    progress: 0,
    errorMessage: 'Network Error'
  };
  FileListItem.displayName = 'FileListItem';

  var FileList = function FileList(props) {
    var fileList = props.fileList,
        onClick = props.onClick,
        actionRenderer = props.actionRenderer,
        className = props.className;
    var baseProps = extractBaseProps(props);
    if (fileList.length === 0) return null;
    return /*#__PURE__*/React.createElement(Card, _extends$p({}, baseProps, {
      shadow: 'none',
      className: className
    }), fileList.map(function (fileItem, index) {
      return /*#__PURE__*/React.createElement(FileListItem, _extends$p({
        key: index,
        onClick: onClick,
        actions: actionRenderer && actionRenderer(fileItem),
        fileItem: fileItem
      }, fileItem));
    }));
  };
  FileList.defaultProps = {
    fileList: []
  };
  FileList.displayName = 'FileList';

  var version = "1.7.1-0";

  exports.Avatar = Avatar;
  exports.AvatarGroup = AvatarGroup;
  exports.Backdrop = Backdrop;
  exports.Badge = Badge;
  exports.Breadcrumbs = Breadcrumbs;
  exports.Button = Button;
  exports.Caption = Caption;
  exports.Card = Card;
  exports.ChatMessage = ChatMessage;
  exports.Checkbox = Checkbox;
  exports.Chip = Chip;
  exports.ChipGroup = ChipGroup;
  exports.Column = Column;
  exports.DatePicker = DatePicker;
  exports.DateRangePicker = DateRangePicker;
  exports.Dialog = Dialog;
  exports.DonutChart = DonutChart;
  exports.Dropdown = Dropdown;
  exports.Dropzone = Dropzone;
  exports.EditableDropdown = EditableDropdown;
  exports.EditableInput = EditableInput;
  exports.EmptyState = EmptyState;
  exports.FileList = FileList;
  exports.FileUploader = FileUploader;
  exports.FileUploaderList = FileUploaderList;
  exports.FullscreenModal = FullscreenModal;
  exports.Grid = Grid;
  exports.GridCell = GridCell;
  exports.Heading = Heading;
  exports.Icon = Icon;
  exports.Input = Input;
  exports.InputMask = InputMask;
  exports.Label = Label;
  exports.Legend = Legend;
  exports.Link = Link;
  exports.List = List;
  exports.Message = Message;
  exports.MetaList = MetaList;
  exports.Modal = Modal;
  exports.ModalBody = ModalBody;
  exports.ModalDescription = ModalDescription;
  exports.ModalFooter = ModalFooter;
  exports.ModalHeader = ModalHeader;
  exports.Navigation = Navigation;
  exports.OutsideClick = OutsideClick;
  exports.PageHeader = PageHeader;
  exports.Pagination = Pagination;
  exports.Paragraph = Paragraph;
  exports.Pills = Pills;
  exports.Placeholder = Placeholder;
  exports.PlaceholderParagraph = PlaceholderParagraph;
  exports.Popover = Popover;
  exports.ProgressBar = ProgressBar;
  exports.ProgressRing = ProgressRing;
  exports.Radio = Radio;
  exports.RangeSlider = RangeSlider;
  exports.Row = Row;
  exports.Sidesheet = Sidesheet;
  exports.Slider = Slider;
  exports.Spinner = Spinner;
  exports.StatusHint = StatusHint;
  exports.Stepper = Stepper;
  exports.Subheading = Subheading;
  exports.Switch = Switch;
  exports.Tab = Tab;
  exports.Table = Table;
  exports.TabsWrapper = TabsWrapper;
  exports.Text = Text$1;
  exports.Textarea = Textarea;
  exports.TimePicker = TimePicker;
  exports.Toast = Toast;
  exports.Tooltip = Tooltip;
  exports.Utils = index$1;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
